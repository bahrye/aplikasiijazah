// =================================================================
// KONFIGURASI GLOBAL
// =================================================================

// PENTING: Ganti dengan ID Spreadsheet Template yang sudah Anda buat.
// Anda bisa mendapatkan ID ini dari URL spreadsheet template Anda.
// Contoh URL: https://docs.google.com/spreadsheets/d/INI_ADALAH_ID_NYA/edit
const TEMPLATE_SPREADSHEET_ID = "14u86jJydOZu-nsTRTH_dOGIBhvLLIObLkbXsHrJ0xhM"; 

// Nama-nama Sheet yang digunakan di dalam spreadsheet data setiap sekolah.
const SHEET_PENGGUNA = "Data Pengguna"; // Ini ada di spreadsheet induk
const SHEET_DATA_SEKOLAH = "Data Sekolah";
const SHEET_DATA_SISWA = "Data Siswa";
const SHEET_MAPEL = "Data Mata Pelajaran";
const SHEET_BOBOT = "Data Bobot Nilai";
const SHEET_NILAI_UJIAN_MADRASAH = "Nilai Ujian Madrasah";
const SHEET_NILAI_UJIAN_PRAKTEK = "Nilai Ujian Praktek";
const SHEET_REKAP_UJIAN = "Rekap Nilai Ujian";
const SHEET_REKAP_RAPOR = "Rekap Nilai Rapor";
const SHEET_REKAP_IJAZAH = "Rekap Nilai Ijazah";
const SHEET_MAPEL_DEFAULT = "Mapel Default"; // Sheet di Spreadsheet Induk untuk mapel standar
const SHEET_LOG = 'Log Aktivitas';
const SHEET_VERSI = 'Versi Aplikasi'; // Sheet baru untuk info update
const SHEET_BACKUP_REGISTRY = "Data Backup Terdaftar";
const SHEET_PENGAJUAN = "Data Pengajuan"; // <-- TAMBAHAN DARI SEBELUMNYA
const SHEET_DASHBOARD_CACHE = "Cache Dashboard"; // <-- TAMBAHKAN BARIS INI
const SHEET_PENGATURAN = "Pengaturan"; // <-- TAMBAHKAN BARIS INI
// ===== AWAL KODE TAMBAHAN =====
const SHEET_BROADCAST = "Pesan Broadcast";
const SHEET_LAST_SEEN_BROADCAST = "Last Seen Broadcast ID"; // Nama kolom di 'Data Pengguna'
const SHEET_BROADCAST_READ_STATUS = "Status Baca Broadcast";
// ===== AKHIR KODE TAMBAHAN =====
const SHEET_CACHE_AKUN = "Cache Akun";
const SHEET_SARAN = "Saran & Masalah";
const SHEET_WILAYAH = "Data Wilayah";
const SHEET_DATA_GURU = "Data Guru";
const SHEET_NILAI_GURU_DRAFT = "Draf Nilai Guru";
const SHEET_NILAI_GURU_SUBMITTED = "Nilai Terkirim Guru";
const SHEET_PENGAJUAN_NILAI = "Pengajuan Nilai"; // [BARU]
const SHEET_QR_REDIRECTS = "QR_Redirects"; 


/**
 * [MODIFIKASI FINAL] Fungsi utama yang menangani permintaan GET.
 * Sekarang mengenali halaman Portal Guru, Siswa, dan Validasi.
 */
function doGet(e) {
  const webAppUrl = ScriptApp.getService().getUrl();

  if (e.parameter.v) {
    try {
      const shortCode = e.parameter.v;
      
      // 1. Cari token di sheet "QR_Redirects"
      const masterSs = SpreadsheetApp.getActiveSpreadsheet();
      const qrSheet = masterSs.getSheetByName(SHEET_QR_REDIRECTS);
      let fullToken = null;

      if (qrSheet && qrSheet.getLastRow() > 1) {
        const data = qrSheet.getRange(2, 1, qrSheet.getLastRow() - 1, 2).getValues();
        const foundRow = data.find(row => row[0] === shortCode);
        if (foundRow) {
          fullToken = foundRow[1]; // Ambil token dari kolom kedua
        }
      }

      if (fullToken) {
        // 2. Jika token ditemukan, bangun halaman validasi
        return buildValidationPage(fullToken);
      } else {
        // 3. Jika kode tidak ditemukan, tampilkan halaman error
        return createErrorPage(
          "Kode Tidak Valid", 
          "Kode validasi yang Anda tuju tidak ditemukan atau sudah tidak berlaku. Pastikan Anda memindai QR Code yang benar dan valid."
        );
      }
    } catch (err) {
      return createErrorPage("Terjadi Kesalahan", `Gagal memproses permintaan Anda. Error: ${err.message}`);
    }
  }

  const page = e.parameter.page;

  // Cek jika halaman yang diminta adalah 'validasi' dan ada parameter 'token'
  if (page === 'validasi' && e.parameter.token) {
    const token = e.parameter.token;
    // Panggil fungsi yang membangun halaman validasi HTML
    return buildValidationPage(token); // Fungsi ini sudah Anda miliki
  }
  if (page === 'siswa') {
    const template = HtmlService.createTemplateFromFile('Siswa.html');
    template.webAppUrl = webAppUrl;
    return template.evaluate()
      .setTitle('Portal Siswa')
      .setFaviconUrl("https://i.imgur.com/XX5e5Pe.png")
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
  } 
  // ===== BLOK BARU UNTUK HALAMAN GURU =====
  else if (page === 'guru') {
    const template = HtmlService.createTemplateFromFile('Guru.html');
    template.webAppUrl = webAppUrl;
    return template.evaluate()
      .setTitle('Portal Guru') // Judul halaman untuk guru
      .setFaviconUrl("https://i.imgur.com/PjdWlTG.png") // Contoh ikon baru
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
  }
  else {
    // Halaman default (Index.html) untuk admin/pengguna
    const template = HtmlService.createTemplateFromFile('Index');
    template.webAppUrl = webAppUrl;
    return template.evaluate()
      .setTitle('Aplikasi Pengolahan Nilai Ijazah by Syamsul Bahri')
      .setFaviconUrl("https://i.imgur.com/C0cZOT0.png")
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
  }
}

/**
 * [BARU] Mengambil informasi versi aplikasi terbaru dari Spreadsheet Induk.
 * @returns {object|null} Objek berisi detail versi terbaru atau null jika gagal.
 */
function getAppVersionInfo() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const versionSheet = ss.getSheetByName(SHEET_VERSI);

    // Jika sheet tidak ada atau hanya ada header
    if (!versionSheet || versionSheet.getLastRow() < 2) {
      return null;
    }

    // Ambil data dari baris teratas (baris ke-2)
    const latestVersionData = versionSheet.getRange(2, 1, 1, 3).getValues()[0];
    const version = latestVersionData[0];
    const releaseDate = latestVersionData[1];
    const changelog = latestVersionData[2];

    if (!version) {
      return null; // Jika kolom versi kosong, jangan kirim apa-apa
    }

    return {
      version: version.toString().trim(),
      releaseDate: releaseDate instanceof Date ? releaseDate.toISOString().split('T')[0] : releaseDate,
      // Ubah catatan perubahan yang dipisahkan baris baru menjadi array HTML (<li>)
      changelog: changelog.split('\n').map(line => line.trim()).filter(line => line)
    };

  } catch (e) {
    Logger.log("Error in getAppVersionInfo: " + e.message);
    return null; // Jangan hentikan aplikasi jika fitur ini gagal
  }
}
// =================================================================
// FUNGSI KEAMANAN (PASSWORD HASHING) - [BARU]
// =================================================================

/**
 * [BARU] Menghasilkan string acak untuk digunakan sebagai salt.
 * @returns {string} Salt yang dihasilkan.
 */
function generateSalt() {
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

/**
 * [BARU & DIPERBAIKI] Menghasilkan hash dari password dan salt menggunakan SHA-256.
 * @param {string} password Password teks biasa.
 * @param {string} salt Salt yang akan digunakan.
 * @returns {string} Hash dalam format heksadesimal.
 */
function hashPassword(password, salt) {
  const saltedPassword = password + salt;
  const digest = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, saltedPassword, Utilities.Charset.UTF_8);
  
  let hexString = '';
  for (let i = 0; i < digest.length; i++) {
    // --- PERBAIKAN ---
    // Ubah 'const' menjadi 'let' agar nilainya bisa dimodifikasi.
    let byte = digest[i]; 
    if (byte < 0) {
      byte += 256;
    }
    // --- AKHIR PERBAIKAN ---
    
    let hex = byte.toString(16); // 'hex' bisa tetap 'let' atau 'const'
    if (hex.length === 1) {
      hexString += '0';
    }
    hexString += hex;
  }
  return hexString;
}

/**
 * [BARU] Memverifikasi password teks biasa terhadap format 'salt:hash' yang tersimpan.
 * @param {string} plainPassword Password yang dimasukkan pengguna saat login.
 * @param {string} saltAndHash String yang tersimpan di database ('salt:hash').
 * @returns {boolean} True jika password cocok, false jika tidak.
 */
function verifyPassword(plainPassword, saltAndHash) {
  try {
    const parts = saltAndHash.split(':');
    if (parts.length !== 2) {
      // Ini bukan format hash yang kita harapkan, anggap saja tidak valid.
      return false;
    }
    const salt = parts[0];
    const storedHash = parts[1];
    const newHash = hashPassword(plainPassword, salt);
    return newHash === storedHash;
  } catch (e) {
    Logger.log("Error during password verification: " + e.message);
    return false;
  }
}

// =================================================================
// FUNGSI AUTENTIKASI DAN MANAJEMEN AKUN (DENGAN OTP)
// =================================================================

/**
 * [MODIFIKASI] Membuat dan menyimpan OTP sementara menggunakan kunci cache yang konsisten.
 * @param {string} email Email tujuan untuk OTP.
 * @returns {string} OTP yang dibuat.
 */
function generateAndStoreOtp(email) {
  const otp = Math.floor(100000 + Math.random() * 900000).toString();
  const cache = CacheService.getScriptCache();
  // [PERBAIKAN] Gunakan email lowercase sebagai kunci cache untuk konsistensi
  const cacheKey = email.toLowerCase();
  cache.put(cacheKey, otp, 600); // 600 detik = 10 menit
  return otp;
}

/**
 * [MODIFIKASI] Memvalidasi OTP yang dimasukkan pengguna dengan logging tambahan.
 * @param {string} email Email yang diverifikasi.
 * @param {string} otp Kode OTP dari pengguna.
 * @returns {boolean} True jika valid, false jika tidak.
 */
function verifyOtp(email, otp) {
  const cache = CacheService.getScriptCache();
  // [PERBAIKAN] Gunakan email lowercase untuk mengambil dari cache
  const cacheKey = email.toLowerCase();
  const storedOtp = cache.get(cacheKey);

  // [DEBUG] Tambahkan logging untuk membantu melacak masalah di masa depan
  Logger.log(`Verifikasi OTP untuk email: ${email} (key: ${cacheKey})`);
  Logger.log(`OTP dari pengguna: "${otp}" (tipe: ${typeof otp})`);
  Logger.log(`OTP dari cache: "${storedOtp}" (tipe: ${typeof storedOtp})`);
  
  // Perbandingan ketat antara OTP yang disimpan (string) dan yang dimasukkan (string)
  const isValid = storedOtp != null && storedOtp === otp.toString();
  Logger.log(`Hasil validasi: ${isValid}`);
  
  return isValid;
}

/**
 * [MODIFIKASI] Mengirim email verifikasi, menggunakan email yang sudah dinormalisasi.
 * @param {string} email Email calon pengguna.
 * @returns {{status: string, message: string}} Hasil proses pengiriman.
 */
function sendVerificationEmail(email) {
  try {
    if (!email) {
      return { status: "error", message: "Email tidak boleh kosong." };
    }
    const normalizedEmail = email.toLowerCase(); // [PERBAIKAN] Normalisasi email

    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);

    if (userSheet.getLastRow() > 1) {
        const dataRange = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1);
        const existingEmails = dataRange.getValues().flat();
        // [PERBAIKAN] Bandingkan dengan email yang sudah dinormalisasi
        if (existingEmails.some(existingEmail => existingEmail.toLowerCase() === normalizedEmail)) {
          lock.releaseLock();
          return { status: "error", message: "Email sudah terdaftar. Silakan gunakan email lain." };
        }
    }
    
    lock.releaseLock();

    // [PERBAIKAN] Gunakan email yang sudah dinormalisasi untuk generate OTP
    const otp = generateAndStoreOtp(normalizedEmail);
    const subject = "Kode Verifikasi Pendaftaran Akun";
    const body = `
      <div style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2>Verifikasi Akun Anda</h2>
        <p>Terima kasih telah mendaftar. Silakan gunakan kode verifikasi di bawah ini untuk menyelesaikan proses pendaftaran Anda:</p>
        <p style="font-size: 24px; font-weight: bold; letter-spacing: 5px; background-color: #f0f0f0; padding: 10px 20px; border-radius: 5px; display: inline-block;">${otp}</p>
        <p>Kode ini hanya berlaku selama 10 menit.</p>
        <p>Jika Anda tidak merasa mendaftar, abaikan email ini.</p>
        <br>
        <p>Terima kasih,</p>
        <p>Tim Aplikasi Pengolahan Nilai Ijazah</p>
      </div>
    `;

    MailApp.sendEmail({
      to: email, // Kirim ke email asli, bukan yang lowercase
      subject: subject,
      htmlBody: body
    });

    return { status: "success", message: "Kode OTP telah dikirim ke email Anda. Silakan periksa kotak masuk atau folder spam." };

  } catch (error) {
    Logger.log(`sendVerificationEmail Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengirim email verifikasi: " + error.message };
  }
}


// File: Kode.gs.html

/**
 * [MODIFIKASI FINAL v3 + NOTIFIKASI EMAIL] Mendaftarkan pengguna baru dengan KODE SEKOLAH unik
 * dan mengirimkan email konfirmasi pendaftaran.
 * @param {{email: string, password: string, namaSekolah: string, jenjang: string}} userData Objek berisi data pengguna baru.
 * @param {string} otp Kode OTP yang dimasukkan pengguna.
 * @returns {{status: string, message: string}} Objek status pendaftaran.
 */
function registerUser(userData, otp) {
  try {
    const { email, password, namaSekolah, jenjang } = userData;
    if (!verifyOtp(email, otp)) {
      return { status: "error", message: "Kode OTP salah atau telah kedaluwarsa." };
    }
    const lock = LockService.getScriptLock();
    lock.waitLock(300000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const configSheet = ss.getSheetByName('Konfigurasi Sistem');
    const defaultLimit = configSheet ? configSheet.getRange("B2").getValue() : 100;
    let userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);
    
    let schoolCode;
    let isCodeUnique = false;
    const existingCodes = userSheet.getLastRow() > 1 ? userSheet.getRange(2, 13, userSheet.getLastRow() - 1, 1).getValues().flat() : [];
    
    while (!isCodeUnique) {
      schoolCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      if (!existingCodes.includes(schoolCode)) {
        isCodeUnique = true;
      }
    }
    
    const latestVersionInfo = getAppVersionInfo();
    const latestVersion = latestVersionInfo ? latestVersionInfo.version : '';

    if (userSheet.getLastRow() > 1) {
      const existingEmails = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1).getValues().flat();
      if (existingEmails.some(e => e.toLowerCase() === email.toLowerCase())) {
        lock.releaseLock();
        return { status: "error", message: "Email sudah terdaftar." };
      }
    }

    const templateFile = DriveApp.getFileById(TEMPLATE_SPREADSHEET_ID);
    const newFile = templateFile.makeCopy(`Data Akademik - ${namaSekolah}`);
    const newSpreadsheetId = newFile.getId();
    const newSs = SpreadsheetApp.openById(newSpreadsheetId);
    const dataSekolahSheet = newSs.getSheetByName(SHEET_DATA_SEKOLAH);
    if (dataSekolahSheet) {
      dataSekolahSheet.getRange(2, 1).setValue(jenjang);
      dataSekolahSheet.getRange(2, 2).setValue(namaSekolah);
    }

    const userId = Utilities.getUuid();
    const salt = generateSalt();
    const hashedPassword = hashPassword(password, salt);
    const storedPasswordString = `${salt}:${hashedPassword}`;

    userSheet.appendRow([
        userId, email, storedPasswordString, namaSekolah, jenjang, newSpreadsheetId,
        'Pengguna', 'Aktif', defaultLimit, latestVersion, '', '', schoolCode, '', 'YA'
    ]);
    
    // ===== AWAL BLOK KODE BARU UNTUK NOTIFIKASI EMAIL =====
    try {
      const subject = "Pendaftaran Akun Aplikasi Ijazah Berhasil!";
      const body = `
        <div style="font-family: Arial, sans-serif; line-height: 1.6;">
          <h2>Selamat Datang di Aplikasi Pengolahan Nilai Ijazah!</h2>
          <p>Halo <strong>${namaSekolah}</strong>,</p>
          <p>Akun Anda telah berhasil dibuat. Berikut adalah detail informasi login Anda. Harap simpan informasi ini di tempat yang aman:</p>
          <div style="background-color: #f9f9f9; border: 1px solid #ddd; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <p style="margin: 5px 0;"><strong>Email:</strong> ${email}</p>
            <p style="margin: 5px 0;"><strong>Password:</strong> ${password}</p>
          </div>
          <p>Anda dapat mulai menggunakan aplikasi dengan mengunjungi link di bawah ini.</p>
          <p><a href="${ScriptApp.getService().getUrl()}" style="display: inline-block; padding: 10px 20px; background-color: #007bff; color: #ffffff; text-decoration: none; border-radius: 5px;">Buka Aplikasi</a></p>
          <br>
          <p>Terima kasih,</p>
          <p>Tim Aplikasi</p>
        </div>
      `;
      MailApp.sendEmail({
        to: email,
        subject: subject,
        htmlBody: body
      });
      Logger.log("Email konfirmasi pendaftaran berhasil dikirim ke: " + email);
    } catch (e) {
      // Mencatat log jika email gagal terkirim, namun tidak menghentikan proses pendaftaran utama.
      Logger.log("Gagal mengirim email konfirmasi pendaftaran ke " + email + ". Error: " + e.message);
    }
    // ===== AKHIR BLOK KODE BARU =====

    CacheService.getScriptCache().remove(email.toLowerCase());
    lock.releaseLock();
    return { status: "success", message: "Pendaftaran berhasil! Akun dan database sekolah Anda telah dibuat." };

  } catch (error) {
    Logger.log(error);
    return { status: "error", message: "Gagal mendaftar: " + error.message + " Stack: " + error.stack };
  }
}

/**
 * [MODIFIKASI FINAL & BROADCAST v2] Memeriksa kredensial login.
 * Menangani kasus Superadmin, status akun, dan mengirimkan changelog & broadcast baru.
 * @param {string} email Email pengguna.
 * @param {string} password Password pengguna.
 * @returns {object} Objek status login, bisa berisi data changelog atau broadcast baru.
 */
function checkLogin(email, password) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet || userSheet.getLastRow() < 2) {
      return { status: "error", message: "Konfigurasi pengguna tidak ditemukan." };
    }

    const users = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 12).getValues(); 
    const userIndex = users.findIndex(userRow => userRow[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Email tidak terdaftar." };
    }

    const userRow = users[userIndex];
    const storedPassword = userRow[2].toString(); 
    let spreadsheetId = userRow[5];
    const role = userRow[6] || 'Pengguna';
    const status = userRow[7] || 'Aktif';
    const lastSeenChangelogVersion = (userRow[10] || '').toString().trim();

    if (status !== 'Aktif') {
        return { status: "error", message: "Akun Anda saat ini tidak aktif. Silahkan hubungi Admin." };
    }

    if (role === 'Superadmin') {
      spreadsheetId = null;  
    } else if (!spreadsheetId) {
      return { status: "error", message: "Akun pengguna ini tidak terkonfigurasi dengan benar (tidak ada Spreadsheet ID)." };
    }

    let passwordIsValid = false;
    if (storedPassword.includes(':')) {
      passwordIsValid = verifyPassword(password, storedPassword);
    } else {
      passwordIsValid = (storedPassword === password);
      if (passwordIsValid) {
        try {
          const salt = generateSalt();
          const newHashedPassword = hashPassword(password, salt);
          userSheet.getRange(userIndex + 2, 3).setValue(`${salt}:${newHashedPassword}`);
        } catch (e) {
          Logger.log(`Failed to upgrade password for ${email}. Error: ${e.message}`);
        }
      }
    }

    // Ganti bagian ini di dalam fungsi checkLogin
    if (passwordIsValid) {
      logLoginActivity(email, userRow[3], userRow[4], role);

      // --- AWAL MODIFIKASI ---
      const lockStatus = checkFiturLock(email);
      // --- AKHIR MODIFIKASI ---

      const loginResponse = {  
          status: "success",  
          message: "Login berhasil.",  
          spreadsheetId: spreadsheetId,  
          email: userRow[1],  
          role: role,  
          webAppUrl: ScriptApp.getService().getUrl(),
          // --- AWAL MODIFIKASI ---
          isLocked: lockStatus.isLocked // Kirim status lock ke frontend
          // --- AKHIR MODIFIKASI ---
      };

      if (role === 'Pengguna') {
        const latestVersionInfo = getAppVersionInfo();
        if (latestVersionInfo && latestVersionInfo.version !== lastSeenChangelogVersion) {
          loginResponse.newChangelog = latestVersionInfo;
        }

        // --- PERUBAHAN UTAMA LOGIKA BROADCAST ---
        const latestBroadcast = getLatestBroadcast();
        if (latestBroadcast) {
          // Cek apakah pengguna ini sudah membaca broadcast terbaru
          const hasRead = hasUserReadBroadcast(latestBroadcast.id, email);
          if (!hasRead) {
            loginResponse.newBroadcast = latestBroadcast;
          }
        }
        // --- AKHIR PERUBAHAN ---
      }
      
      return loginResponse;

    } else {
      return { status: "error", message: "Password salah." };
    }

  } catch (error) {
    Logger.log(error);
    return { status: "error", message: "Kesalahan Server: " + error.message };
  }
}

/**
 * [VERSI FINAL & DIPERBAIKI] Memperbarui 'Versi Changelog Terakhir Dilihat' untuk pengguna spesifik.
 * @param {string} userEmail - Email pengguna yang sesi-nya akan diperbarui, dikirim dari frontend.
 * @param {string} version - Versi changelog yang baru saja dilihat oleh pengguna.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function updateLastSeenChangelogVersion(userEmail, version) {
  try {
    // Gunakan userEmail yang dikirim dari frontend, yang didapat dari sessionStorage.
    if (!userEmail || !version) {
      throw new Error("Email pengguna atau versi tidak boleh kosong.");
    }
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) {
      throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);
    }

    // Cari baris berdasarkan email yang dikirim dari frontend
    const emailColumn = userSheet.getRange("B2:B").getValues().flat();
    const userIndex = emailColumn.findIndex(email => email && email.toLowerCase() === userEmail.toLowerCase());

    if (userIndex !== -1) {
      const rowToUpdate = userIndex + 2;
      const targetCell = userSheet.getRange(rowToUpdate, 11); // Kolom K
      
      targetCell.setNumberFormat('@');
      targetCell.setValue(version); 
      
      return { status: 'success', message: 'Status changelog berhasil diperbarui.' };
    } else {
      // Ini jarang terjadi jika pengguna sudah login, tapi sebagai pengaman.
      throw new Error(`Pengguna dengan email ${userEmail} tidak ditemukan untuk update status changelog.`);
    }

  } catch (e) {
    Logger.log(`updateLastSeenChangelogVersion Error: ${e.message}`);
    return { status: 'error', message: e.message };
  }
}

/**
 * [DIPERBARUI] Mengambil riwayat semua aktivitas login pengguna dari 'Log Aktivitas'.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek berisi data riwayat login.
 */
function getLoginHistory_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak. Hanya Superadmin yang dapat mengakses riwayat login.");
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const logSheet = ss.getSheetByName(SHEET_LOG);
    
    // Jika sheet log belum ada atau kosong, kembalikan array kosong.
    if (!logSheet || logSheet.getLastRow() < 2) {
        return [];
    }

    // Baca semua data dari sheet log kecuali baris header
    const dataRange = logSheet.getRange(2, 1, logSheet.getLastRow() - 1, 5);
    const values = dataRange.getValues();

    const loginHistory = values
      .map(row => ({
        timestamp: row[0],      // Kolom A: Timestamp
        namaSekolah: row[2],    // Kolom C: Nama Sekolah
        jenjang: row[3],        // Kolom D: Jenjang
        role: row[4]            // Kolom E: Role
      }))
      .filter(log => log.role === 'Pengguna') // Tetap filter hanya untuk 'Pengguna'
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime()) // Urutkan dari yang paling baru
      .slice(0, 50); // Ambil 50 aktivitas terbaru agar dashboard tidak lambat

    // Ubah format data agar sesuai dengan yang diharapkan frontend
    return loginHistory.map(item => ({
      namaSekolah: item.namaSekolah,
      jenjang: item.jenjang,
      loginTimestamp: item.timestamp.toISOString() // Gunakan key 'loginTimestamp'
    }));

  } catch (e) {
    Logger.log(`getLoginHistory_Superadmin Error: ${e.message}`);
    return []; // Kembalikan array kosong jika error
  }
}

/**
 * [BARU] Mengirimkan OTP untuk reset password.
 * @param {string} email Email pengguna yang terdaftar.
 * @returns {{status: string, message: string}} Hasil proses pengiriman.
 */
function sendPasswordResetOtp(email) {
  try {
    if (!email) {
      return { status: "error", message: "Email tidak boleh kosong." };
    }
    const normalizedEmail = email.toLowerCase();

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const users = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1).getValues().flat();

    // Cek apakah email terdaftar
    const emailExists = users.some(existingEmail => existingEmail.toLowerCase() === normalizedEmail);
    if (!emailExists) {
      return { status: "error", message: "Email tidak terdaftar di sistem kami." };
    }

    const otp = generateAndStoreOtp(normalizedEmail); // Menggunakan kembali fungsi OTP yang sudah ada
    const subject = "Kode Verifikasi Reset Password";
    const body = `
      <div style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2>Reset Password Anda</h2>
        <p>Kami menerima permintaan untuk mereset password akun Anda. Gunakan kode di bawah ini untuk melanjutkan:</p>
        <p style="font-size: 24px; font-weight: bold; letter-spacing: 5px; background-color: #f0f0f0; padding: 10px 20px; border-radius: 5px; display: inline-block;">${otp}</p>
        <p>Kode ini hanya berlaku selama 10 menit.</p>
        <p>Jika Anda tidak merasa meminta reset password, abaikan email ini.</p>
      </div>
    `;

    MailApp.sendEmail({
      to: email,
      subject: subject,
      htmlBody: body
    });

    return { status: "success", message: "Kode OTP telah dikirim ke email Anda." };

  } catch (error) {
    Logger.log(`sendPasswordResetOtp Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengirim email verifikasi: " + error.message };
  }
}


/**
 * [BARU] Memverifikasi OTP dan mereset password pengguna.
 * @param {string} email Email pengguna.
 * @param {string} otp Kode OTP yang dimasukkan.
 * @param {string} newPassword Password baru yang akan diatur.
 * @returns {{status: string, message: string}} Hasil proses reset.
 */
function resetPasswordWithOtp(email, otp, newPassword) {
  try {
    // 1. Verifikasi OTP
    if (!verifyOtp(email, otp)) {
      return { status: "error", message: "Kode OTP salah atau telah kedaluwarsa." };
    }

    // 2. Hash password baru
    const salt = generateSalt();
    const hashedPassword = hashPassword(newPassword, salt);
    const newStoredPasswordString = `${salt}:${hashedPassword}`;

    // 3. Temukan dan perbarui password di spreadsheet
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 3).getValues(); // Ambil ID, email, password

    const userIndex = data.findIndex(row => row[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Terjadi kesalahan: Pengguna tidak ditemukan." };
    }

    // Update password di baris yang benar (baris spreadsheet = index array + 2)
    const rowToUpdate = userIndex + 2;
    userSheet.getRange(rowToUpdate, 3).setValue(newStoredPasswordString); // Kolom password (C) adalah kolom ke-3

    // Hapus OTP dari cache setelah berhasil digunakan
    CacheService.getScriptCache().remove(email.toLowerCase());

    return { status: "success", message: "Password Anda telah berhasil direset." };

  } catch (error) {
    Logger.log(`resetPasswordWithOtp Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mereset password: " + error.message };
  }
}

/**
 * [BARU] Mengubah password pengguna yang sedang login.
 * @param {string} email Email pengguna yang terdaftar.
 * @param {string} currentPassword Password saat ini yang dimasukkan pengguna.
 * @param {string} newPassword Password baru yang akan diatur.
 * @returns {{status: string, message: string}} Hasil proses perubahan password.
 */
function changeUserPassword(email, currentPassword, newPassword) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) {
      throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);
    }

    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 3).getValues(); // Ambil ID, email, password
    const userIndex = data.findIndex(row => row[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Terjadi kesalahan: Pengguna tidak ditemukan." };
    }

    const storedPasswordString = data[userIndex][2].toString();

    // 1. Verifikasi password saat ini
    // ==== AWAL PERBAIKAN ====
    // Logika verifikasi ini sekarang dapat menangani password lama (plain text) dan baru (hash).
    let isCurrentPasswordValid = false;
    if (storedPasswordString.includes(':')) {
      // Jika formatnya 'salt:hash', gunakan verifikasi hash.
      isCurrentPasswordValid = verifyPassword(currentPassword, storedPasswordString);
    } else {
      // Jika tidak, ini adalah password lama, bandingkan sebagai teks biasa.
      isCurrentPasswordValid = (currentPassword === storedPasswordString);
    }
    // ==== AKHIR PERBAIKAN ====
    
    if (!isCurrentPasswordValid) {
      return { status: "error", message: "Password Anda saat ini salah. Silakan coba lagi." };
    }

    // 2. Hash password baru (bagian ini sudah benar)
    const salt = generateSalt();
    const hashedPassword = hashPassword(newPassword, salt);
    const newStoredPasswordString = `${salt}:${hashedPassword}`;

    // 3. Perbarui password di spreadsheet
    const rowToUpdate = userIndex + 2; // Baris spreadsheet = index array + 2
    userSheet.getRange(rowToUpdate, 3).setValue(newStoredPasswordString); // Kolom password (C) adalah kolom ke-3

    return { status: "success", message: "Password Anda telah berhasil diubah." };

  } catch (error) {
    Logger.log(`changeUserPassword Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengubah password: " + error.message };
  }
}

// =================================================================
// FUNGSI UTILITAS UMUM
// =================================================================

/**
 * Helper function untuk membuka spreadsheet berdasarkan ID.
 * @param {string} spreadsheetId ID dari Google Sheet yang akan dibuka.
 * @returns {SpreadsheetApp.Spreadsheet} Objek Spreadsheet.
 */
function getSpreadsheet(spreadsheetId) {
  if (!spreadsheetId) {
    throw new Error("Spreadsheet ID tidak valid atau tidak diberikan.");
  }
  return SpreadsheetApp.openById(spreadsheetId);
}

/**
 * [BARU] Helper function untuk mengubah string menjadi Proper Case.
 * @param {string} str String yang akan diubah.
 * @returns {string} String dalam format Proper Case.
 */
function toProperCase(str) {
  if (!str || typeof str !== 'string') return '';
  return str.replace(/\w\S*/g, function(txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}


// =================================================================
// FUNGSI MANAJEMEN DATA SEKOLAH, SISWA, MAPEL, DLL.
// =================================================================

// GANTI FUNGSI INI DI Kode.gs.html

function saveSchoolData(spreadsheetId, dataObj) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_DATA_SEKOLAH);
    
    // ===== PERBAIKAN UTAMA =====
    // Cek jika jenjang yang dikirim dari form kosong atau hanya berisi spasi.
    if (!dataObj.jenjang || dataObj.jenjang.trim() === '') {
      // Jika kosong, baca nilai jenjang yang sudah ada langsung dari spreadsheet.
      const existingJenjang = sheet.getRange("A2").getValue();
      // Hanya gunakan nilai lama jika memang ada isinya.
      if (existingJenjang && existingJenjang.trim() !== '') {
        dataObj.jenjang = existingJenjang;
      }
    }
    // ===== AKHIR PERBAIKAN =====

    sheet.getRange("C:D").setNumberFormat('@');
    sheet.getRange("J:K").setNumberFormat('@');
    sheet.getRange("O:O").setNumberFormat('@');
    
    if (sheet.getRange("G1").getValue() !== "Tipe Kabupaten/Kota") {
      sheet.insertColumnAfter(9);
      sheet.getRange("J1").setValue("Tipe Kabupaten/Kota").setFontWeight("bold");
    }
    if (sheet.getRange("L1").getValue() !== "Tipe Kelurahan/Desa") {
      sheet.insertColumnAfter(11);
      sheet.getRange("M1").setValue("Tipe Kelurahan/Desa").setFontWeight("bold");
    }
    
    const valuesToWrite = [
        dataObj.jenjang||"", dataObj.namaSekolah||"", dataObj.npsn||"", dataObj.nsm||"",
        dataObj.alamat||"", dataObj.provinsi||"", dataObj.tipeKabupaten||"Kabupaten", dataObj.kabupaten||"",
        dataObj.kecamatan||"", dataObj.tipeKelurahan||"Kelurahan", dataObj.kelurahan||"", dataObj.kodePos||"",
        dataObj.telepon||"", dataObj.email||"", dataObj.website||"", dataObj.namaKepsek||"",
        dataObj.nipKepsek||""
    ];
    sheet.getRange(2, 1, 1, valuesToWrite.length).setValues([valuesToWrite]);

    return { status: "success", message: "Data sekolah berhasil diperbarui." };
  } catch (error) {
    Logger.log(error);
    return { status: "error", message: "Gagal menyimpan data sekolah (mungkin karena perubahan struktur): " + error.message };
  }
}

/**
 * [MODIFIKASI] Mengambil data sekolah dari sheet 'Data Sekolah', termasuk tipe wilayah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object|null} Objek data sekolah atau null jika gagal.
 */
function getSchoolData(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SEKOLAH);
    if (!sheet || sheet.getLastRow() < 2) return null;

    sheet.getRange("C:D").setNumberFormat('@');
    sheet.getRange("K:L").setNumberFormat('@'); // Disesuaikan setelah penambahan kolom
    sheet.getRange("Q:Q").setNumberFormat('@'); // Disesuaikan setelah penambahan kolom

    // [MODIFIKASI] Ubah jangkauan pengambilan data menjadi A2:Q2 (17 kolom)
    const values = sheet.getRange("A2:Q2").getValues()[0];
    
    // [MODIFIKASI] Tambahkan field baru dan sesuaikan indeks
    return {
        jenjang: values[0], 
        namaSekolah: values[1], 
        npsn: values[2], 
        nsm: values[3],
        alamat: values[4], 
        provinsi: values[5],
        tipeKabupaten: values[6], // Kolom baru
        kabupaten: values[7],
        kecamatan: values[8],
        tipeKelurahan: values[9], // Kolom baru
        kelurahan: values[10],
        kodePos: values[11], 
        telepon: values[12], 
        email: values[13], 
        website: values[14], 
        namaKepsek: values[15], 
        nipKepsek: values[16]
    };
  } catch (error) {
    Logger.log(error);
    return null;
  }
}

// GANTI FUNGSI INI DI Kode.gs.html

function getStudents(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (!sheet || sheet.getLastRow() < 2) return [];

    // ===== AWAL PERBAIKAN =====
    // Paksa kolom NISN, NIS, No. Ujian, dan Kelas menjadi format Teks Biasa
    // untuk mencegah konversi otomatis menjadi tanggal atau angka.
    sheet.getRange("A:C").setNumberFormat('@'); 
    sheet.getRange("F:F").setNumberFormat('@'); 
    sheet.getRange("I:I").setNumberFormat('@');
    sheet.getRange("N:N").setNumberFormat('@'); // Ini adalah baris KUNCI untuk memperbaiki masalah Kelas
    // ===== AKHIR PERBAIKAN =====

    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 15);
    // [PERBAIKAN TAMBAHAN] Gunakan .getDisplayValues() untuk memastikan kita mendapatkan
    // nilai persis seperti yang ditampilkan di sheet.
    const values = dataRange.getDisplayValues();

    return values.map((row, index) => {
      let tanggalLahirStr = '';
      // Logika untuk tanggal lahir tidak perlu diubah karena kita ingin formatnya tetap benar
      const tglLahirCell = sheet.getRange(index + 2, 7).getValue();
      if (tglLahirCell && tglLahirCell instanceof Date && !isNaN(tglLahirCell)) {
        tanggalLahirStr = Utilities.formatDate(tglLahirCell, Session.getScriptTimeZone(), "yyyy-MM-dd");
      } else if (tglLahirCell) {
        tanggalLahirStr = tglLahirCell.toString();
      }

      return {
        row: index + 2,
        nisn: String(row[0] || ''),
        nis: String(row[1] || ''),
        nomorUjian: String(row[2] || ''),
        nama: String(row[3] || ''),
        jenisKelamin: String(row[4] || ''),
        tempatLahir: String(row[5] || ''),
        tanggalLahir: tanggalLahirStr,
        alamat: String(row[7] || ''),
        telepon: String(row[8] || ''),
        emailSiswa: String(row[9] || ''),
        tahunMasuk: String(row[10] || ''),
        tahunLulus: String(row[11] || ''),
        tampilkanTranskrip: String(row[12] || 'TIDAK'),
        kelas: String(row[13] || ''),
        ruangUjian: String(row[14] || '')
      };
    });
  } catch (e) {
    Logger.log(`getStudents Error: ${e.stack}`);
    return [];
  }
}

/**
 * [MODIFIKASI & PERBAIKAN FINAL] Menambahkan siswa baru atau mendeteksi konflik jika NISN sudah ada.
 * Kini juga memeriksa batas siswa sebelum menambahkan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} studentData Objek data siswa baru.
 * @param {string} userEmail Email pengguna yang melakukan aksi (dikirim dari frontend).
 * @returns {{status: string, message: string, oldData?: object, newData?: object}} Status penambahan.
 */
function addStudent(spreadsheetId, studentData, userEmail) {
  try {
    const limitCheck = checkStudentLimit(spreadsheetId, userEmail); 
    if (limitCheck.limitReached) {
        return { status: "error", message: limitCheck.message };
    }

    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    
    if (sheet.getLastRow() > 1) {
      const allStudents = getStudents(spreadsheetId);
      const existingStudent = allStudents.find(s => s.nisn.toString() === studentData.nisn.toString());

      if (existingStudent) {
        const isIdentical = areStudentsIdentical(existingStudent, studentData);
        if (isIdentical) {
          return { status: "duplicate", message: "Data siswa dengan NISN ini sudah ada dan semua datanya identik." };
        } else {
          return {
            status: "conflict",
            message: "NISN ini sudah terdaftar dengan data yang berbeda.",
            oldData: existingStudent,
            newData: studentData
          };
        }
      }
    }

    const nextRow = sheet.getLastRow() + 1;
    const tanggalLahirObject = studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '';
    
    const newRowData = [
        studentData.nisn, studentData.nis, studentData.nomorUjian, studentData.nama, 
        studentData.jenisKelamin, toProperCase(studentData.tempatLahir), tanggalLahirObject, 
        studentData.alamat, studentData.telepon, studentData.emailSiswa, 
        studentData.tahunMasuk, studentData.tahunLulus, 'TIDAK',
        studentData.kelas, studentData.ruangUjian
    ];
    sheet.getRange(nextRow, 1, 1, newRowData.length).setValues([newRowData]);
    
    // [MODIFIKASI] Panggil fungsi penyortiran setelah menambah siswa baru
    sortAndRewriteStudentSheet(spreadsheetId);
    
    SpreadsheetApp.flush();
    const updatedStudentList = getStudents(spreadsheetId);
    
    return { 
      status: "success", 
      message: `Siswa "${studentData.nama}" berhasil ditambahkan.`,
      updatedStudentList: updatedStudentList
    };

  } catch (e) { 
    Logger.log(e); 
    return { status: "error", message: "Gagal memproses data siswa: " + e.message }; 
  }
}

/**
 * [DIPERBARUI v2] Memperbarui data siswa dan mempertahankan status visibilitas transkrip.
 */
function updateStudent(spreadsheetId, studentData) {
  try {
    const allStudents = getStudents(spreadsheetId);
    const duplicateStudent = allStudents.find(s =>
      s.nisn.toString().trim() === studentData.nisn.toString().trim() &&
      s.row != studentData.studentRow
    );
    if (duplicateStudent) {
      return { status: "error", message: `Gagal: NISN "${studentData.nisn}" sudah digunakan oleh siswa lain (${duplicateStudent.nama}).` };
    }

    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);

    // --- AWAL PERBAIKAN ---
    // 1. Baca nilai "Tampilkan Transkrip" yang sudah ada dari baris yang akan diupdate.
    // Kolom "Tampilkan Transkrip" adalah kolom ke-13.
    const existingVisibility = sheet.getRange(studentData.studentRow, 13).getValue();
    // --- AKHIR PERBAIKAN ---
    
    // Sesuaikan array `rowToUpdate` untuk menggunakan nilai yang sudah ada
    const rowToUpdate = [
      studentData.nisn, studentData.nis, studentData.nomorUjian, studentData.nama,
      studentData.jenisKelamin, toProperCase(studentData.tempatLahir),
      studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '',
      studentData.alamat, studentData.telepon, studentData.emailSiswa,
      studentData.tahunMasuk, studentData.tahunLulus, 
      // 2. Gunakan nilai yang ada jika tidak ada nilai baru dari `studentData`
      studentData.tampilkanTranskrip || existingVisibility || 'TIDAK', 
      studentData.kelas, studentData.ruangUjian
    ];

    sheet.getRange(studentData.studentRow, 1, 1, rowToUpdate.length).setValues([rowToUpdate]);

    sortAndRewriteStudentSheet(spreadsheetId);

    SpreadsheetApp.flush();
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: `Data siswa "${studentData.nama}" berhasil diperbarui.`,
      updatedStudentList: updatedStudentList
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data: " + e.message };
  }
}

/**
 * Menghapus data siswa dari sheet 'Data Siswa'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {number} rowNumber Nomor baris yang akan dihapus.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteStudent(spreadsheetId, rowNumber) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    sheet.deleteRow(rowNumber);
    // -- PERUBAHAN INTI --
    SpreadsheetApp.flush();
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: "Data siswa berhasil dihapus.",
      updatedStudentList: updatedStudentList
    };
  } catch (e) { Logger.log(e); return { status: "error", message: "Gagal menghapus data: " + e.message }; }
}

/**
 * Menghapus semua data siswa dari sheet 'Data Siswa'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllStudents(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (sheet && sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }
    return { status: "success", message: "Semua data siswa telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data siswa: " + e.message };
  }
}

/**
 * [DIPERBARUI] Menghasilkan template Excel dengan kolom-kolom baru.
 */
function generateSiswaTemplate() {
  let tempFile;
  try {
    const templateName = `Template_Import_Siswa_${new Date().getTime()}`;
    const ss = SpreadsheetApp.create(templateName);
    tempFile = DriveApp.getFileById(ss.getId());
    
    const sheet = ss.getSheets()[0];
    const headers = [
      "NISN", "NIS (2 digit tahun lulus 4 digit nomor urut)", "Nomor Ujian", "Nama Lengkap", "Jenis Kelamin (L/P)", 
      "Tempat Lahir", "Tanggal Lahir (Format: YYYY-MM-DD)",
      "Alamat Lengkap Siswa", "Nomor Telepon", "Email", 
      "Tahun Masuk", "Tahun Lulus", "Kelas", "Ruang Ujian"
    ];
    sheet.appendRow(headers);
    sheet.getRange("A1:N1").setFontWeight("bold").setBackground("#d9ead3");
    
    sheet.getRange("A:C").setNumberFormat("@");
    sheet.getRange("I:I").setNumberFormat("@");
    sheet.getRange("G:G").setNumberFormat("yyyy-mm-dd");
    
    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${ss.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: 'Template_Import_Siswa.xlsx',
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

function importFromExcel(spreadsheetId, fileData, sheetName, userEmail) {
    let tempFile; // Pindahkan deklarasi ke sini agar cakupannya lebih luas
    try {
        const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
        const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
        
        // Buat file sementara
        const tempSpreadsheetFile = Drive.Files.insert({ title: `temp_import_${new Date().getTime()}` }, blob, { convert: true });
        
        // Periksa apakah file berhasil dibuat
        if (!tempSpreadsheetFile || !tempSpreadsheetFile.id) {
            throw new Error("Gagal membuat file sementara di Google Drive. Pastikan Drive API telah diaktifkan.");
        }
        
        // Simpan file object untuk dihapus nanti
        tempFile = DriveApp.getFileById(tempSpreadsheetFile.id); 
        const importSheet = SpreadsheetApp.openById(tempSpreadsheetFile.id).getSheets()[0];
        const data = importSheet.getDataRange().getValues();

        if (data.length <= 1) throw new Error("File kosong atau hanya berisi header.");
        data.shift();

        const targetSpreadsheet = getSpreadsheet(spreadsheetId);
        let targetSheet = targetSpreadsheet.getSheetByName(sheetName);

        if (sheetName === SHEET_DATA_SISWA) {
            const quotaInfo = getStudentQuotaInfo(userEmail);
            if (quotaInfo.status === 'error') {
                return { status: "error", message: quotaInfo.message };
            }
            let remainingSlots = quotaInfo.remaining;
            if (isNaN(remainingSlots) || remainingSlots < 0) {
                 remainingSlots = 1000000;
            }
            if (remainingSlots <= 0) {
                return { status: "error", message: `Impor dibatalkan. Kuota siswa Anda sudah penuh (${quotaInfo.usedCount}/${quotaInfo.totalLimit}).` };
            }

            targetSheet.getRange("A:C").setNumberFormat("@");
            const existingStudents = getStudents(spreadsheetId);
            const existingNisnMap = new Map();
            existingStudents.forEach(s => {
                if (s.nisn) existingNisnMap.set(s.nisn.toString().trim(), s);
            });

            const newStudents = [];
            const enrichedStudents = [];
            const conflicts = [];
            const skippedDuplicates = [];
            const skippedDueToLimit = [];
            const processedNisns = new Set();

            data.forEach((row) => {
                const nisn = (row[0] || '').toString().trim();
                const namaFromFile = (row[3] || '').toString().trim();
                if (!nisn || !namaFromFile) return;
                if (processedNisns.has(nisn)) {
                    skippedDuplicates.push({ nisn, nama: namaFromFile, reason: 'Duplikat di dalam file import.' });
                    return;
                }
                processedNisns.add(nisn);

                const newData = {
                    nisn: nisn, 
                    nis: row[1] || '', 
                    nomorUjian: row[2] || '',
                    nama: namaFromFile, 
                    jenisKelamin: row[4] || '',
                    tempatLahir: toProperCase(row[5] || ''),
                    tanggalLahir: row[6] ? Utilities.formatDate(new Date(row[6]), Session.getScriptTimeZone(), "yyyy-MM-dd") : '',
                    alamat: row[7] || '', 
                    telepon: row[8] || '', 
                    emailSiswa: row[9] || '',
                    tahunMasuk: row[10] || '', 
                    tahunLulus: row[11] || '',
                    kelas: row[12] || '',
                    ruangUjian: row[13] || ''
                };

                if (existingNisnMap.has(nisn)) {
                    const existingStudent = existingNisnMap.get(nisn);
                    const isIdentical = areStudentsIdentical(existingStudent, newData);
                    if (!isIdentical) {
                        conflicts.push({ nisn: nisn, rowToUpdate: existingStudent.row, oldData: existingStudent, newData: newData });
                    } else {
                        let isEnriched = false;
                        const finalData = { ...existingStudent };
                        Object.keys(newData).forEach(key => {
                            if (!finalData[key] && newData[key]) {
                                finalData[key] = newData[key];
                                isEnriched = true;
                            }
                        });
                        if (isEnriched) {
                            enrichedStudents.push({ ...finalData, studentRow: existingStudent.row });
                        } else {
                            skippedDuplicates.push({ nisn, nama: namaFromFile, reason: 'Data sudah ada dan identik.' });
                        }
                    }
                } else {
                    if (remainingSlots > 0) {
                        const newRowForSheet = [
                            newData.nisn, newData.nis, newData.nomorUjian, newData.nama, newData.jenisKelamin,
                            newData.tempatLahir, newData.tanggalLahir ? new Date(newData.tanggalLahir) : '', newData.alamat, newData.telepon,
                            newData.emailSiswa, newData.tahunMasuk, newData.tahunLulus, 'TIDAK', newData.kelas, newData.ruangUjian
                        ];
                        newStudents.push(newRowForSheet);
                        remainingSlots--;
                    } else {
                        skippedDueToLimit.push({ nisn: nisn, nama: namaFromFile, reason: 'Batas kuota siswa tercapai.' });
                    }
                }
            });

            if (newStudents.length > 0) {
                targetSheet.getRange(targetSheet.getLastRow() + 1, 1, newStudents.length, newStudents[0].length).setValues(newStudents);
            }
            if (enrichedStudents.length > 0) {
                batchUpdateStudents(spreadsheetId, enrichedStudents);
            }

            return {
                status: "partial",
                message: "Proses impor siswa selesai.",
                newCount: newStudents.length,
                enrichedCount: enrichedStudents.length,
                skippedCount: skippedDuplicates.length,
                conflictCount: conflicts.length,
                conflicts: conflicts,
                skippedLimitCount: skippedDueToLimit.length,
                skippedLimitData: skippedDueToLimit
            };
        } else {
            const rowsToAppend = data.filter(row => row.some(cell => cell.toString().trim() !== ""));
            if (rowsToAppend.length > 0) {
                targetSheet.getRange(targetSheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
            }
            return { status: "success", message: `${rowsToAppend.length} data berhasil diimpor ke sheet ${sheetName}.` };
        }

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: `Gagal mengimpor data: ${e.toString()}` };
    } finally {
        if (tempFile) { // Hanya hapus jika tempFile berhasil didefinisikan
            tempFile.setTrashed(true);
        }
    }
}

/**
 * Mengambil daftar mata pelajaran dari sheet 'Data Mata Pelajaran'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {Array<object>} Array objek data mata pelajaran.
 */
function getMapel(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    if (!sheet || sheet.getLastRow() < 2) return [];
    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4);
    const values = dataRange.getValues();
    return values.map((row, index) => ({ row: index + 2, kode: row[0], nama: row[1], kelompok: row[2], jenisUjian: row[3] || '' }));
  } catch (e) { Logger.log(e); return []; }
}

/**
 * [PERBAIKAN] Menambahkan beberapa mata pelajaran sekaligus (input massal)
 * dan mengembalikan daftar mapel terbaru setelah selesai.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} mapelArray Array objek data mata pelajaran baru.
 * @returns {object} Status penambahan DAN daftar mapel yang sudah diupdate.
 */
function addMultipleMapel(spreadsheetId, mapelArray) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_MAPEL);

        const existingMapel = getMapel(spreadsheetId);
        const existingCodes = new Set(existingMapel.map(m => m.kode.toString().trim().toLowerCase()));
        
        const rowsToAppend = [];
        const codesInThisBatch = new Set();
        let skippedCount = 0;

        for (const mapelData of mapelArray) {
            const newCode = (mapelData.kode || '').toString().trim().toLowerCase();
            const newName = (mapelData.nama || '').toString().trim();

            if (!newCode || !newName) {
                skippedCount++;
                continue;
            }

            if (existingCodes.has(newCode) || codesInThisBatch.has(newCode)) {
                skippedCount++;
                continue;
            }

            const jenisUjian = mapelData.jenisUjian || 'Ujian Madrasah';
            
            rowsToAppend.push([mapelData.kode, newName, mapelData.kelompok, jenisUjian]);
            codesInThisBatch.add(newCode);
        }
        
        if (rowsToAppend.length > 0) {
            sheet.getRange(sheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
        }

        let message = `${rowsToAppend.length} mata pelajaran berhasil ditambahkan.`;
        if (skippedCount > 0) {
            message += ` ${skippedCount} mapel dilewati karena tidak lengkap atau kode duplikat.`;
        }

        // ======================================================
        // === PERUBAHAN INTI ADA DI BAWAH INI ===
        // ======================================================

        SpreadsheetApp.flush();
        const updatedMapelList = getMapel(spreadsheetId);

        return { 
            status: "success", 
            message: message,
            updatedMapelList: updatedMapelList // <-- Data baru disertakan di sini
        };

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: "Gagal menambah mapel secara massal: " + e.message };
    }
}

/**
 * [PERBAIKAN] Memperbarui data mata pelajaran DAN mengembalikan daftar mapel terbaru.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} mapelData Data mata pelajaran yang akan diupdate, termasuk nomor baris.
 * @returns {object} Status pembaruan DAN daftar mapel yang sudah diupdate.
 */
function updateMapel(spreadsheetId, mapelData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    
    // Data yang akan ditulis ke baris yang diupdate
    const rowToUpdate = [mapelData.kode, mapelData.nama, mapelData.kelompok, mapelData.jenisUjian];
    sheet.getRange(mapelData.mapelRow, 1, 1, rowToUpdate.length).setValues([rowToUpdate]);
    
    // Paksa Google Sheet untuk menyelesaikan proses update
    SpreadsheetApp.flush();
    
    // Baca kembali data yang sudah terupdate
    const updatedMapelList = getMapel(spreadsheetId);

    // Kembalikan data baru bersama pesan sukses
    return { 
      status: "success", 
      message: `Mata Pelajaran "${mapelData.nama}" berhasil diperbarui.`,
      updatedMapelList: updatedMapelList 
    };
  } catch (e) { 
    Logger.log(e); 
    return { status: "error", message: "Gagal memperbarui data mapel: " + e.message }; 
  }
}

/**
 * [PERBAIKAN] Menghapus mata pelajaran DAN mengembalikan daftar mapel terbaru.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {number} rowNumber Nomor baris yang akan dihapus.
 * @returns {object} Status penghapusan DAN daftar mapel yang sudah diupdate.
 */
function deleteMapel(spreadsheetId, rowNumber) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    sheet.deleteRow(rowNumber);
    
    // Paksa Google Sheet untuk menyelesaikan proses hapus
    SpreadsheetApp.flush();
    
    // Baca kembali data yang sudah terupdate
    const updatedMapelList = getMapel(spreadsheetId);

    // Kembalikan data baru bersama pesan sukses
    return { 
      status: "success", 
      message: "Mata pelajaran berhasil dihapus.",
      updatedMapelList: updatedMapelList 
    };
  } catch (e) { 
    Logger.log(e); 
    return { status: "error", message: "Gagal menghapus mapel: " + e.message }; 
  }
}

/**
 * Menghapus semua mata pelajaran.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllMapel(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    if (sheet && sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }
    return { status: "success", message: "Semua data mata pelajaran telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data mata pelajaran: " + e.message };
  }
}

/**
 * Menyimpan data bobot nilai.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} bobotData Objek berisi bobot nilai.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveBobot(spreadsheetId, bobotData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_BOBOT);
    const bobotRow = [bobotData.bobotUjian, bobotData.bobotRapor];
    if (sheet.getLastRow() >= 2) sheet.getRange("A2:B2").clearContent();
    sheet.getRange(2, 1, 1, bobotRow.length).setValues([bobotRow]);
    return { status: "success", message: "Bobot nilai berhasil disimpan." };
  } catch (e) { Logger.log(e); return { status: "error", message: "Gagal menyimpan bobot nilai: " + e.message }; }
}

/**
 * Mengambil data bobot nilai, atau mengaturnya ke default jika belum ada.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi bobot nilai.
 */
function getBobot(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_BOBOT);
    if (!sheet) {
      return { bobotUjian: 40, bobotRapor: 60 };
    }

    if (sheet.getLastRow() >= 2) {
        const values = sheet.getRange("A2:B2").getValues()[0];
        if (values[0] !== '' && values[1] !== '' && !isNaN(values[0]) && !isNaN(values[1])) {
            return { bobotUjian: values[0], bobotRapor: values[1] };
        }
    }
    
    const defaultBobot = { bobotUjian: 40, bobotRapor: 60 };
    sheet.getRange(2, 1, 1, 2).setValues([[defaultBobot.bobotUjian, defaultBobot.bobotRapor]]);
    
    return defaultBobot;
  } catch (e) { 
    Logger.log('Error di getBobot: ' + e.message); 
    return { bobotUjian: 40, bobotRapor: 60 }; 
  }
}

/**
 * [BARU] Menyimpan nilai KKM sekolah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {number} kkm Nilai KKM yang akan disimpan.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveKkm(spreadsheetId, kkm) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);

    // Jika sheet belum ada, buat baru dan siapkan header & label
    if (!sheet) {
      sheet = ss.insertSheet(SHEET_PENGATURAN);
      sheet.getRange("A1:B1").setValues([['Nama Pengaturan', 'Value']]).setFontWeight('bold');
      sheet.getRange("A2").setValue("KKM Sekolah");
      sheet.setFrozenRows(1);
    }

    // Pastikan label ada jika sheet sudah ada tapi kosong
    if (sheet.getRange("A2").getValue() === "") {
        sheet.getRange("A2").setValue("KKM Sekolah");
    }
    
    // Simpan nilai KKM di sel B2
    sheet.getRange("B2").setValue(kkm);

    return { status: "success", message: "Nilai KKM berhasil disimpan." };
  } catch (e) {
    Logger.log(`saveKkm Error: ${e.message}`);
    return { status: "error", message: `Gagal menyimpan KKM: ${e.message}` };
  }
}

/**
 * [BARU] Mengambil nilai KKM sekolah, atau mengembalikan default jika belum ada.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, kkm: number}} Objek berisi KKM.
 */
function getKkm(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    const defaultValue = 75; // Nilai default KKM jika belum diatur

    if (!sheet || sheet.getLastRow() < 2) {
      return { status: 'success', kkm: defaultValue };
    }

    const kkmValue = sheet.getRange("B2").getValue();
    
    // Jika sel B2 kosong atau tidak valid, kembalikan nilai default
    if (kkmValue === '' || isNaN(kkmValue)) {
        return { status: 'success', kkm: defaultValue };
    }
    
    return { status: 'success', kkm: kkmValue };
  } catch (e) {
    Logger.log(`getKkm Error: ${e.message}`);
    // Jika error, kembalikan nilai default agar aplikasi tidak macet
    return { status: 'success', kkm: 75 }; 
  }
}

/**
 * Mengambil daftar mapel berdasarkan jenis ujian.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} jenis Jenis ujian ('madrasah' atau 'praktek').
 * @returns {Array<object>} Array objek data mata pelajaran.
 */
function getMapelByJenis(spreadsheetId, jenis) {
  const allMapel = getMapel(spreadsheetId);
  if (jenis === 'madrasah') return allMapel.filter(m => m.jenisUjian === 'Ujian Madrasah' || m.jenisUjian === 'Keduanya');
  if (jenis === 'praktek') return allMapel.filter(m => m.jenisUjian === 'Ujian Praktek' || m.jenisUjian === 'Keduanya');
  return [];
}

// File: Kode.gs.html

/**
 * [DIPERBARUI] Menyimpan data nilai ujian.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} data Objek berisi jenis dan data nilai.
 * @returns {object} Status penyimpanan.
 */
function saveNilai(spreadsheetId, data) {
  const { jenis, nilai } = data; //
  const sheetName = jenis === 'madrasah' ? SHEET_NILAI_UJIAN_MADRASAH : SHEET_NILAI_UJIAN_PRAKTEK; //
  const mapelList = getMapelByJenis(spreadsheetId, jenis); //
  
  // Panggil fungsi inti yang baru dan andal
  return saveScoresToSheet(spreadsheetId, sheetName, mapelList, nilai); 
}

// File: Kode.gs.html

/**
 * [DIPERBARUI] Menyimpan data nilai rapor.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} data Objek berisi semester, jenis, dan data nilai.
 * @returns {object} Status penyimpanan.
 */
function saveNilaiRapor(spreadsheetId, data) {
  const { semesterKey, jenisNilai, nilai } = data; //
  const sheetName = `Rapor_${jenisNilai}_${semesterKey}`; //
  const mapelList = getMapel(spreadsheetId); //
  
  // Panggil fungsi inti yang baru dan andal
  return saveScoresToSheet(spreadsheetId, sheetName, mapelList, nilai);
}

/**
 * Mengambil data nilai yang sudah ada dari sebuah sheet.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet nilai.
 * @returns {object} Objek berisi nilai yang sudah ada, dengan NISN sebagai key.
 */
function getExistingNilai(spreadsheetId, sheetName) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() < 2) return {};
    sheet.getRange("A:A").setNumberFormat('@');
    const data = sheet.getDataRange().getValues();
    const headers = data.shift();
    const nisnIndex = headers.indexOf("NISN");
    const existingScores = {};
    data.forEach(row => {
      const nisn = row[nisnIndex];
      if (nisn) {
          existingScores[nisn] = {};
          headers.forEach((header, index) => {
              if (index > 1) existingScores[nisn][header] = row[index];
          });
      }
    });
    return existingScores;
  } catch(e) { Logger.log(e); return {}; }
}

/**
 * [FINAL v2 & DENGAN RESOLUSI KONFLIK] Memproses, memvalidasi, dan mengimpor nilai dari sheet Excel.
 * Fungsi ini sekarang dapat secara bersamaan menambahkan nilai baru yang valid (mengisi sel kosong)
 * DAN mengidentifikasi konflik nilai tanpa menghentikan proses penambahan.
 *
 * @param {SpreadsheetApp.Spreadsheet} targetSs - Objek spreadsheet tujuan.
 * @param {string} targetSheetName - Nama sheet yang akan diproses (mis. 'Nilai Ujian Madrasah').
 * @param {SpreadsheetApp.Sheet} importSheet - Objek sheet dari file Excel yang diimpor.
 * @param {Array<object>} mapelForSheet - Daftar mata pelajaran yang relevan untuk sheet ini.
 * @returns {object} Objek hasil yang berisi jumlah nilai baru, nilai yang di-skip, dan daftar konflik.
 */
function processSheetImport(targetSs, targetSheetName, importSheet, mapelForSheet) {
    // 1. Ambil data utama
    if (importSheet.getLastRow() <= 1) return { newValuesCount: 0, conflicts: [], skippedCount: 0 };

    const students = getStudents(targetSs.getId());
    if (!students || students.length === 0) {
        throw new Error("Tidak ada data siswa di sheet 'Data Siswa'.");
    }

    // 2. Baca data dari file Excel dan buat Map untuk akses cepat
    const dataFromExcel = importSheet.getDataRange().getDisplayValues();
    const headersFromExcel = dataFromExcel.shift();
    const nisnIndexExcel = headersFromExcel.indexOf("NISN");
    if (nisnIndexExcel === -1) throw new Error(`Kolom 'NISN' tidak ditemukan di sheet import.`);
    
    const uploadedDataMap = new Map();
    dataFromExcel.forEach(row => {
        const nisn = row[nisnIndexExcel].toString().trim();
        if (nisn) {
            const scores = new Map();
            headersFromExcel.forEach((header, index) => {
                if (index > 1) scores.set(header.toString().trim(), row[index]);
            });
            uploadedDataMap.set(nisn, scores);
        }
    });

    // 3. Ambil data nilai yang sudah ada di sistem
    const existingScoresMap = getSheetDataAsObject(targetSs.getId(), targetSheetName);

    // 4. Proses perbandingan, deteksi konflik, dan penambahan data baru
    const conflicts = [];
    let newValuesCount = 0;
    let skippedCount = 0;
    const finalDataGrid = []; // Grid data akhir yang akan ditulis ke sheet

    students.forEach(student => {
        const nisn = student.nisn.toString().trim();
        const uploadedScores = uploadedDataMap.get(nisn);
        const existingStudentScores = existingScoresMap[nisn] || {};
        
        const newRow = ["'" + nisn, student.nama.toUpperCase()];

        mapelForSheet.forEach(mapel => {
            const mapelKode = mapel.kode;
            let scoreToWrite = existingStudentScores[mapelKode] !== undefined ? existingStudentScores[mapelKode] : '';

            if (uploadedScores && uploadedScores.has(mapelKode)) {
                const uploadedScoreValue = uploadedScores.get(mapelKode);

                if (uploadedScoreValue !== undefined && uploadedScoreValue !== null && String(uploadedScoreValue).trim() !== '') {
                    const numericUploaded = parseFloat(uploadedScoreValue);

                    if (!isNaN(numericUploaded) && numericUploaded >= 0 && numericUploaded <= 100) {
                        const existingScore = existingStudentScores[mapelKode];

                        if (existingScore !== undefined && String(existingScore).trim() !== '') {
                            // Ada nilai lama, cek apakah berbeda
                            if (String(existingScore) !== String(numericUploaded)) {
                                // KONFLIK DITEMUKAN
                                conflicts.push({
                                    sheetName: targetSheetName,
                                    nisn: nisn,
                                    namaSiswa: student.nama,
                                    mapelKode: mapelKode,
                                    oldValue: existingScore,
                                    newValue: numericUploaded
                                });
                                // Biarkan scoreToWrite tetap nilai lama untuk saat ini
                            } else {
                                // Nilai sama, diabaikan
                                skippedCount++;
                            }
                        } else {
                            // NILAI BARU DITEMUKAN (sel sebelumnya kosong)
                            scoreToWrite = numericUploaded;
                            newValuesCount++;
                        }
                    } else {
                        // Nilai tidak valid (bukan angka atau di luar rentang), diabaikan
                        skippedCount++;
                    }
                }
            }
            newRow.push(scoreToWrite);
        });
        finalDataGrid.push(newRow);
    });
    
    // 5. Jika ada nilai baru yang valid, tulis grid data yang sudah diperbarui ke sheet.
    // Ini berjalan terlepas dari apakah ada konflik atau tidak.
    if (newValuesCount > 0) {
        let targetSheet = targetSs.getSheetByName(targetSheetName);
        if (!targetSheet) {
            targetSheet = targetSs.insertSheet(targetSheetName);
        }
        targetSheet.clear();
        const newHeaders = ["NISN", "Nama Lengkap", ...mapelForSheet.map(m => m.kode)];
        targetSheet.getRange(1, 1, 1, newHeaders.length).setValues([newHeaders]).setFontWeight("bold");
        targetSheet.getRange("A:A").setNumberFormat('@');
        
        if (finalDataGrid.length > 0) {
            targetSheet.getRange(2, 1, finalDataGrid.length, newHeaders.length).setValues(finalDataGrid);
        }
        SpreadsheetApp.flush();
    }

    // 6. Kembalikan laporan lengkap ke frontend
    return {
        newValuesCount: newValuesCount,
        skippedCount: skippedCount,
        conflicts: conflicts
    };
}

// =================================================================
// FUNGSI REKAPITULASI NILAI
// =================================================================

/**
 * Mengambil data dari sebuah sheet dan mengubahnya menjadi objek dengan NISN sebagai key.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet.
 * @returns {object} Data sheet dalam bentuk objek.
 */
function getSheetDataAsObject(spreadsheetId, sheetName) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(sheetName);
        if (!sheet || sheet.getLastRow() < 2) return {};
        sheet.getRange("A:A").setNumberFormat('@');
        const data = sheet.getDataRange().getValues();
        const headers = data.shift();
        const nisnIndex = headers.indexOf("NISN");
        if (nisnIndex === -1) return {};

        const dataObj = {};
        data.forEach(row => {
            const nisn = row[nisnIndex].toString().trim();
            if (nisn) {
                dataObj[nisn] = {};
                headers.forEach((header, index) => {
                    // Mulai dari kolom ke-3 (setelah NISN dan Nama)
                    if (index > 1) dataObj[nisn][header] = row[index];
                });
            }
        });
        return dataObj;
    } catch (e) {
        Logger.log(`Error getting data from ${sheetName}: ${e}`);
        return {};
    }
}

/**
 * Memperbarui semua data di sheet rekapitulasi.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status pembaruan.
 */
function updateRekapitulasi(spreadsheetId) {
  try {
    const students = getStudents(spreadsheetId); //
    if (!students || students.length === 0) {
      return {status: 'error', message: 'Tidak ada data siswa untuk direkap.'};
    }
    const mapel = getMapel(spreadsheetId); //
    if (!mapel || mapel.length === 0) {
      return {status: 'error', message: 'Tidak ada data mata pelajaran untuk direkap.'};
    }
    const bobot = getBobot(spreadsheetId) || { bobotUjian: 0, bobotRapor: 0 }; //
    const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang; //

    if (!jenjang) {
      return {status: 'error', message: 'Jenjang sekolah belum diatur di menu Data Sekolah.'};
    }

    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    const semestersForJenjang = semesterKeys[jenjang] || [];

    const sheetsToRead = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK]; //
    semestersForJenjang.forEach(smKey => {
        sheetsToRead.push(`Rapor_Pengetahuan_${smKey}`);
        sheetsToRead.push(`Rapor_Keterampilan_${smKey}`);
    });
    
    const allData = {};
    sheetsToRead.forEach(sheetName => {
        allData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName); //
    });

    const nilaiUjianMadrasah = allData[SHEET_NILAI_UJIAN_MADRASAH] || {}; //
    const nilaiUjianPraktek = allData[SHEET_NILAI_UJIAN_PRAKTEK] || {}; //
    
    const rekapUjian = {};
    const rekapRapor = {};
    const rekapIjazah = {};

    students.forEach(student => {
        const nisn = student.nisn.toString().trim();
        rekapUjian[nisn] = {};
        rekapRapor[nisn] = {};
        rekapIjazah[nisn] = {};

        mapel.forEach(m => {
            const kode = m.kode;
            const nilaiUM = parseFloat( (nilaiUjianMadrasah[nisn] || {})[kode] );
            const nilaiUP = parseFloat( (nilaiUjianPraktek[nisn] || {})[kode] );

            let rataUjian = null; // Default ke null
            const hasUM = !isNaN(nilaiUM);
            const hasUP = !isNaN(nilaiUP);

            if (hasUM && hasUP) rataUjian = (nilaiUM + nilaiUP) / 2;
            else if (hasUM) rataUjian = nilaiUM;
            else if (hasUP) rataUjian = nilaiUP;
            
            if(rataUjian !== null) rekapUjian[nisn][kode] = rataUjian;

            let totalNilaiRapor = 0;
            let semesterCount = 0;
            
            semestersForJenjang.forEach(smKey => {
                const sheetNameP = `Rapor_Pengetahuan_${smKey}`;
                const sheetNameK = `Rapor_Keterampilan_${smKey}`;
                
                const nilaiP = parseFloat( ((allData[sheetNameP] || {})[nisn] || {})[kode] );
                const nilaiK = parseFloat( ((allData[sheetNameK] || {})[nisn] || {})[kode] );

                if (!isNaN(nilaiP) && !isNaN(nilaiK)) {
                    totalNilaiRapor += (nilaiP + nilaiK) / 2;
                    semesterCount++;
                } else if (!isNaN(nilaiP)) {
                    totalNilaiRapor += nilaiP;
                    semesterCount++;
                } else if (!isNaN(nilaiK)) {
                    totalNilaiRapor += nilaiK;
                    semesterCount++;
                }
            });

            const rataRapor = semesterCount > 0 ? totalNilaiRapor / semesterCount : 0;
            if (semesterCount > 0) rekapRapor[nisn][kode] = rataRapor;

            const bobotUjianVal = parseFloat(bobot.bobotUjian) || 0;
            const bobotRaporVal = parseFloat(bobot.bobotRapor) || 0;

            const finalRataUjian = rataUjian !== null ? rataUjian : 0;
            const finalRataRapor = semesterCount > 0 ? rataRapor : 0;

            if (rataUjian !== null || semesterCount > 0) {
              const nilaiAkhir = (finalRataUjian * (bobotUjianVal / 100)) + (finalRataRapor * (bobotRaporVal / 100));
              rekapIjazah[nisn][kode] = nilaiAkhir;
            }
        });
    });

    saveRekapSheet(spreadsheetId, SHEET_REKAP_UJIAN, students, mapel, rekapUjian); //
    saveRekapSheet(spreadsheetId, SHEET_REKAP_RAPOR, students, mapel, rekapRapor); //
    saveRekapSheet(spreadsheetId, SHEET_REKAP_IJAZAH, students, mapel, rekapIjazah); //
    
    return {status: "success", message: "Data rekapitulasi berhasil diperbarui."};
  } catch(e) {
    Logger.log(e);
    return {status: "error", message: "Gagal memperbarui rekapitulasi: " + e.message};
  }
}

/**
 * [PERBAIKAN RATA-RATA v2 & PENAMBAHAN KELAS] Menyimpan data rekapitulasi ke sheet yang ditentukan.
 * Rata-rata kini DIHITUNG DARI TOTAL NILAI DIBAGI JUMLAH TOTAL MAPEL.
 * Nilai kosong dianggap 0. Kolom Kelas ditambahkan setelah Nama Siswa.
 */
function saveRekapSheet(spreadsheetId, sheetName, students, mapel, data) {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
        sheet = ss.insertSheet(sheetName);
    }
    sheet.clear();

    // [MODIFIKASI] Menambahkan header "Kelas"
    const headers = ["NISN", "Nama Lengkap", "Kelas", ...mapel.map(m => m.kode), "Jumlah", "Rata-rata"];
    if (sheetName === SHEET_REKAP_IJAZAH) {
        headers.push("Status");
    } else if (sheetName === SHEET_REKAP_UJIAN) {
        headers.push("Rata-Rata AM (PDUM)");
    }

    sheet.appendRow(headers);
    sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold");
    sheet.getRange("A:A").setNumberFormat("@");

    const isIjazahSheet = sheetName === SHEET_REKAP_IJAZAH;
    const kkm = isIjazahSheet ? (getKkm(spreadsheetId).kkm || 75) : 0;

    const rows = students.map(student => {
        const nisn = student.nisn.toString().trim();
        // [MODIFIKASI] Menambahkan data student.kelas
        const rowData = [nisn, student.nama, student.kelas || '-'];
        
        let roundedTotal = 0;
        const mapelCount = mapel.length; 

        mapel.forEach(m => {
            const rawScore = (data[nisn] || {})[m.kode];
            let numericScore = parseFloat(rawScore);

            if (isNaN(numericScore)) {
                numericScore = 0;
            }
            
            const roundedScore = Math.round(numericScore);
            roundedTotal += roundedScore;
            rowData.push(roundedScore);
        });

        const average = mapelCount > 0 ? (roundedTotal / mapelCount) : 0;
        
        rowData.push(roundedTotal);
        rowData.push(average.toFixed(2).replace('.', ','));

        if (isIjazahSheet) {
            let status = '-';
            if (mapelCount > 0) {
                 status = (average >= kkm) ? 'LULUS' : 'TIDAK LULUS';
            }
            rowData.push(status);
        }

        if (sheetName === SHEET_REKAP_UJIAN) {
            rowData.push(Math.round(average));
        }
        
        return rowData;
    });

    if (rows.length > 0) {
        sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
    }
}

/**
 * Mengambil semua data rekapitulasi untuk ditampilkan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi semua data rekapitulasi.
 */
function getRekapitulasiData(spreadsheetId) {
  const students = getStudents(spreadsheetId);
  const mapel = getMapel(spreadsheetId);
  const bobot = getBobot(spreadsheetId); // Tambahkan baris ini
  return {
    students,
    mapel,
    bobot, // Tambahkan properti ini
    rekapUjian: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_UJIAN),
    rekapRapor: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_RAPOR),
    rekapIjazah: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_IJAZAH),
  };
}

/**
 * [BARU & OPTIMIZED & PERBAIKAN KELAS] Mengambil semua data untuk halaman rekapitulasi dalam satu operasi.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi semua data rekapitulasi.
 */
function getRekapitulasiData_Optimized(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);

    const processSheetData = (sheet) => {
      if (!sheet || sheet.getLastRow() < 2) return {};
      sheet.getRange("A:A").setNumberFormat('@');
      const data = sheet.getDataRange().getValues();
      const headers = data.shift();
      const nisnIndex = headers.indexOf("NISN");
      if (nisnIndex === -1) return {};

      const dataObj = {};
      data.forEach(row => {
        const nisn = row[nisnIndex].toString().trim();
        if (nisn) {
          dataObj[nisn] = {};
          headers.forEach((header, index) => {
            if (header !== "NISN" && header !== "Nama Lengkap") {
              dataObj[nisn][header] = row[index];
            }
          });
        }
      });
      return dataObj;
    };

    // [PERBAIKAN] Menggunakan fungsi getStudents() untuk memastikan semua data siswa termuat
    const students = getStudents(spreadsheetId);

    const mapelSheet = ss.getSheetByName(SHEET_MAPEL);
    let mapel = [];
    if (mapelSheet && mapelSheet.getLastRow() >= 2) {
      const mapelValues = mapelSheet.getRange(2, 1, mapelSheet.getLastRow() - 1, 4).getValues();
      mapel = mapelValues.map((row, index) => ({ row: index + 2, kode: row[0], nama: row[1], kelompok: row[2], jenisUjian: row[3] || '' }));
    }

    const bobotSheet = ss.getSheetByName(SHEET_BOBOT);
    let bobot = { bobotUjian: 40, bobotRapor: 60 };
    if (bobotSheet && bobotSheet.getLastRow() >= 2) {
      const bobotValues = bobotSheet.getRange("A2:B2").getValues()[0];
      if (bobotValues[0] !== '' && bobotValues[1] !== '' && !isNaN(bobotValues[0]) && !isNaN(bobotValues[1])) {
        bobot = { bobotUjian: bobotValues[0], bobotRapor: bobotValues[1] };
      }
    }
    
    const kkmData = getKkm(spreadsheetId);
    const kkm = kkmData.kkm;

    const rekapUjian = processSheetData(ss.getSheetByName(SHEET_REKAP_UJIAN));
    const rekapRapor = processSheetData(ss.getSheetByName(SHEET_REKAP_RAPOR));
    const rekapIjazah = processSheetData(ss.getSheetByName(SHEET_REKAP_IJAZAH));

    return { status: "success", data: { students, mapel, bobot, kkm, rekapUjian, rekapRapor, rekapIjazah } };

  } catch (e) {
    Logger.log(`Error di getRekapitulasiData_Optimized: ${e}`);
    return { status: "error", message: "Gagal mengambil data rekapitulasi: " + e.message };
  }
}

/**
 * [VERSI FINAL] Mengambil semua data yang diperlukan untuk membuat transkrip siswa,
 * termasuk data siswa, sekolah, mata pelajaran, bobot nilai, dan pengaturan cetak yang tersimpan.
 *
 * @param {string} spreadsheetId - ID spreadsheet sekolah target.
 * @param {string} nisn - NISN siswa yang akan diambil datanya.
 * @returns {object} Objek berisi status dan payload data transkrip yang lengkap.
 */
function getTranscriptData(spreadsheetId, nisn) {
    try {
        // 1. Validasi Input Awal
        if (!spreadsheetId || !nisn) {
            throw new Error("ID Spreadsheet atau NISN tidak boleh kosong.");
        }

        // 2. Mengambil Data Utama
        const allStudents = getStudents(spreadsheetId);
        const student = allStudents.find(s => String(s.nisn).trim() === String(nisn).trim());

        if (!student) {
            throw new Error(`Siswa dengan NISN ${nisn} tidak dapat ditemukan.`);
        }

        const schoolData = getSchoolData(spreadsheetId);
        const mapelList = getMapel(spreadsheetId);
        const bobot = getBobot(spreadsheetId);
        const printSettings = getPrintSettings(spreadsheetId).settings || {}; // Mengambil pengaturan cetak

        if (!schoolData || !schoolData.jenjang) {
            throw new Error("Jenjang sekolah belum diatur. Silakan lengkapi di menu Data Sekolah.");
        }

        // 3. Menyiapkan Daftar Sheet Nilai yang Akan Dibaca
        const jenjang = schoolData.jenjang;
        const semesterKeys = {
            MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
            MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
            MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
        };
        const semestersForJenjang = semesterKeys[jenjang] || [];
        const sheetsToRead = [
            SHEET_NILAI_UJIAN_MADRASAH,
            SHEET_NILAI_UJIAN_PRAKTEK,
            ...semestersForJenjang.flatMap(smKey => [`Rapor_Pengetahuan_${smKey}`, `Rapor_Keterampilan_${smKey}`])
        ];

        // 4. Membaca Semua Data Nilai dalam Satu Operasi
        const allScoreData = {};
        sheetsToRead.forEach(sheetName => {
            allScoreData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName);
        });

        // 5. Melakukan Kalkulasi untuk Setiap Mata Pelajaran
        const transcriptSubjects = mapelList.map(mapel => {
            const kode = mapel.kode;
            const studentScoresUM = (allScoreData[SHEET_NILAI_UJIAN_MADRASAH] || {})[nisn] || {};
            const studentScoresUP = (allScoreData[SHEET_NILAI_UJIAN_PRAKTEK] || {})[nisn] || {};
            
            // Hitung Rata-rata Nilai Ujian
            const nilaiUM = parseFloat(studentScoresUM[kode]);
            const nilaiUP = parseFloat(studentScoresUP[kode]);
            let rataUjian = null;
            if (!isNaN(nilaiUM) && !isNaN(nilaiUP)) rataUjian = (nilaiUM + nilaiUP) / 2;
            else if (!isNaN(nilaiUM)) rataUjian = nilaiUM;
            else if (!isNaN(nilaiUP)) rataUjian = nilaiUP;

            // Hitung Rata-rata Nilai Rapor
            let totalNilaiRapor = 0;
            let semesterCount = 0;
            semestersForJenjang.forEach(smKey => {
                const nilaiP = parseFloat(((allScoreData[`Rapor_Pengetahuan_${smKey}`] || {})[nisn] || {})[kode]);
                const nilaiK = parseFloat(((allScoreData[`Rapor_Keterampilan_${smKey}`] || {})[nisn] || {})[kode]);
                if (!isNaN(nilaiP) && !isNaN(nilaiK)) { totalNilaiRapor += (nilaiP + nilaiK) / 2; semesterCount++; }
                else if (!isNaN(nilaiP)) { totalNilaiRapor += nilaiP; semesterCount++; }
                else if (!isNaN(nilaiK)) { totalNilaiRapor += nilaiK; semesterCount++; }
            });
            const rataRapor = semesterCount > 0 ? totalNilaiRapor / semesterCount : null;

            // Hitung Nilai Akhir Ijazah
            let nilaiIjazah = null;
            if (rataUjian !== null || rataRapor !== null) {
                const finalRataUjian = rataUjian !== null ? rataUjian : 0;
                const finalRataRapor = rataRapor !== null ? rataRapor : 0;
                nilaiIjazah = (finalRataUjian * (bobot.bobotUjian / 100)) + (finalRataRapor * (bobot.bobotRapor / 100));
            }

            return {
                kode: kode,
                nama: mapel.nama,
                kelompok: mapel.kelompok,
                nilaiRapor: rataRapor,
                nilaiUjian: rataUjian,
                nilaiIjazah: nilaiIjazah
            };
        });

        // 6. Menyusun Paket Data Final untuk Dikirim
        const finalTranscriptData = {
            student: student,
            school: schoolData,
            subjects: transcriptSubjects,
            bobot: bobot,
            printSettings: printSettings // Menyertakan pengaturan cetak
        };

        return { status: 'success', data: finalTranscriptData };

    } catch (e) {
        Logger.log('Error di getTranscriptData: ' + e.message + ' | Stack: ' + e.stack);
        return { status: 'error', message: 'Gagal mengambil data transkrip: ' + e.message };
    }
}

/**
 * Memeriksa apakah sheet rekapitulasi sudah ada.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {boolean} True jika semua sheet ada.
 */
function checkRekapSheetsExist(spreadsheetId) {
  const ss = getSpreadsheet(spreadsheetId);
  const sheetUjian = ss.getSheetByName(SHEET_REKAP_UJIAN);
  const sheetRapor = ss.getSheetByName(SHEET_REKAP_RAPOR);
  const sheetIjazah = ss.getSheetByName(SHEET_REKAP_IJAZAH);
  return !!(sheetUjian && sheetRapor && sheetIjazah);
}

/**
 * [DIPERBARUI] Mengekspor data rekapitulasi ke format PDF atau Excel.
 * Kini menyertakan kolom Status LULUS/TIDAK LULUS untuk rekap ijazah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} type Jenis rekap ('ujian', 'rapor', 'ijazah').
 * @param {string} format Format ekspor ('pdf' atau 'excel').
 * @param {object} exportOptions Objek berisi data dari form modal.
 * @returns {object} Objek berisi data file yang telah di-encode base64.
 */
function exportRekapData(spreadsheetId, type, format, exportOptions, selectedKelas) {
    let tempSpreadsheetFileId = null;
    try {
        // 1. Tentukan Judul Laporan
        let reportTitle;
        switch (type) {
            case 'ijazah': reportTitle = "REKAPITULASI NILAI IJAZAH"; break;
            case 'rapor': reportTitle = "REKAPITULASI NILAI RAPOR"; break;
            case 'ujian': reportTitle = "REKAPITULASI NILAI UJIAN"; break;
            default: throw new Error("Jenis rekap tidak valid.");
        }

        // 2. Ambil data yang diperlukan
        const { students, mapel } = getRekapitulasiData(spreadsheetId);
        if (!students || students.length === 0) throw new Error("Tidak ada data siswa untuk diekspor.");
        
        // ==========================================================
        // === AWAL BLOK KODE BARU: FILTER SISWA BERDASARKAN KELAS ==
        // ==========================================================
        let studentsToExport = students; // Gunakan semua siswa sebagai default
        if (selectedKelas && selectedKelas !== 'semua') {
            studentsToExport = students.filter(student => student.kelas === selectedKelas);
        }
        // Jika tidak ada siswa yang cocok setelah difilter, berikan pesan error.
        if (studentsToExport.length === 0) {
            throw new Error(`Tidak ada siswa yang ditemukan di kelas "${selectedKelas}" untuk diekspor.`);
        }
        // ==========================================================
        // === AKHIR BLOK KODE BARU =================================
        // ==========================================================
        
        const kkm = (type === 'ijazah') ? (getKkm(spreadsheetId).kkm || 75) : 75;
        const sheetName = `Rekap Nilai ${type.charAt(0).toUpperCase() + type.slice(1)}`;
        const dataToProcess = getSheetDataAsObject(spreadsheetId, sheetName);

        // 3. Bangun data tabel
        const tableBodyData = [];
        // GANTI 'students' MENJADI 'studentsToExport' PADA BAGIAN .forEach
        studentsToExport.forEach((student, index) => {
            const nisn = student.nisn;
            const studentScores = dataToProcess[nisn] || {};
            const rowData = [index + 1, `'${nisn}`, student.nama.toUpperCase()];
            
            let total = 0;
            // [PERBAIKAN 1] Kembalikan deklarasi validScoresCount untuk pengecekan status.
            let validScoresCount = 0; 

            mapel.forEach(m => {
                const score = parseFloat(studentScores[m.kode]);
                let displayValue = 0; // Default ke 0

                if (!isNaN(score)) {
                    const roundedScore = Math.round(score);
                    displayValue = roundedScore;
                    total += roundedScore;
                    // [PERBAIKAN 2] Kembalikan increment (penambahan) validScoresCount.
                    validScoresCount++; 
                }
                
                // Selalu push angka 0 atau nilai yang ada
                rowData.push(displayValue);
            });

            // [TETAP] Rata-rata TETAP menggunakan logika baru (dibagi jumlah total mapel).
            const mapelCount = mapel.length;
            const average = mapelCount > 0 ? (total / mapelCount) : 0;
            
            rowData.push(total);
            rowData.push(average.toFixed(2).replace('.', ','));

            if (type === 'ujian') {
                rowData.push(Math.round(average));
            } else if (type === 'ijazah') {
                // [TETAP] Status LULUS/TIDAK LULUS sekarang berfungsi kembali karena validScoresCount sudah ada.
                const status = (validScoresCount > 0 && average >= kkm) ? 'LULUS' : 'TIDAK LULUS';
                rowData.push(status);
            }
            
            tableBodyData.push(rowData);
        });
        
        // 4. Buat spreadsheet sementara
        const tempSpreadsheetName = `Cetak_${reportTitle.replace(/ /g, "_")}_${new Date().getTime()}`;
        const tempSpreadsheet = SpreadsheetApp.create(tempSpreadsheetName);
        tempSpreadsheetFileId = tempSpreadsheet.getId();
        const tempSheet = tempSpreadsheet.getSheets()[0];
        tempSheet.setName("Rekapitulasi");

        // --- PEMFORMATAN KUSTOM ---
        const schoolData = getSchoolData(spreadsheetId);
        let currentRow = 1;
        const numMapel = mapel.length;

        // [MODIFIKASI] Sesuaikan jumlah total kolom jika tipenya 'ujian' atau 'ijazah'
        let numColumns = numMapel + 5; // No, NISN, Nama, Jumlah, Rata-Rata
        if (type === 'ujian' || type === 'ijazah') {
            numColumns++; // Tambah 1 untuk kolom Pembulatan atau Status
        }

        // Header Laporan (tidak berubah)
        tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue(reportTitle).setFontSize(16);
        currentRow++;
        tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue((schoolData.namaSekolah || "NAMA SEKOLAH").toUpperCase()).setFontSize(16);
        currentRow++;
        tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue(`Tahun Ajaran ${exportOptions.tahunAjaran || ""}`).setFontSize(14);
        currentRow += 2;

        // --- HEADER TABEL (STRUKTUR 2 BARIS) ---
        const tableStartRow = currentRow;
        tempSheet.getRange(tableStartRow, 4, 1, numMapel).merge().setValue("MATA PELAJARAN");
        const mapelHeaders = mapel.map(m => m.kode);
        tempSheet.getRange(tableStartRow + 1, 4, 1, numMapel).setValues([mapelHeaders]);
        
        // Header Tetap
        tempSheet.getRange(tableStartRow, 1).setValue("No.");
        tempSheet.getRange(tableStartRow, 2).setValue("NISN");
        tempSheet.getRange(tableStartRow, 3).setValue("Nama Siswa");
        const jumlahCol = 4 + numMapel;
        const rataRataCol = 5 + numMapel;
        tempSheet.getRange(tableStartRow, jumlahCol).setValue("Jumlah");
        tempSheet.getRange(tableStartRow, rataRataCol).setValue("Rata-Rata");

        // Merge Vertikal
        tempSheet.getRange(tableStartRow, 1, 2, 1).merge();
        tempSheet.getRange(tableStartRow, 2, 2, 1).merge();
        tempSheet.getRange(tableStartRow, 3, 2, 1).merge();
        tempSheet.getRange(tableStartRow, jumlahCol, 2, 1).merge();
        tempSheet.getRange(tableStartRow, rataRataCol, 2, 1).merge();
        
        // [MODIFIKASI] Tambahkan header "Pembulatan" atau "Status"
        if (type === 'ujian') {
            const pembulatanCol = 6 + numMapel;
            tempSheet.getRange(tableStartRow, pembulatanCol).setValue("Pembulatan");
            tempSheet.getRange(tableStartRow, pembulatanCol, 2, 1).merge();
        } else if (type === 'ijazah') {
            const statusCol = 6 + numMapel;
            tempSheet.getRange(tableStartRow, statusCol).setValue("Status");
            tempSheet.getRange(tableStartRow, statusCol, 2, 1).merge();
        }
        
        // Tulis Body Tabel
        if (tableBodyData.length > 0) {
            tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, numColumns).setValues(tableBodyData);
        }

        // --- APLIKASI FORMAT ---
        const fullRange = tempSheet.getRange(1, 1, tempSheet.getLastRow() + 5, numColumns);
        fullRange.setFontFamily("Arial").setVerticalAlignment("middle");
        tempSheet.getRange(1, 1, 3, 1).setFontWeight("bold").setHorizontalAlignment("center");
        const tableHeaderRange = tempSheet.getRange(tableStartRow, 1, 2, numColumns);
        tableHeaderRange.setFontWeight("bold").setFontSize(12).setHorizontalAlignment("center").setBackground("#ffff00");
        if (tableBodyData.length > 0) {
            tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, numColumns).setFontSize(12);
            tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, 1).setHorizontalAlignment("center");
            tempSheet.getRange(tableStartRow + 2, 2, tableBodyData.length, 1).setNumberFormat("@").setHorizontalAlignment("center");
            tempSheet.getRange(tableStartRow + 2, 3, tableBodyData.length, 1).setHorizontalAlignment("left");
            tempSheet.getRange(tableStartRow + 2, 4, tableBodyData.length, numColumns - 3).setHorizontalAlignment("center");
        }
        tempSheet.getRange(tableStartRow, 1, tableBodyData.length + 2, numColumns).setBorder(true, true, true, true, true, true);
        
        // --- [BARU] PEWARNAAN KONDISIONAL UNTUK STATUS ---
        if (type === 'ijazah' && tableBodyData.length > 0) {
            const statusColumnIndex = numColumns; // Status adalah kolom terakhir
            const statusRange = tempSheet.getRange(tableStartRow + 2, statusColumnIndex, tableBodyData.length, 1);

            const ruleLulus = SpreadsheetApp.newConditionalFormatRule()
                .whenTextEqualTo("LULUS")
                .setBackground("#dcfce7") // Tailwind green-100
                .setFontColor("#166534")  // Tailwind green-800
                .setBold(true)
                .setRanges([statusRange])
                .build();

            const ruleTidakLulus = SpreadsheetApp.newConditionalFormatRule()
                .whenTextEqualTo("TIDAK LULUS")
                .setBackground("#fee2e2") // Tailwind red-100
                .setFontColor("#991b1b")  // Tailwind red-800
                .setBold(true)
                .setRanges([statusRange])
                .build();
            
            const rules = tempSheet.getConditionalFormatRules();
            rules.push(ruleLulus, ruleTidakLulus);
            tempSheet.setConditionalFormatRules(rules);

            // [BARU] Atur format spesifik untuk kolom Status agar tidak terpotong
            statusRange.setWrap(false).setHorizontalAlignment('center');
        }
        
        // --- Atur Lebar Kolom ---
        tempSheet.setColumnWidth(1, 40);
        tempSheet.setColumnWidth(2, 100);
        tempSheet.setColumnWidth(3, 220);
        for (let i = 4; i <= 3 + numMapel; i++) {
            tempSheet.setColumnWidth(i, 60);
        }
        tempSheet.setColumnWidth(jumlahCol, 80);
        tempSheet.setColumnWidth(rataRataCol, 80);
        // [MODIFIKASI] Atur lebar kolom "Pembulatan" atau "Status"
        if (type === 'ujian') {
            tempSheet.setColumnWidth(6 + numMapel, 90);
        } else if (type === 'ijazah') {
            tempSheet.setColumnWidth(6 + numMapel, 120);
        }

        // Blok Tanda Tangan
        const signatureBlockStartRow = tableStartRow + tableBodyData.length + 3;
        const signatureColumnStart = numColumns - 3;
        const formatDateToIndonesian = (dateString) => {
          if (!dateString) return "";
          const date = new Date(dateString);
          return new Intl.DateTimeFormat('id-ID', { day: '2-digit', month: 'long', year: 'numeric' }).format(date);
        };
        
        let ttdRow = signatureBlockStartRow;
        const ttdDate = formatDateToIndonesian(exportOptions.tanggalTTD);
        
        tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(`${exportOptions.tempatTTD || "Tempat"}, ${ttdDate}`);
        ttdRow++;
        tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(exportOptions.tipeKamad || "Kepala Madrasah");
        ttdRow += 3;
        tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(schoolData.namaKepsek || "Nama Kepala").setFontWeight("bold").setFontLine('underline');
        ttdRow++;
        const nipRange = tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge();
        nipRange.setNumberFormat("@");
        nipRange.setValue(schoolData.nipKepsek ? `NIP. ${schoolData.nipKepsek}` : "NIP. -");
        
        // Samakan ukuran font seluruh blok ttd
        tempSheet.getRange(signatureBlockStartRow, signatureColumnStart, 5, 4).setFontSize(12).setHorizontalAlignment("left");
        
        SpreadsheetApp.flush(); 

        // 5. Ekspor file
        const exportUrl = `https://docs.google.com/spreadsheets/d/${tempSpreadsheetFileId}/export`;
        const token = ScriptApp.getOAuthToken();
        const fetchOptions = { headers: { Authorization: `Bearer ${token}` }, muteHttpExceptions: true };
        let blob, fileName, mimeType;

        if (format === 'excel') {
          fileName = `${reportTitle.replace(/ /g, "_")}.xlsx`;
          mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
          const url = `${exportUrl}?format=xlsx`;
          blob = UrlFetchApp.fetch(url, fetchOptions).getBlob().setName(fileName);
        } else { // PDF
          fileName = `${reportTitle.replace(/ /g, "_")}.pdf`;
          mimeType = 'application/pdf';
          const pdfOptions = `?exportFormat=pdf&format=pdf&size=A4&portrait=false&fitw=true&sheetnames=false&printtitle=false&gridlines=false&gid=${tempSheet.getSheetId()}`;
          const url = `${exportUrl}${pdfOptions}`;
          blob = UrlFetchApp.fetch(url, fetchOptions).getBlob().setName(fileName);
        }
        
        if (!blob || blob.getBytes().length === 0) throw new Error("Gagal membuat file ekspor. Blob kosong.");
        
        // 6. Kembalikan data file
        return {
          fileName: fileName,
          mimeType: mimeType,
          base64Data: Utilities.base64Encode(blob.getBytes())
        };

    } catch (e) {
        Logger.log(`Export Error: ${e.toString()}\nStack: ${e.stack}`);
        return { error: e.toString() };
    } finally {
        if (tempSpreadsheetFileId) {
            DriveApp.getFileById(tempSpreadsheetFileId).setTrashed(true);
        }
    }
}

/**
 * [BARU] Menghitung rata-rata skor untuk setiap mata pelajaran dari sheet rekap.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi data rata-rata untuk setiap jenis rekap.
 */
function getSubjectAverageScores(spreadsheetId) {
  try {
    const mapel = getMapel(spreadsheetId);
    if (!mapel || mapel.length === 0) return {};

    const ss = getSpreadsheet(spreadsheetId);
    const labels = mapel.map(m => m.kode);

    // Helper function untuk memproses satu sheet
    const calculateAveragesForSheet = (sheetName) => {
      const sheet = ss.getSheetByName(sheetName);
      const averages = {};
      labels.forEach(l => averages[l] = 0); // Inisialisasi semua rata-rata ke 0

      if (!sheet || sheet.getLastRow() < 2) {
        return labels.map(() => 0); // Kembalikan array nol jika sheet kosong
      }

      const data = sheet.getDataRange().getValues();
      const headers = data.shift();
      const studentCount = data.length;
      if (studentCount === 0) return labels.map(() => 0);

      // Hitung total untuk setiap kolom
      const totals = new Array(headers.length).fill(0);
      data.forEach(row => {
        for (let i = 2; i < headers.length; i++) { // Mulai dari kolom ke-3 (setelah NISN dan Nama)
          const value = parseFloat(row[i]);
          if (!isNaN(value)) {
            totals[i] += value;
          }
        }
      });

      // Hitung rata-rata
      headers.forEach((header, i) => {
        if (averages.hasOwnProperty(header)) {
          averages[header] = totals[i] / studentCount;
        }
      });
      
      return labels.map(label => Math.round(averages[label] || 0));
    };

    return {
      ujian: { labels, data: calculateAveragesForSheet(SHEET_REKAP_UJIAN) },
      rapor: { labels, data: calculateAveragesForSheet(SHEET_REKAP_RAPOR) },
      ijazah: { labels, data: calculateAveragesForSheet(SHEET_REKAP_IJAZAH) }
    };

  } catch (e) {
    Logger.log("Error in getSubjectAverageScores: " + e.message);
    return {};
  }
}


/**
 * [DIUBAH & DIPERBAIKI] Mengambil data nilai rata-rata ujian untuk setiap siswa.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {Array<Object>} Array objek berisi nama dan skor rata-rata ujian setiap siswa.
 */
function getExamScoreShare(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const rekapUjianSheet = ss.getSheetByName(SHEET_REKAP_UJIAN);

    if (!rekapUjianSheet || rekapUjianSheet.getLastRow() < 2) {
      return [{ nama: 'Belum Ada Data', skor: 1 }];
    }

    const dataRange = rekapUjianSheet.getRange(2, 1, rekapUjianSheet.getLastRow() - 1, rekapUjianSheet.getLastColumn()).getValues();
    const headers = rekapUjianSheet.getRange(1, 1, 1, rekapUjianSheet.getLastColumn()).getValues()[0];

    // [PERBAIKAN] Mencari header "Nama Lengkap" dan "Rata-rata"
    const namaIndex = headers.indexOf("Nama Lengkap");
    const skorIndex = headers.indexOf("Rata-rata");

    if (namaIndex === -1 || skorIndex === -1) {
       return [{ nama: 'Kolom Tidak Ditemukan', skor: 1 }];
    }

    const studentScores = dataRange.map(row => {
      return {
        nama: row[namaIndex],
        skor: parseFloat(row[skorIndex]) || 0
      };
    });

    return studentScores;

  } catch (e) {
    Logger.log("Error in getExamScoreShare: " + e.message);
    return [{ nama: 'Gagal Memuat', skor: 1 }];
  }
}

/**
 * [DIPERBAIKI] Mendapatkan peringkat siswa berdasarkan nilai rata-rata ijazah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {array} Array objek berisi nama siswa dan rata-rata nilai ijazah, diurutkan berdasarkan peringkat.
 */
function getIjazahRanking(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const rekapIjazahSheet = ss.getSheetByName(SHEET_REKAP_IJAZAH);

    if (!rekapIjazahSheet || rekapIjazahSheet.getLastRow() < 2) {
      return [];
    }

    const dataRange = rekapIjazahSheet.getDataRange().getValues();
    const headers = dataRange.shift();
    
    // [PERBAIKAN] Mencari header "Nama Lengkap" dan "Rata-rata"
    const namaKolomIndex = headers.indexOf('Nama Lengkap');
    const nilaiKolomIndex = headers.indexOf('Rata-rata');

    if (namaKolomIndex === -1 || nilaiKolomIndex === -1) {
      return [];
    }

    const studentRanks = dataRange.map(row => ({
      nama: row[namaKolomIndex],
      nilai: parseFloat(row[nilaiKolomIndex]) || 0
    }));

    studentRanks.sort((a, b) => b.nilai - a.nilai);
    return studentRanks;

  } catch (e) {
    Logger.log("Error in getIjazahRanking: " + e.message);
    return [];
  }
}

/**
 * [MODIFIKASI] Mengambil data agregat untuk halaman dashboard.
 * Kini juga menyertakan jumlah siswa dengan nilai yang belum lengkap.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi data untuk dashboard.
 */
function getDashboardData(spreadsheetId) {
  try {
    // --- AWAL LOGIKA BARU UNTUK MENGAMBIL KODE SEKOLAH ---
    let schoolCode = 'TIDAK ADA';
    try {
      const masterSs = SpreadsheetApp.getActiveSpreadsheet();
      const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
      if (userSheet.getLastRow() > 1) {
        const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
        const userRow = data.find(row => row[5] === spreadsheetId); 
        if (userRow && userRow[12]) { 
          schoolCode = userRow[12];
        }
      }
    } catch (e) {
      Logger.log(`Tidak bisa mengambil Kode Sekolah untuk SS ID ${spreadsheetId}: ${e.message}`);
    }
    // --- AKHIR LOGIKA BARU ---

    const students = getStudents(spreadsheetId);
    const mapel = getMapel(spreadsheetId);
    const guru = getGuru(spreadsheetId); // <-- [PERUBAHAN] Tambahkan baris ini
    const schoolData = getSchoolData(spreadsheetId);
    const subjectAverages = getSubjectAverageScores(spreadsheetId);
    const examScoreShare = getExamScoreShare(spreadsheetId);
    const ijazahRanking = getIjazahRanking(spreadsheetId);

    let incompleteStudentsCount = 0;
    try {
        const validationResponse = validateAllScores(spreadsheetId);
        if (validationResponse.status === 'success' && validationResponse.data) {
            incompleteStudentsCount = validationResponse.data.filter(student => student.missingCount > 0).length;
        }
    } catch (e) {
        Logger.log(`Validasi di dashboard gagal: ${e.message}`);
    }

    return {
      status: "success",
      studentCount: students.length,
      mapelCount: mapel.length,
      guruCount: guru.length, // <-- [PERUBAHAN] Tambahkan baris ini
      schoolData: schoolData,
      mapelList: mapel,
      subjectAverages: subjectAverages,
      examScoreShare: examScoreShare,
      ijazahRanking: ijazahRanking,
      schoolCode: schoolCode,
      incompleteCount: incompleteStudentsCount
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengambil data dashboard: " + e.message };
  }
}

// [PERUBAHAN] Tambahkan fungsi baru ini
/**
 * Memperbarui data beberapa siswa sekaligus berdasarkan data dari file impor.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} studentsToUpdate Array objek siswa yang akan diupdate.
 * @returns {{status: string, message: string}} Status pembaruan.
 */
function batchUpdateStudents(spreadsheetId, studentsToUpdate) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    let updatedCount = 0;

    studentsToUpdate.forEach(studentData => {
      const rowToUpdate = [
        studentData.nisn, studentData.nis, studentData.nomorUjian, studentData.nama,
        studentData.jenisKelamin, toProperCase(studentData.tempatLahir),
        studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '',
        studentData.alamat, studentData.telepon, studentData.emailSiswa,
        studentData.tahunMasuk, studentData.tahunLulus, studentData.tampilkanTranskrip,
        studentData.kelas, studentData.ruangUjian
      ];

      const targetRange = sheet.getRange(studentData.studentRow, 1, 1, rowToUpdate.length);
      
      sheet.getRange(studentData.studentRow, 1, 1, 2).setNumberFormat('@'); // NISN, NIS
      sheet.getRange(studentData.studentRow, 8, 1, 1).setNumberFormat('@'); // Telepon di kolom H

      targetRange.setValues([rowToUpdate]);
      updatedCount++;
    });

    return { status: "success", message: `${updatedCount} data siswa berhasil diperbarui.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data siswa secara massal: " + e.message };
  }
}

// ===== [BARU] FUNGSI UNTUK MENGHAPUS SEMUA NILAI UJIAN =====
/**
 * Menghapus semua konten dari sheet Nilai Ujian Madrasah dan Praktek.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllUjianScores(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheetNames = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK];
    let clearedCount = 0;

    sheetNames.forEach(name => {
      const sheet = ss.getSheetByName(name);
      if (sheet && sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
        clearedCount++;
      }
    });

    if (clearedCount === 0) {
      return { status: "info", message: "Tidak ada data nilai ujian untuk dihapus." };
    }
    
    return { status: "success", message: "Semua data nilai Ujian Madrasah & Praktek telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data nilai ujian: " + e.message };
  }
}


// ===== [BARU] FUNGSI UNTUK MENGHAPUS SEMUA NILAI RAPOR PER SEMESTER =====
/**
 * Menghapus semua konten nilai rapor (Pengetahuan & Keterampilan) untuk semester tertentu.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} semesterKey Kunci semester, cth: 'k10_ganjil'.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllRaporScoresBySemester(spreadsheetId, semesterKey) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheetNames = [
      `Rapor_Pengetahuan_${semesterKey}`,
      `Rapor_Keterampilan_${semesterKey}`
    ];
    let clearedCount = 0;

    sheetNames.forEach(name => {
      const sheet = ss.getSheetByName(name);
      if (sheet && sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
        clearedCount++;
      }
    });
    
    if (clearedCount === 0) {
      return { status: "info", message: "Tidak ada data nilai rapor untuk semester ini yang bisa dihapus." };
    }

    return { status: "success", message: `Semua data nilai rapor untuk semester ini telah berhasil dihapus.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data rapor semester: " + e.message };
  }
}

/**
 * [BARU] Membandingkan dua objek data siswa untuk melihat apakah identik di semua kolom.
 * @param {object} studentA Objek data siswa pertama.
 * @param {object} studentB Objek data siswa kedua.
 * @returns {boolean} True jika identik, false jika ada perbedaan.
 */
function areStudentsIdentical(studentA, studentB) {
  // Daftar semua kunci yang ingin dibandingkan
  const keysToCompare = [
    'nisn', 'nis', 'nama', 'jenisKelamin', 'tempatLahir', 'tanggalLahir',
    'alamat', 'telepon', 'emailSiswa', 'tahunMasuk', 'tahunLulus'
  ];

  for (const key of keysToCompare) {
    // Menggunakan (objek[key] || '') untuk menangani nilai null/undefined sebagai string kosong
    // Ini memastikan perbandingan yang konsisten.
    const valueA = (studentA[key] || '').toString().trim();
    const valueB = (studentB[key] || '').toString().trim();

    // Khusus untuk tempat lahir, kita bandingkan dalam format Proper Case
    if (key === 'tempatLahir') {
      if (toProperCase(valueA) !== toProperCase(valueB)) {
        return false; // Jika berbeda, langsung kembalikan false
      }
    } else {
      if (valueA !== valueB) {
        return false; // Jika ada satu saja perbedaan, mereka tidak identik
      }
    }
  }

  // Jika loop selesai tanpa menemukan perbedaan, berarti mereka identik
  return true;
}

// =================================================================
// FUNGSI KHUSUS SUPERADMIN
// =================================================================

// File: Kode.gs

/**
 * [STANDAR KEAMANAN] Memverifikasi apakah email yang diberikan memiliki peran Superadmin.
 * @param {string} email Email pengguna yang akan diperiksa.
 * @returns {boolean} True jika Superadmin, false jika bukan.
 */
function isSuperadmin(email) {
  if (!email) { 
    return false;
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // Gunakan konstanta yang sudah ada
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA); 
    if (!userSheet || userSheet.getLastRow() < 2) return false;

    // Ambil data dari kolom B (email) dan kolom G (role)
    const emailColumn = userSheet.getRange("B2:B").getValues().flat();
    const roleColumn = userSheet.getRange("G2:G").getValues().flat();
    
    // Cari indeks baris berdasarkan email
    const userIndex = emailColumn.findIndex(sheetEmail => sheetEmail && sheetEmail.toLowerCase() === email.toLowerCase());
    
    // Jika email ditemukan, cek perannya di indeks yang sama
    if (userIndex !== -1) {
      return roleColumn[userIndex] === 'Superadmin';
    }
    
    return false; // Jika email tidak ditemukan
  } catch (e) {
    Logger.log("Error in isSuperadmin: " + e.message);
    return false;
  }
}

/**
 * [SUPERADMIN - VERSI SUPER CEPAT] Mengambil data pengguna dari PropertiesService, 
 * dengan fallback ke sheet cache jika perlu.
 */
function getAllUsers_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }

  const scriptProperties = PropertiesService.getScriptProperties();
  const cachedJson = scriptProperties.getProperty('userManagementCache');

  let dataToMap;

  if (cachedJson) {
    dataToMap = JSON.parse(cachedJson);
  } else {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_CACHE_AKUN);
    if (!sheet || sheet.getLastRow() < 2) {
        return [];
    }
    // --- PERBAIKAN: BACA HINGGA KOLOM KE-10 ---
    const sheetData = sheet.getRange(2, 1, sheet.getLastRow() - 1, 10).getValues();
    dataToMap = sheetData.filter(row => row[0] && row[0] !== 'last_updated');
  }

  return dataToMap.map((row) => {
    return {
      email: row[0],
      namaSekolah: row[1],
      jenjang: row[2],
      schoolCode: row[3],
      status: row[4],
      studentLimit: row[5],
      currentStudentCount: row[6],
      row: row[7],
      role: row[8],
      // --- PERBAIKAN: Baca dari indeks 9 (kolom ke-10) ---
      fiturTerkunci: row[9] || 'TIDAK' 
    };
  });
}

/**
 * [SUPERADMIN] Memperbarui data pengguna (Nama Sekolah & Jenjang) oleh Superadmin.
 * @param {string} adminEmail Email superadmin yang melakukan aksi.
 * @param {object} userData Objek berisi data yang akan diupdate {row, namaSekolah, jenjang}.
 * @returns {{status: string, message: string}} Hasil proses.
 */
function updateUserBySuperadmin(adminEmail, userData) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    
    // Update Nama Sekolah (Kolom D) dan Jenjang (Kolom E) di sheet Data Pengguna
    userSheet.getRange(userData.row, 4).setValue(userData.namaSekolah);
    userSheet.getRange(userData.row, 5).setValue(userData.jenjang);

    // Update juga di dalam spreadsheet sekolah yang bersangkutan
    const schoolSsId = userSheet.getRange(userData.row, 6).getValue();
    const schoolSs = SpreadsheetApp.openById(schoolSsId);
    const dataSekolahSheet = schoolSs.getSheetByName(SHEET_DATA_SEKOLAH);
    if (dataSekolahSheet) {
      dataSekolahSheet.getRange(2, 1).setValue(userData.jenjang); // Jenjang di A2
      dataSekolahSheet.getRange(2, 2).setValue(userData.namaSekolah); // Nama Sekolah di B2
    }

    return { status: "success", message: `Data untuk akun ${userData.email} berhasil diperbarui.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data: " + e.message };
  }
}

/**
 * [SUPERADMIN] Mengubah status akun pengguna (Aktif/Nonaktif).
 * @param {string} adminEmail Email superadmin yang melakukan aksi.
 * @param {number} rowNomor Nomor baris pengguna yang akan diubah.
 * @param {string} newStatus Status baru ('Aktif' atau 'Nonaktif').
 * @returns {{status: string, message: string}} Hasil proses.
 */
function setUserStatus_Superadmin(adminEmail, rowNumber, newStatus) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    // Kolom Status adalah kolom ke-8 (H)
    userSheet.getRange(rowNumber, 8).setValue(newStatus); 
    return { status: "success", message: `Status akun berhasil diubah menjadi ${newStatus}.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengubah status: " + e.message };
  }
}

/**
 * [SUPERADMIN - VERSI CEPAT DENGAN PROPERTIES SERVICE] Mengambil data statistik dari cache.
 * @param {string} adminEmail - Email superadmin untuk verifikasi.
 * @returns {object} Objek berisi data statistik.
 */
function getSuperadminDashboardData(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }

  try {
    const scriptProperties = PropertiesService.getScriptProperties();
    const cachedJson = scriptProperties.getProperty('superadminDashboardCache');

    if (cachedJson) {
      // JALUR CEPAT: Data ditemukan di PropertiesService, langsung kirim
      const cachedStats = JSON.parse(cachedJson);
      return { status: 'success', ...cachedStats };
    } else {
      // JALUR LAMBAT (HANYA UNTUK PERTAMA KALI): Jika cache belum ada, beri pesan
      // Trigger otomatis atau klik manual pertama akan membuat cache ini.
      return {
        status: "success",
        totalAccounts: 0, activeAccounts: 0, inactiveAccounts: 0,
        totalStudents: 0, totalRequests: 0, pendingRequests: 0,
        approvedRequests: 0, rejectedRequests: 0,
        lastUpdated: "Belum pernah"
      };
    }
  } catch (e) {
    Logger.log("Error saat membaca cache dashboard dari PropertiesService: " + e.message);
    return { status: "error", message: "Gagal membaca cache: " + e.message };
  }
}

/**
 * [SUPERADMIN] Memicu pembaruan cache akun pengguna secara manual.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {object} Hasil operasi.
 */
function updateUserCache_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    runUserCacheUpdateTrigger(); // Panggil fungsi inti
    return { status: 'success', message: 'Pembaruan cache akun telah dimulai dan akan segera selesai.' };
  } catch(e) {
    Logger.log("updateUserCache_Superadmin (manual) Error: " + e.message);
    return { status: 'error', message: 'Gagal memulai pembaruan cache: ' + e.message };
  }
}

// ===== TAMBAHKAN FUNGSI BARU INI DI Kode.gs =====

/**
 * [SUPERADMIN] Mengambil waktu terakhir cache akun diperbarui.
 * @returns {object} Objek berisi status dan timestamp dalam format ISO string.
 */
function getUserCacheLastUpdated_Superadmin() {
  try {
    const cacheSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_CACHE_AKUN);
    if (!cacheSheet || cacheSheet.getLastRow() < 2) {
      return { status: 'success', lastUpdated: null };
    }

    const data = cacheSheet.getDataRange().getValues();
    // Cari dari bawah ke atas untuk efisiensi
    for (let i = data.length - 1; i >= 1; i--) {
      if (data[i][0] === 'last_updated') {
        return { status: 'success', lastUpdated: data[i][1] };
      }
    }

    return { status: 'success', lastUpdated: null }; // Tidak ditemukan
  } catch(e) {
    return { status: 'error', message: e.message };
  }
}
// ===== AKHIR KODE BARU (Fungsi Update Cache) =====

/**
 * [BARU] Menjalankan pembaruan cache, lalu langsung memanggil getSuperadminDashboardData
 * untuk mengembalikan data yang paling fresh ke UI.
 * @param {string} adminEmail - Email superadmin untuk verifikasi.
 */
function forceDashboardCacheUpdate_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    // 1. Jalankan proses update yang lambat
    updateSuperadminDashboardCache();
    
    // 2. Setelah selesai, panggil fungsi pembaca data yang cepat untuk mendapatkan hasil terbaru
    const freshData = getSuperadminDashboardData(adminEmail);
    
    // 3. Kembalikan data terbaru ini ke frontend
    return { 
      status: 'success', 
      message: 'Data dashboard berhasil diperbarui!',
      dashboardData: freshData // <-- Kita sertakan data baru di sini
    };

  } catch (e) {
    Logger.log('Gagal force update cache: ' + e.message);
    return { status: "error", message: 'Gagal memperbarui data: ' + e.message };
  }
}

/**
 * Helper function untuk memeriksa apakah pengguna telah mencapai batas siswa.
 * @param {string} spreadsheetId ID spreadsheet pengguna.
 * @param {string} userEmail Email pengguna yang akan diperiksa.
 * @returns {{limitReached: boolean, message: string}} Objek berisi status batas.
 */
function checkStudentLimit(spreadsheetId, userEmail) {
  try {
    // Dapatkan batas siswa dari sheet Data Pengguna
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    const userRow = usersData.find(row => row[1].toLowerCase() === userEmail.toLowerCase());
    
    if (!userRow) {
      return { limitReached: true, message: "Data pengguna tidak ditemukan." };
    }
    const studentLimit = parseInt(userRow[8]); // Kolom I adalah student limit

    if (isNaN(studentLimit)) {
      // Jika batas tidak diatur, anggap tidak ada batas (untuk keamanan)
      return { limitReached: false, message: "" };
    }

    // Dapatkan jumlah siswa saat ini
    const studentSs = SpreadsheetApp.openById(spreadsheetId);
    const studentSheet = studentSs.getSheetByName(SHEET_DATA_SISWA);
    const currentStudentCount = studentSheet ? studentSheet.getLastRow() - 1 : 0;

    if (currentStudentCount >= studentLimit) {
      return { limitReached: true, message: `Batas jumlah siswa tercapai (${currentStudentCount}/${studentLimit}). Anda tidak dapat menambahkan siswa baru. Hubungi admin untuk menaikkan batas.` };
    }

    return { limitReached: false, message: "" };

  } catch (e) {
    Logger.log(`Error di checkStudentLimit: ${e.message}`);
    return { limitReached: true, message: "Terjadi kesalahan saat memeriksa batas siswa." };
  }
}

/**
 * [SUPERADMIN] Mengatur batas jumlah siswa untuk akun tertentu.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {number} rowNumber Nomor baris pengguna yang akan diubah.
 * @param {number} newLimit Batas baru yang akan ditetapkan.
 * @returns {object} Hasil proses.
 */
function setStudentLimit_Superadmin(adminEmail, rowNumber, newLimit) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const limit = parseInt(newLimit);
    if (isNaN(limit) || limit < 0) {
      return { status: "error", message: "Batas siswa harus berupa angka positif." };
    }
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    userSheet.getRange(rowNumber, 9).setValue(limit); // Kolom I adalah Student Limit
    return { status: "success", message: "Batas siswa berhasil diperbarui." };
  } catch (e) {
    return { status: "error", message: "Gagal memperbarui batas: " + e.message };
  }
}

/**
 * [SUPERADMIN] Mengatur dan mengambil batas default siswa untuk pendaftaran baru.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {number} [newLimit] Batas default baru (opsional). Jika tidak diberikan, fungsi hanya akan mengambil nilai saat ini.
 * @returns {object} Hasil proses atau nilai saat ini.
 */
function manageDefaultStudentLimit_Superadmin(adminEmail, newLimit) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const configSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Konfigurasi Sistem');
    if (!configSheet) {
      return { status: "error", message: "Sheet 'Konfigurasi Sistem' tidak ditemukan." };
    }
    const limitCell = configSheet.getRange("B2");

    if (newLimit !== undefined && newLimit !== null) {
      // Mode: Mengatur nilai baru
      const limit = parseInt(newLimit);
      if (isNaN(limit) || limit < 0) {
        return { status: "error", message: "Batas default harus berupa angka positif." };
      }
      limitCell.setValue(limit);
      return { status: "success", message: `Batas default siswa berhasil diubah menjadi ${limit}.`, currentLimit: limit };
    } else {
      // Mode: Mengambil nilai saat ini
      const currentLimit = limitCell.getValue();
      return { status: "success", currentLimit: currentLimit };
    }
  } catch (e) {
    return { status: "error", message: "Gagal mengelola batas default: " + e.message };
  }
}

/**
 * [BARU] Mengambil informasi kuota siswa untuk pengguna yang sedang login.
 * @param {string} userEmail Email pengguna.
 * @returns {object} Objek berisi info kuota: {status, totalLimit, usedCount, remaining}.
 */
function getStudentQuotaInfo(userEmail) {
  if (!userEmail) {
    return { status: "error", message: "Email pengguna tidak diberikan." };
  }

  try {
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    const userRow = usersData.find(row => row[1] && row[1].toLowerCase() === userEmail.toLowerCase());

    if (!userRow) {
      return { status: "error", message: "Data pengguna tidak ditemukan." };
    }

    const role = userRow[6];
    if (role === 'Superadmin') {
        // Superadmin tidak memiliki kuota siswa
        return { status: "success", totalLimit: 'Tak Terbatas', usedCount: '-', remaining: '-' };
    }

    const spreadsheetId = userRow[5];
    const studentLimit = parseInt(userRow[8]);

    if (!spreadsheetId) {
        return { status: "error", message: "Spreadsheet ID tidak ditemukan untuk pengguna ini." };
    }

    // Jika batas tidak diatur atau bukan angka, anggap tak terbatas
    if (isNaN(studentLimit)) {
      const studentSheet = SpreadsheetApp.openById(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
      const usedCount = studentSheet ? Math.max(0, studentSheet.getLastRow() - 1) : 0;
      return { status: "success", totalLimit: 'Tak Terbatas', usedCount: usedCount, remaining: '-' };
    }

    const studentSs = SpreadsheetApp.openById(spreadsheetId);
    const studentSheet = studentSs.getSheetByName(SHEET_DATA_SISWA);
    const usedCount = studentSheet ? Math.max(0, studentSheet.getLastRow() - 1) : 0;
    
    const remaining = studentLimit - usedCount;

    return {
      status: "success",
      totalLimit: studentLimit,
      usedCount: usedCount,
      remaining: remaining
    };

  } catch (e) {
    Logger.log(`Error di getStudentQuotaInfo untuk ${userEmail}: ${e.message}`);
    return { status: "error", message: "Gagal mengambil informasi kuota." };
  }
}

// =================================================================
// [BARU] FUNGSI PENGAJUAN PERUBAHAN DATA
// =================================================================

/**
 * [BARU & DIPERBAIKI] Mengajukan permintaan perubahan data sekolah oleh pengguna.
 * @param {string} userEmail Email pengguna yang mengajukan.
 * @param {object} newData Objek berisi data baru { jenjang, namaSekolah }.
 * @returns {{status: string, message: string}} Hasil dari pengajuan.
 */
function submitChangeRequest(userEmail, newData) {
  try {
    const { newJenjang, newNamaSekolah } = newData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);

    // Jika sheet belum ada, buat baru dengan header.
    if (!pengajuanSheet) {
      pengajuanSheet = ss.insertSheet(SHEET_PENGAJUAN);
      pengajuanSheet.appendRow([
        "Request ID", "User Email", "Jenjang Lama", "Nama Sekolah Lama", 
        "Jenjang Baru", "Nama Sekolah Baru", "Tanggal Ajuan", "Status", 
        "Catatan Admin", "Tanggal Diproses"
      ]);
    }

    // Cek apakah ada pengajuan yang masih menunggu dari pengguna yang sama.
    if (pengajuanSheet.getLastRow() > 1) {
        const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
        const pendingRequest = data.find(row => row[1] === userEmail && row[7] === 'Menunggu Persetujuan');
        if (pendingRequest) {
            return { status: "error", message: "Anda sudah memiliki pengajuan yang sedang diproses. Harap tunggu hingga admin meninjaunya." };
        }
    }
    
    // Dapatkan data sekolah saat ini untuk disimpan sebagai 'data lama'.
    const userRow = findUserRowByEmail(userEmail);
    if (!userRow) {
        return { status: "error", message: "Data pengguna tidak ditemukan." };
    }
    const oldJenjang = userRow[4]; // Kolom E
    const oldNamaSekolah = userRow[3]; // Kolom D

    if (!newJenjang && !newNamaSekolah) {
       return { status: "error", message: "Tidak ada data baru yang diajukan untuk diubah." };
    }

    const requestId = Utilities.getUuid();
    const requestDate = new Date();
    
    pengajuanSheet.appendRow([
      requestId,
      userEmail,
      oldJenjang,
      oldNamaSekolah,
      newJenjang || oldJenjang, // Jika tidak diubah, pakai data lama
      newNamaSekolah || oldNamaSekolah, // Jika tidak diubah, pakai data lama
      requestDate,
      'Menunggu Persetujuan', // Status awal
      '', // Catatan Admin kosong
      '',  // Tanggal diproses kosong
      'Proses' // <-- [TAMBAHAN BARU] Kolom K: Status Dibaca
    ]);

    // --- AWAL KODE NOTIFIKASI EMAIL SUPERADMIN ---
    try {
      const superadminEmail = "syamsulbahri.agro27b@gmail.com"; // GANTI DENGAN EMAIL SUPERADMIN ANDA
      const subject = "[Aplikasi Ijazah] Pengajuan Perubahan Data Baru";
      const body = `
        <p>Halo Superadmin,</p>
        <p>Ada pengajuan perubahan data baru yang masuk dari pengguna:</p>
        <ul>
          <li><b>Email Pengguna:</b> ${userEmail}</li>
          <li><b>Nama Sekolah:</b> ${oldNamaSekolah}</li>
          <li><b>Tanggal Ajuan:</b> ${requestDate.toLocaleString('id-ID')}</li>
        </ul>
        <p>Data yang diajukan untuk diubah:</p>
        <ul>
          <li><b>Jenjang Baru:</b> ${newJenjang || '(tidak diubah)'}</li>
          <li><b>Nama Sekolah Baru:</b> ${newNamaSekolah || '(tidak diubah)'}</li>
        </ul>
        <p>Silakan masuk ke panel Superadmin untuk meninjau dan memproses pengajuan ini.</p>
        <br>
        <p>Terima kasih.</p>
      `;
      MailApp.sendEmail(superadminEmail, subject, "", { htmlBody: body });
    } catch (e) {
      Logger.log("Gagal mengirim notifikasi email pengajuan ke Superadmin: " + e.message);
    }
    // --- AKHIR KODE NOTIFIKASI EMAIL SUPERADMIN ---

    // !! PENTING: TAMBAHKAN BARIS INI !!
    // Memaksa Google untuk menyelesaikan semua operasi penulisan sebelum melanjutkan.
    SpreadsheetApp.flush(); 

    return { status: "success", message: "Pengajuan perubahan data berhasil dikirim dan sedang menunggu persetujuan admin." };

  } catch (e) {
    Logger.log(`submitChangeRequest Error: ${e.toString()}`);
    return { status: "error", message: "Gagal mengirim pengajuan: " + e.message };
  }
}

/**
 * [BARU] Mengambil status pengajuan terakhir dari seorang pengguna.
 * @param {string} userEmail Email pengguna.
 * @returns {object|null} Objek berisi detail pengajuan terakhir atau null jika tidak ada.
 */
function getChangeRequestStatus(userEmail) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!pengajuanSheet || pengajuanSheet.getLastRow() < 2) {
      return null;
    }

    const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
    // Cari dari bawah ke atas untuk mendapatkan data terbaru
    for (let i = data.length - 1; i >= 0; i--) {
      if (data[i][1] === userEmail) {
        // Ditemukan ajuan terakhir dari pengguna ini
        return {
          requestId: data[i][0],
          userEmail: data[i][1],
          oldJenjang: data[i][2],
          oldNamaSekolah: data[i][3],
          newJenjang: data[i][4],
          newNamaSekolah: data[i][5],
          requestDate: data[i][6],
          status: data[i][7],
          adminNotes: data[i][8],
          resolvedDate: data[i][9]
        };
      }
    }
    return null; // Tidak ada ajuan dari pengguna ini
  } catch (e) {
    Logger.log(`getChangeRequestStatus Error: ${e.toString()}`);
    return null;
  }
}

/**
 * [BARU] Helper function untuk mencari baris pengguna berdasarkan email.
 * @param {string} email Email pengguna.
 * @returns {Array|null} Array data baris pengguna atau null.
 */
function findUserRowByEmail(email) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet || userSheet.getLastRow() < 2) return null;
    const users = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    return users.find(userRow => userRow[1].toLowerCase() === email.toLowerCase());
}

/**
 * [SUPERADMIN] Mengambil semua data pengajuan perubahan data.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek data pengajuan.
 */
function getChangeRequests_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!sheet || sheet.getLastRow() < 2) {
      return [];
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    
    const requests = data.map(row => ({
      requestId: row[0],
      userEmail: row[1],
      oldJenjang: row[2],
      oldNamaSekolah: row[3],
      newJenjang: row[4],
      newNamaSekolah: row[5],
      requestDate: row[6] instanceof Date ? row[6].toISOString() : new Date().toISOString(),
      status: row[7],
      adminNotes: row[8] || '' // <-- [PERBAIKAN] Ambil juga data catatan admin
    })).filter(req => req.requestId);

    requests.sort((a, b) => {
        if (a.status === 'Menunggu Persetujuan' && b.status !== 'Menunggu Persetujuan') return -1;
        if (a.status !== 'Menunggu Persetujuan' && b.status === 'Menunggu Persetujuan') return 1;
        return new Date(b.requestDate).getTime() - new Date(a.requestDate).getTime();
    });

    return requests;

  } catch (e) {
    Logger.log("getChangeRequests_Superadmin Error: " + e.message);
    return [];
  }
}


/**
 * [SUPERADMIN] Memproses (menyetujui/menolak) pengajuan perubahan data.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {string} requestId ID dari pengajuan yang akan diproses.
 * @param {string} resolution Keputusan ('Disetujui' atau 'Ditolak').
 * @param {string} adminNotes Catatan dari admin (khusus jika ditolak).
 * @returns {{status: string, message: string}} Hasil proses.
 */
function resolveChangeRequest_Superadmin(adminEmail, requestId, resolution, adminNotes) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Kunci proses untuk menghindari double-processing

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    const dataRange = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn());
    const data = dataRange.getValues();

    const requestIndex = data.findIndex(row => row[0] === requestId);

    if (requestIndex === -1) {
      return { status: "error", message: "Pengajuan tidak ditemukan." };
    }
    
    const requestRow = data[requestIndex];
    if (requestRow[7] !== 'Menunggu Persetujuan') {
      return { status: "error", message: "Pengajuan ini sudah pernah diproses." };
    }

    const userEmail = requestRow[1];
    const newJenjang = requestRow[4];
    const newNamaSekolah = requestRow[5];

    // Jika disetujui, lakukan perubahan data.
    if (resolution === 'Disetujui') {
      const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
      const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
      const userIndex = usersData.findIndex(row => row[1] === userEmail);
      
      if (userIndex !== -1) {
        const userRowNumber = userIndex + 2;
        
        // 1. Update di sheet Data Pengguna
        userSheet.getRange(userRowNumber, 4).setValue(newNamaSekolah); // Kolom D
        userSheet.getRange(userRowNumber, 5).setValue(newJenjang);    // Kolom E
        
        // 2. Update di spreadsheet sekolah yang bersangkutan
        const schoolSsId = usersData[userIndex][5]; // Kolom F
        if (schoolSsId) {
            const schoolSs = SpreadsheetApp.openById(schoolSsId);
            const dataSekolahSheet = schoolSs.getSheetByName(SHEET_DATA_SEKOLAH);
            if (dataSekolahSheet) {
              dataSekolahSheet.getRange("A2").setValue(newJenjang);
              dataSekolahSheet.getRange("B2").setValue(newNamaSekolah);
            }
        }
      } else {
         throw new Error(`Pengguna dengan email ${userEmail} tidak ditemukan di Data Pengguna.`);
      }
    }

    // Update status di sheet Data Pengajuan
    const targetRowInSheet = requestIndex + 2;
    pengajuanSheet.getRange(targetRowInSheet, 8).setValue(resolution); // Status
    pengajuanSheet.getRange(targetRowInSheet, 9).setValue(adminNotes); // Catatan Admin
    pengajuanSheet.getRange(targetRowInSheet, 10).setValue(new Date()); // Tanggal Diproses
    pengajuanSheet.getRange(targetRowInSheet, 11).setValue('Belum Dibaca'); // Set Status Dibaca

    // --- AWAL KODE NOTIFIKASI EMAIL PENGGUNA ---
    try {
      const subject = `[Aplikasi Ijazah] Status Pengajuan Anda Telah Diperbarui: ${resolution}`;
      let body = `
        <p>Halo,</p>
        <p>Pengajuan perubahan data yang Anda kirim pada tanggal ${requestRow[6].toLocaleString('id-ID')} telah diproses oleh admin.</p>
        <p><b>Status baru: ${resolution}</b></p>
      `;
      if (resolution === 'Disetujui') {
        body += "<p>Perubahan data pada akun Anda telah berhasil diterapkan. Silakan periksa kembali data sekolah Anda di aplikasi.</p>";
      } else if (resolution === 'Ditolak' && adminNotes) {
        body += `<p><b>Alasan Penolakan:</b> ${adminNotes}</p><p>Anda dapat mengajukan perubahan data kembali melalui aplikasi jika diperlukan.</p>`;
      }
      body += "<br><p>Terima kasih.</p>";
      
      MailApp.sendEmail(userEmail, subject, "", { htmlBody: body });
    } catch (e) {
      Logger.log(`Gagal mengirim notifikasi email status pengajuan ke pengguna ${userEmail}: ${e.message}`);
    }
    // --- AKHIR KODE NOTIFIKASI EMAIL PENGGUNA ---

    return { status: 'success', message: `Pengajuan berhasil ${resolution.toLowerCase()}.` };

  } catch (e) {
    Logger.log("resolveChangeRequest_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memproses pengajuan: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN] Menghitung jumlah pengajuan yang berstatus "Menunggu Persetujuan".
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @returns {{status: string, count: number}} Objek berisi status dan jumlah hitungan.
 */
function getPendingRequestCount_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    // Sebaiknya tidak melempar error agar tidak mengganggu UI jika terjadi masalah sesi
    return { status: "error", count: 0 }; 
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!sheet || sheet.getLastRow() < 2) {
      return { status: "success", count: 0 };
    }

    // Ambil hanya kolom status (kolom H, indeks 7) untuk efisiensi
    const statusColumn = sheet.getRange(2, 8, sheet.getLastRow() - 1, 1).getValues();
    
    // Hitung yang statusnya "Menunggu Persetujuan"
    const pendingCount = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
    
    return { status: "success", count: pendingCount };

  } catch (e) {
    Logger.log("getPendingRequestCount_Superadmin Error: " + e.message);
    return { status: "error", count: 0 };
  }
}

/**
 * [BARU] Mengambil SEMUA riwayat pengajuan perubahan data untuk seorang pengguna.
 * @param {string} userEmail Email pengguna.
 * @returns {Array<object>} Array berisi semua objek pengajuan, diurutkan dari terbaru.
 */
function getChangeRequestHistory_User(userEmail) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!pengajuanSheet || pengajuanSheet.getLastRow() < 2) {
      return []; // Kembalikan array kosong jika tidak ada data
    }

    const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
    
    // 1. Filter untuk mendapatkan semua baris milik pengguna ini
    const userRequests = data.filter(row => row[1] === userEmail);

    // 2. Ubah menjadi objek dan urutkan dari yang terbaru
    const history = userRequests.map(row => ({
        requestId: row[0],
        requestDate: row[6] instanceof Date ? row[6].toISOString() : new Date().toISOString(),
        oldJenjang: row[2],
        oldNamaSekolah: row[3],
        newJenjang: row[4],
        newNamaSekolah: row[5],
        status: row[7],
        adminNotes: row[8],
        statusBaca: row[10] || 'Proses' // <-- [TAMBAHAN BARU] Ambil data dari kolom K (indeks 10)
    })).sort((a, b) => new Date(b.requestDate).getTime() - new Date(a.requestDate).getTime());

    return history;

  } catch (e) {
    Logger.log(`getChangeRequestHistory_User Error: ${e.toString()}`);
    return []; // Kembalikan array kosong jika terjadi error
  }
}

/**
 * [VERSI FINAL - DIPERBAIKI] Menandai pengajuan sebagai "Sudah Dibaca" oleh pengguna.
 * @param {string} requestId - ID dari pengajuan yang akan ditandai.
 * @param {string} userEmailFromClient - Email pengguna yang sedang login, dikirim dari frontend.
 * @returns {object} Hasil operasi.
 */
function markRequestAsRead_User(requestId, userEmailFromClient) {
  try {
    // Validasi: Pastikan email dari frontend tidak kosong
    if (!userEmailFromClient) {
      throw new Error("Email pengguna tidak disertakan dalam permintaan.");
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!sheet || sheet.getLastRow() < 2) {
      return { status: 'error', message: 'Sheet pengajuan tidak ditemukan.' };
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 11).getValues();
    
    // Logika pencarian yang diperbaiki: Membandingkan dengan email yang dikirim dari klien
    const requestIndex = data.findIndex(row => 
      row[0] === requestId && row[1].toLowerCase() === userEmailFromClient.toLowerCase()
    );

    if (requestIndex !== -1) {
      const rowToUpdate = requestIndex + 2;
      // Kolom K adalah kolom ke-11
      sheet.getRange(rowToUpdate, 11).setValue('Sudah Dibaca');
      return { status: 'success', message: 'Berhasil ditandai sebagai sudah dibaca.' };
    }
    
    // Jika tidak ditemukan, log untuk debugging
    Logger.log(`Gagal menandai dibaca. RequestId: ${requestId}. Email dari Klien: ${userEmailFromClient}. Tidak ada baris yang cocok.`);
    return { status: 'error', message: 'Pengajuan tidak ditemukan atau bukan milik Anda.' };

  } catch (e) {
    Logger.log(`markRequestAsRead_User Error: ${e.stack}`);
    return { status: 'error', message: `Gagal menandai pengajuan: ${e.message}` };
  }
}

// =================================================================
// FUNGSI BACKUP & RESTORE (SISTEM KODE UNIK)
// =================================================================

/**
 * [BARU] Mencari atau membuat folder backup yang spesifik untuk pengguna di dalam folder induk spreadsheet mereka.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @returns {DriveApp.Folder} Objek folder backup.
 */
function getOrCreateUserBackupFolder(spreadsheetId) {
  try {
    const userSpreadsheetFile = DriveApp.getFileById(spreadsheetId);
    // Asumsi spreadsheet pengguna berada di dalam satu folder induk
    const parentFolder = userSpreadsheetFile.getParents().next(); 
    
    // Nama folder backup yang lebih rapi
    const backupFolderName = `_Backup Aplikasi Ijazah`; 
    let backupFolderIterator = parentFolder.getFoldersByName(backupFolderName);

    if (backupFolderIterator.hasNext()) {
      return backupFolderIterator.next();
    } else {
      return parentFolder.createFolder(backupFolderName);
    }
  } catch (e) {
    // Jika gagal mendapatkan folder induk, buat di root Drive pengguna sebagai fallback
    Logger.log(`Tidak dapat menemukan folder induk untuk SS ID: ${spreadsheetId}. Membuat folder backup di Root Drive. Error: ${e.message}`);
    const rootFolder = DriveApp.getRootFolder();
    const fallbackFolderName = `BACKUP APLIKASI IJAZAH (ID: ${spreadsheetId.slice(0,8)})`;
    let fallbackFolderIterator = rootFolder.getFoldersByName(fallbackFolderName);
     if (fallbackFolderIterator.hasNext()) {
      return fallbackFolderIterator.next();
    } else {
      return rootFolder.createFolder(fallbackFolderName);
    }
  }
}

/**
 * [BARU] Membuat backup, menghasilkan kode unik, dan mencatatnya di registry.
 * @param {string} spreadsheetId ID spreadsheet pengguna yang akan dibackup.
 * @param {string} userEmail Email pengguna yang membuat backup.
 * @returns {object} Hasil operasi berisi status, pesan, dan kode unik.
 */
function createBackupWithCode(spreadsheetId, userEmail) {
  try {
    const liveFile = DriveApp.getFileById(spreadsheetId);
    const backupFolder = getOrCreateUserBackupFolder(spreadsheetId);
    
    const now = new Date();
    const timestamp = Utilities.formatDate(now, Session.getScriptTimeZone(), "yyyy-MM-dd_HH-mm");
    const schoolData = getSchoolData(spreadsheetId); // Menggunakan fungsi yang ada untuk mendapatkan nama sekolah
    const schoolName = schoolData ? schoolData.namaSekolah : "Unknown_School";

    // 1. Buat file backup
    const backupFileName = `[${timestamp}] Backup - ${schoolName}`;
    const backupFile = liveFile.makeCopy(backupFileName, backupFolder);
    const backupFileId = backupFile.getId();

    // 2. Buat kode restore yang unik dan mudah dibaca
    const uniqueCode = Utilities.getUuid().substring(0, 4).toUpperCase() + '-' + Utilities.getUuid().substring(9, 13).toUpperCase();

    // 3. Simpan catatan di Spreadsheet Induk
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    let registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);

    // Buat sheet jika belum ada
    if (!registrySheet) {
      registrySheet = masterSs.insertSheet(SHEET_BACKUP_REGISTRY);
      const headers = ['Kode Restore', 'ID File Backup', 'Dibuat Oleh (Email)', 'Tanggal Dibuat', 'Nama Sekolah', 'Nama File'];
      registrySheet.appendRow(headers);
      registrySheet.getRange("A1:F1").setFontWeight("bold");
      registrySheet.setFrozenRows(1);
    }

    // Tambahkan data backup baru
    registrySheet.appendRow([uniqueCode, backupFileId, userEmail, now, schoolName, backupFileName]);
    
    return { 
      status: "success", 
      message: `Backup berhasil dibuat. Kode restore Anda adalah: ${uniqueCode}`,
      code: uniqueCode,
      backupName: backupFileName
    };

  } catch (e) {
    Logger.log(`createBackupWithCode Error: ${e.stack}`);
    return { status: "error", message: `Gagal membuat backup: ${e.message}` };
  }
}

/**
 * [VERSI FINAL - DIPERBAIKI] Mengambil daftar semua backup yang dibuat oleh pengguna tertentu.
 * Memastikan data tanggal diubah menjadi string sebelum dikirim ke frontend.
 * @param {string} userEmail Email pengguna yang sedang login.
 * @returns {object} Hasil operasi berisi daftar file backup.
 */
function getBackupListForUser(userEmail) {
  try {
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);

    if (!registrySheet || registrySheet.getLastRow() < 2) {
      return { status: "success", backups: [] };
    }

    const data = registrySheet.getDataRange().getValues();
    const headers = data.shift();
    const emailIndex = headers.indexOf('Dibuat Oleh (Email)');

    // Pengecekan header untuk menghindari error
    if (emailIndex === -1) {
      throw new Error("Kolom 'Dibuat Oleh (Email)' tidak ditemukan di sheet 'Data Backup Terdaftar'.");
    }
    
    const userBackups = data
      .filter(row => row[emailIndex] && row[emailIndex].toLowerCase() === userEmail.toLowerCase())
      .map(row => {
        const tglDibuat = row[headers.indexOf('Tanggal Dibuat')];

        return {
          code: row[headers.indexOf('Kode Restore')],
          id: row[headers.indexOf('ID File Backup')],
          //  PERBAIKAN UTAMA ADA DI SINI 
          // Mengubah objek Date menjadi string ISO, yang aman untuk dikirim ke frontend.
          date: tglDibuat instanceof Date ? tglDibuat.toISOString() : tglDibuat,
          //  AKHIR PERBAIKAN 
          name: row[headers.indexOf('Nama File')] || `Backup dari tanggal tidak diketahui`
        };
      })
      .sort((a, b) => new Date(b.date) - new Date(a.date));

    return { status: "success", backups: userBackups };

  } catch (e) {
    Logger.log(`getBackupListForUser Error: ${e.stack}`);
    return { status: "error", message: `Gagal mengambil daftar backup: ${e.message}` };
  }
}

/**
 * [BARU] Memulihkan data dari backup menggunakan kode unik, dengan validasi kepemilikan.
 * Ini memicu proses di latar belakang.
 * @param {string} liveSpreadsheetId ID spreadsheet yang akan ditimpa.
 * @param {string} uniqueCode Kode restore yang dimasukkan pengguna.
 * @param {string} userEmail Email pengguna yang meminta restore (untuk verifikasi).
 */
function restoreFromCode(liveSpreadsheetId, uniqueCode, userEmail) {
  const cache = CacheService.getScriptCache();
  const statusKey = `restore_status_${userEmail}_${liveSpreadsheetId}`;

  // Segera set status 'running' di cache
  cache.put(statusKey, 'running', 21600); // Simpan status selama 6 jam

  try {
    if (!uniqueCode || !userEmail) {
      throw new Error("Kode restore dan email pengguna wajib diisi.");
    }
    
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    // 1. Cari kode di Spreadsheet Induk
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);
    if (!registrySheet) {
      throw new Error("Sistem registry backup tidak ditemukan. Hubungi Superadmin.");
    }

    const data = registrySheet.getRange(2, 1, registrySheet.getLastRow() - 1, 4).getValues();
    let backupFileId = null;
    let found = false;

    for (let i = 0; i < data.length; i++) {
      // Bandingkan kode (kolom 0) dan email (kolom 2)
      if (data[i][0].toString().toUpperCase() === uniqueCode.toUpperCase()) {
        if (data[i][2].toLowerCase() === userEmail.toLowerCase()) {
          backupFileId = data[i][1];
          found = true;
          break;
        } else {
          // Kode ditemukan, tapi bukan milik pengguna ini
          throw new Error("Akses ditolak. Kode restore ini milik pengguna lain.");
        }
      }
    }
    
    lock.releaseLock();
    
    if (!found) {
      throw new Error(`Kode restore '${uniqueCode}' tidak valid atau tidak ditemukan.`);
    }

    // 2. Jalankan proses restore inti
    const liveSs = SpreadsheetApp.openById(liveSpreadsheetId);
    const backupSs = SpreadsheetApp.openById(backupFileId);

    performSheetCopyRestore(backupSs, liveSs); // Panggil helper function

    // 3. Set status 'complete' di cache jika berhasil
    cache.put(statusKey, 'complete', 300); // Simpan status selesai selama 5 menit

  } catch (e) {
    Logger.log(`restoreFromCode Error: ${e.stack}`);
    // Jika ada error, simpan pesan error di cache
    cache.put(statusKey, `error: ${e.message}`, 300);
  }
}

/**
 * [BARU] Helper untuk memeriksa status proses restore yang berjalan di latar belakang.
 * @param {string} liveSpreadsheetId ID spreadsheet yang sedang direstore.
 * @param {string} userEmail Email pengguna yang meminta.
 * @returns {string|null} Status saat ini: 'running', 'complete', 'error: ...', atau null.
 */
function getRestoreStatusForUser(liveSpreadsheetId, userEmail) {
  const cache = CacheService.getScriptCache();
  const statusKey = `restore_status_${userEmail}_${liveSpreadsheetId}`;
  return cache.get(statusKey);
}

/**
 * [BARU] Menghapus file backup dan catatannya di registry, dengan validasi kepemilikan.
 * @param {string} backupFileId ID file backup yang akan dihapus.
 * @param {string} userEmail Email pengguna yang meminta penghapusan.
 * @returns {object} Hasil operasi.
 */
function deleteBackupForUser(backupFileId, userEmail) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  
  try {
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);
    if (!registrySheet) {
      throw new Error("Sistem registry backup tidak ditemukan.");
    }

    const data = registrySheet.getRange(1, 1, registrySheet.getLastRow(), registrySheet.getLastColumn()).getValues();
    const headers = data[0];
    const idIndex = headers.indexOf('ID File Backup');
    const emailIndex = headers.indexOf('Dibuat Oleh (Email)');
    
    let rowIndexToDelete = -1;

    // Cari dari baris ke-2 (indeks 1)
    for (let i = 1; i < data.length; i++) {
      if (data[i][idIndex] === backupFileId) {
        if (data[i][emailIndex].toLowerCase() === userEmail.toLowerCase()) {
          rowIndexToDelete = i + 1; // Nomor baris di spreadsheet
          break;
        } else {
          throw new Error("Akses ditolak. Anda tidak memiliki izin untuk menghapus backup ini.");
        }
      }
    }

    if (rowIndexToDelete !== -1) {
      // Hapus file di Google Drive
      DriveApp.getFileById(backupFileId).setTrashed(true);
      // Hapus baris di registry
      registrySheet.deleteRow(rowIndexToDelete);
      
      lock.releaseLock();
      return { status: 'success', message: 'File backup dan catatannya berhasil dihapus.' };
    } else {
      lock.releaseLock();
      return { status: 'error', message: 'Backup tidak ditemukan atau Anda tidak memiliki izin.' };
    }

  } catch (e) {
    lock.releaseLock();
    Logger.log(`deleteBackupForUser Error: ${e.stack}`);
    return { status: 'error', message: `Gagal menghapus backup: ${e.message}` };
  }
}

/**
 * [HELPER - TIDAK DIUBAH] Fungsi inti untuk menyalin semua sheet dari sumber ke target.
 * @param {SpreadsheetApp.Spreadsheet} sourceSs Objek Spreadsheet sumber.
 * @param {SpreadsheetApp.Spreadsheet} targetSs Objek Spreadsheet tujuan.
 */
function performSheetCopyRestore(sourceSs, targetSs) {
  const placeholderName = '__placeholder__' + new Date().getTime();
  const placeholderSheet = targetSs.insertSheet(placeholderName);
  
  const originalTargetSheets = targetSs.getSheets().filter(s => s.getName() !== placeholderName);
  
  originalTargetSheets.forEach(sheet => {
    try {
      targetSs.deleteSheet(sheet);
    } catch (e) {
      Logger.log(`Gagal menghapus sheet lama: ${sheet.getName()}. Error: ${e.message}`);
    }
  });
  
  const sourceSheets = sourceSs.getSheets();
  sourceSheets.forEach(sourceSheet => {
    const sourceName = sourceSheet.getName();
    sourceSheet.copyTo(targetSs).setName(sourceName);
  });
  
  targetSs.deleteSheet(placeholderSheet);
  
  try {
    const allSheets = targetSs.getSheets();
    if (allSheets.length > 0) {
      targetSs.setActiveSheet(allSheets[0]);
    }
  } catch (e) { 
    Logger.log('Gagal mengaktifkan sheet pertama setelah restore.');
  }
}


/**
 * [BARU] Mencatat setiap aktivitas login ke sheet 'Log Aktivitas'.
 * Fungsi ini akan otomatis membuat sheet jika belum ada.
 * @param {string} email - Email pengguna yang login.
 * @param {string} namaSekolah - Nama sekolah pengguna.
 * @param {string} jenjang - Jenjang sekolah pengguna.
 * @param {string} role - Role pengguna.
 */
function logLoginActivity(email, namaSekolah, jenjang, role) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let logSheet = ss.getSheetByName(SHEET_LOG);

    // Jika sheet 'Log Aktivitas' tidak ditemukan, buat baru beserta header.
    if (!logSheet) {
      logSheet = ss.insertSheet(SHEET_LOG, 0); // Buat sebagai sheet pertama
      const headers = [['Timestamp', 'Email', 'Nama Sekolah', 'Jenjang', 'Role']];
      logSheet.getRange(1, 1, 1, 5).setValues(headers).setFontWeight('bold');
      logSheet.setFrozenRows(1); // Bekukan baris header
    }

    // Tambahkan baris baru untuk setiap aktivitas login
    logSheet.appendRow([new Date(), email, namaSekolah, jenjang, role]);
  } catch (e) {
    // Catat error jika gagal logging, tapi jangan hentikan proses login
    Logger.log(`Gagal mencatat log aktivitas untuk email ${email}: ${e.message}`);
  }
}

/**
 * [VERSI FINAL] Mengambil seluruh riwayat versi dari sheet 'Versi Aplikasi'.
 * Memanggil helper untuk memastikan format tanggal dalam Bahasa Indonesia.
 * @returns {Array} Array berisi objek untuk setiap versi.
 */
function getAllVersionChangelogs() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_VERSI);

    if (!sheet) {
      Logger.log("Sheet 'Versi Aplikasi' tidak ditemukan.");
      return [];
    }

    const data = sheet.getDataRange().getValues();

    if (data.length < 2) {
      return [];
    }

    const allVersions = [];
    const headers = data[0];
    const versionIndex = headers.indexOf("Versi");
    const dateIndex = headers.indexOf("Tanggal Rilis");
    const changelogIndex = headers.indexOf("Catatan Perubahan (pisahkan dengan baris baru)");

    if(versionIndex === -1 || dateIndex === -1 || changelogIndex === -1) {
        throw new Error("Satu atau lebih nama header ('Versi', 'Tanggal Rilis', 'Catatan Perubahan (pisahkan dengan baris baru)') tidak ditemukan di sheet 'Versi Aplikasi'.");
    }

    const spreadsheetTimezone = ss.getSpreadsheetTimeZone();

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const version = row[versionIndex];

      if (!version) {
        continue;
      }

      const releaseDate = row[dateIndex];

      allVersions.push({
        version: version.toString().trim(),

        //  PERUBAHAN UTAMA ADA DI SINI 
        // Memanggil fungsi helper baru kita untuk format tanggal
        releaseDate: releaseDate instanceof Date ? formatDateToIndonesian(releaseDate, spreadsheetTimezone) : releaseDate.toString(),
        //  AKHIR DARI PERUBAHAN 

        changelog: row[changelogIndex].toString().split('\n').map(line => line.trim()).filter(line => line)
      });
    }

    return allVersions;

  } catch (e) {
    Logger.log("Error di getAllVersionChangelogs: " + e.message);
    throw new Error("Gagal mengambil data changelog dari server. " + e.message); 
  }
}

/**
 * [BARU] Helper untuk memformat tanggal ke Bahasa Indonesia dengan benar.
 * Menerjemahkan nama bulan dari output default Apps Script.
 * @param {Date} dateObj Objek tanggal yang akan diformat.
 * @param {string} timezone Zona waktu dari spreadsheet.
 * @return {string} Tanggal yang sudah diformat, cth: "18 Oktober 2025".
 */
function formatDateToIndonesian(dateObj, timezone) {
  // Peta untuk menerjemahkan bulan
  const monthMap = {
    'January': 'Januari', 'February': 'Februari', 'March': 'Maret',
    'April': 'April', 'May': 'Mei', 'June': 'Juni',
    'July': 'Juli', 'August': 'Agustus', 'September': 'September',
    'October': 'Oktober', 'November': 'November', 'December': 'Desember'
  };

  // Format tanggal ke dalam Bahasa Inggris terlebih dahulu
  let formattedDate = Utilities.formatDate(dateObj, timezone, "dd MMMM yyyy");

  // Ganti nama bulan Inggris dengan nama bulan Indonesia
  for (const [english, indonesian] of Object.entries(monthMap)) {
    formattedDate = formattedDate.replace(english, indonesian);
  }

  return formattedDate;
}

/**
 * [ADMIN] Mengambil semua data versi untuk ditampilkan di panel kelola update.
 * @returns {Array<object>} Array berisi semua data versi.
 */
function getVersionsForAdmin() {
  //  GERBANG KEAMANAN YANG BENAR 
  const adminEmail = Session.getActiveUser().getEmail();
  if (!isSuperadmin(adminEmail)) {
    // Gunakan throw Error agar bisa ditangkap oleh withFailureHandler di frontend
    throw new Error("Akses ditolak.");
  }
  //  AKHIR DARI GERBANG KEAMANAN 

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_VERSI);
    if (!sheet || sheet.getLastRow() < 2) {
      return [];
    }
    
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 3).getValues();
    
    return data.map((row, index) => {
      const releaseDate = row[1];
      return {
        row: index + 2,
        version: row[0],
        releaseDate: releaseDate instanceof Date ? Utilities.formatDate(releaseDate, ss.getSpreadsheetTimeZone(), "yyyy-MM-dd") : releaseDate,
        changelog: row[2]
      };
    }).sort((a, b) => a.row - b.row);

  } catch (e) {
    Logger.log("getVersionsForAdmin Error: " + e.message);
    throw new Error("Gagal mengambil data versi dari server.");
  }
}

/**
 * [ADMIN - DIPERBAIKI] Menambahkan data versi baru ke baris kedua (setelah header)
 * dan memastikan format kolom Versi adalah Teks.
 * @param {object} versionData Objek berisi data versi baru {version, releaseDate, changelog}.
 * @returns {object} Objek status.
 */
function addVersion(versionData) {
    const adminEmail = Session.getActiveUser().getEmail();
    if (!isSuperadmin(adminEmail)) {
        return { status: "error", message: "Akses ditolak." };
    }

    try {
        const { version, releaseDate, changelog } = versionData;
        if (!version || !releaseDate || !changelog) {
            throw new Error("Semua field wajib diisi.");
        }
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sheet = ss.getSheetByName(SHEET_VERSI);

        // --- [PERBAIKAN DIMULAI DI SINI] ---

        // 1. Sisipkan baris baru di bawah header (setelah baris 1)
        sheet.insertRowAfter(1);

        // 2. Ambil range untuk baris baru tersebut (yaitu baris ke-2)
        const newRowRange = sheet.getRange("A2:C2");
        
        // 3. Paksa format kolom A di baris baru itu menjadi Plain Text ('@')
        sheet.getRange("A2").setNumberFormat('@');
        
        // 4. Masukkan data ke baris baru tersebut
        newRowRange.setValues([[version, new Date(releaseDate), changelog]]);
        
        // --- [PERBAIKAN SELESAI] ---

        return { status: "success", message: `Versi ${version} berhasil ditambahkan.` };
    } catch (e) {
        return { status: "error", message: `Gagal menambahkan versi: ${e.message}` };
    }
}

/**
 * [ADMIN] Memperbarui data versi yang sudah ada.
 * @param {object} versionData Objek berisi data versi, termasuk nomor baris {row, version, releaseDate, changelog}.
 * @returns {object} Objek status.
 */
function updateVersion(versionData) {
  const adminEmail = Session.getActiveUser().getEmail();
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }

  try {
    const { row, version, releaseDate, changelog } = versionData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_VERSI);
    // Update 1 baris, 3 kolom (A, B, C)
    sheet.getRange(row, 1, 1, 3).setValues([[version, new Date(releaseDate), changelog]]);
    return { status: "success", message: `Versi ${version} berhasil diperbarui.` };
  } catch (e) {
    return { status: "error", message: `Gagal memperbarui versi: ${e.message}` };
  }
}

/**
 * [ADMIN] Menghapus data versi dari sheet.
 * @param {number} rowNumber Nomor baris yang akan dihapus.
 * @returns {object} Objek status.
 */
function deleteVersion(rowNumber) {
  const adminEmail = Session.getActiveUser().getEmail();
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_VERSI);
    sheet.deleteRow(rowNumber);
    return { status: "success", message: "Data versi berhasil dihapus." };
  } catch (e) {
    return { status: "error", message: `Gagal menghapus versi: ${e.message}` };
  }
}

/**
 * FUNGSI UNTUK DIAGNOSA (VERSI FINAL)
 * Mengirimkan hasil diagnosa langsung ke email pengguna yang terdeteksi.
 */
function cekStatusAdminSaya() {
  try {
    const emailAktif = Session.getActiveUser().getEmail();
    const isAdmin = isSuperadmin(emailAktif); // Memanggil fungsi pengecekan standar kita
    
    const subject = "Hasil Diagnosa Akun Superadmin - Aplikasi Ijazah";
    const message = "Halo,\n\n" +
                  "Anda telah menjalankan fungsi diagnosa dari aplikasi Anda. Berikut adalah hasilnya:\n\n" +
                  "=========================================================\n" +
                  "1. Email yang terdeteksi oleh Google saat ini: " + emailAktif + "\n\n" +
                  "2. Apakah email ini terdaftar sebagai Superadmin di sheet 'Data Pengguna'? " + (isAdmin ? 'YA, Benar.' : 'TIDAK, Salah.') + "\n" +
                  "=========================================================\n\n" +
                  "TINDAK LANJUT:\n" +
                  "- Jika statusnya 'TIDAK', mohon periksa kembali sheet 'Data Pengguna' di Spreadsheet Induk.\n" +
                  "- Pastikan email di atas tertulis dengan benar dan di kolom 'Role' tertulis persis 'Superadmin' (tanpa salah ketik atau spasi tambahan).\n" +
                  "- Jika email yang terdeteksi bukan email yang Anda harapkan, coba gunakan browser dalam mode Incognito/Private.";

    // Kirim hasil ke email pengguna yang terdeteksi
    MailApp.sendEmail(emailAktif, subject, message);
    
    // Juga catat di log untuk backup
    Logger.log(message);
    
    // Beri tahu pengguna di editor bahwa email telah dikirim
    Browser.msgBox("Diagnosa Selesai", "Hasil diagnosa telah dikirim ke email Anda di: " + emailAktif + ". Silakan periksa kotak masuk (dan folder spam) Anda.", Browser.Buttons.OK);

  } catch (e) {
    Browser.msgBox("Error Saat Diagnosa", "Gagal menjalankan diagnosa: " + e.message, Browser.Buttons.OK);
  }
}

/**
 * [BARU] Mengambil daftar mata pelajaran default berdasarkan jenjang sekolah pengguna.
 * Fungsi ini HANYA mengambil daftar, tidak melakukan impor.
 * @param {string} spreadsheetId ID spreadsheet pengguna untuk menentukan jenjang.
 * @returns {Array<object>} Array objek data mata pelajaran default.
 */
function getDefaultMapelList(spreadsheetId) {
  try {
    const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang;

    if (!jenjang) {
      throw new Error('Jenjang sekolah belum diatur. Harap atur di menu Data Sekolah.');
    }

    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const mapelDefaultSheet = masterSs.getSheetByName(SHEET_MAPEL_DEFAULT);
    if (!mapelDefaultSheet) {
      throw new Error(`Sheet '${SHEET_MAPEL_DEFAULT}' tidak ditemukan di spreadsheet master.`);
    }

    const defaultMapelData = mapelDefaultSheet.getDataRange().getValues();
    defaultMapelData.shift(); // Hapus header

    const mapelForJenjang = defaultMapelData
      .filter(row => row[0] === jenjang) // Filter berdasarkan jenjang
      .map(row => ({ // Ubah menjadi objek agar lebih mudah di frontend
        kode: row[1], 
        nama: row[2], 
        kelompok: row[3], 
        jenisUjian: row[4]
      }));

    if (mapelForJenjang.length === 0) {
      // Tidak melempar error, tapi kirim array kosong agar frontend bisa menangani
      return []; 
    }
    
    return mapelForJenjang;

  } catch (e) {
    Logger.log(e);
    // Lempar error agar bisa ditangkap oleh .withFailureHandler di frontend
    throw new Error("Gagal mengambil daftar mapel default: " + e.message);
  }
}

/**
 * [PERBAIKAN SANGAT PENTING] Mengimpor mapel pilihan PENGGUNA.
 * Setelah selesai, fungsi ini akan membaca ulang dan mengembalikan daftar mapel terbaru
 * untuk menghilangkan delay dan memastikan data selalu sinkron.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} selectedMapelArray Array berisi objek mapel yang dipilih pengguna.
 * @returns {object} Hasil proses impor, TERMASUK daftar mapel yang sudah diupdate.
 */
function importSelectedMapel(spreadsheetId, selectedMapelArray) {
  if (!selectedMapelArray || selectedMapelArray.length === 0) {
    return { status: "info", message: "Tidak ada mata pelajaran yang dipilih untuk diimpor." };
  }

  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);

    const existingMapelMap = new Map();
    if (sheet.getLastRow() >= 2) { 
      const existingDataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4);
      const existingValues = existingDataRange.getValues();
      existingValues.forEach((row, index) => {
        const kode = row[0].toString().trim();
        if (kode) {
          existingMapelMap.set(kode, index + 2);
        }
      });
    }

    const rowsToAppend = [];
    let updatedCount = 0;
    let newCount = 0;

    selectedMapelArray.forEach(mapel => {
      const dataToInsert = [mapel.kode, mapel.nama, mapel.kelompok, mapel.jenisUjian];
      if (existingMapelMap.has(mapel.kode)) {
        const rowNumber = existingMapelMap.get(mapel.kode);
        sheet.getRange(rowNumber, 1, 1, 4).setValues([dataToInsert]);
        updatedCount++;
      } else {
        rowsToAppend.push(dataToInsert);
        newCount++;
      }
    });

    if (rowsToAppend.length > 0) {
      sheet.getRange(sheet.getLastRow() + 1, 1, rowsToAppend.length, 4).setValues(rowsToAppend);
    }
    
    // ======================================================
    // === PERUBAHAN INTI ADA DI BAWAH INI ===
    // ======================================================
    
    // 1. Paksa Google Sheet untuk menyelesaikan semua penulisan data
    SpreadsheetApp.flush(); 
    
    // 2. Baca kembali data mapel yang sudah fresh/terbaru
    const updatedMapelList = getMapel(spreadsheetId);

    // 3. Kirim kembali pesan, status, DAN data yang baru ke frontend
    return { 
      status: "success", 
      message: `Impor Selesai. ${newCount} mapel baru ditambahkan dan ${updatedCount} mapel diperbarui.`,
      updatedMapelList: updatedMapelList // <-- Data baru disertakan di sini
    };

  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengimpor mapel: " + e.message };
  }
}

// [PERUBAHAN] Ganti fungsi saveMapelOrder dengan yang ini di Kode.gs.html
/**
 * [BARU] Menyimpan urutan baru dari daftar mata pelajaran.
 * Fungsi ini akan menghapus semua mapel yang ada dan menulisnya kembali
 * sesuai dengan urutan yang diberikan dari frontend.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} orderedMapelArray Array objek mapel yang sudah diurutkan.
 * @returns {object} Status penyimpanan dan daftar mapel yang sudah diupdate.
 */
function saveMapelOrder(spreadsheetId, orderedMapelArray) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);

    // Hapus data lama terlebih dahulu (dari baris 2 ke bawah)
    if (sheet.getLastRow() >= 2) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }

    // Jika ada data baru untuk ditulis
    if (orderedMapelArray && orderedMapelArray.length > 0) {
      // Ubah array of objects menjadi array 2D untuk ditulis ke sheet
      const newValues = orderedMapelArray.map(m => [m.kode, m.nama, m.kelompok, m.jenisUjian]);
      // Tulis semua data baru dalam satu operasi
      sheet.getRange(2, 1, newValues.length, newValues[0].length).setValues(newValues);
    }
    
    SpreadsheetApp.flush(); // Pastikan perubahan segera diterapkan

    // Ambil kembali data yang sudah terupdate untuk dikirim ke frontend
    const updatedMapelList = getMapel(spreadsheetId);

    return { 
        status: "success", 
        message: "Urutan mata pelajaran berhasil disimpan.",
        updatedMapelList: updatedMapelList // Kirim data terbaru
    };

  } catch (e) {
    Logger.log("saveMapelOrder Error: " + e.message);
    return { status: "error", message: "Gagal menyimpan urutan baru: " + e.message };
  }
}

/**
 * [FINAL & DENGAN PROPERTIES SERVICE] Menghitung ulang semua statistik Superadmin
 * dan menyimpannya ke sheet cache DAN PropertiesService.
 */
function updateSuperadminDashboardCache() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let cacheSheet = ss.getSheetByName(SHEET_DASHBOARD_CACHE);

  if (!cacheSheet) {
    cacheSheet = ss.insertSheet(SHEET_DASHBOARD_CACHE);
  }
  cacheSheet.clearContents().appendRow(['Metric', 'Value']);
  cacheSheet.getRange("B:B").setNumberFormat('@');

  const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
  
  // 1. Hitung Statistik Akun & Siswa (Logika ini tidak berubah)
  let totalAccounts = 0, activeAccounts = 0, totalStudents = 0, inactiveAccounts = 0;
  if (userSheet && userSheet.getLastRow() >= 2) {
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 8).getValues();
    const validUsers = usersData.filter(u => u[1]); // Filter baris yang punya email
    totalAccounts = validUsers.length;
    
    validUsers.forEach(userRow => {
      if (userRow[7] === 'Aktif') activeAccounts++;
      
      const role = userRow[6];
      const spreadsheetId = userRow[5];
      if (role !== 'Superadmin' && spreadsheetId) {
        try {
          const studentSheet = SpreadsheetApp.openById(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
          if (studentSheet && studentSheet.getLastRow() > 1) {
            totalStudents += studentSheet.getLastRow() - 1;
          }
        } catch (e) {
          Logger.log(`[Cache] Gagal akses spreadsheet ID ${spreadsheetId}. Error: ${e.message}`);
        }
      }
    });
    inactiveAccounts = totalAccounts - activeAccounts;
  }

  // 2. Hitung Statistik Pengajuan (Logika ini tidak berubah)
  let totalRequests = 0, pendingRequests = 0, approvedRequests = 0, rejectedRequests = 0;
  try {
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (pengajuanSheet && pengajuanSheet.getLastRow() >= 2) {
      const statusColumn = pengajuanSheet.getRange(2, 8, pengajuanSheet.getLastRow() - 1, 1).getValues();
      totalRequests = statusColumn.length;
      pendingRequests = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
      approvedRequests = statusColumn.filter(row => row[0] === 'Disetujui').length;
      rejectedRequests = statusColumn.filter(row => row[0] === 'Ditolak').length;
    }
  } catch(e) {
     Logger.log("updateSuperadminDashboardCache Error saat mengambil data pengajuan: " + e.message);
  }

  // 3. Siapkan data untuk ditulis ke cache sheet (Logika ini tidak berubah)
  const cacheDataForSheet = [
    ['totalAccounts', totalAccounts], ['activeAccounts', activeAccounts],
    ['inactiveAccounts', inactiveAccounts], ['totalStudents', totalStudents],
    ['totalRequests', totalRequests], ['pendingRequests', pendingRequests],
    ['approvedRequests', approvedRequests], ['rejectedRequests', rejectedRequests],
    ['lastUpdated', new Date().toISOString()]
  ];
  cacheSheet.getRange(2, 1, cacheDataForSheet.length, 2).setValues(cacheDataForSheet);

  // ===== PERUBAHAN UTAMA: SIMPAN KE PROPERTIES SERVICE =====
  // 4. Buat objek JavaScript dari statistik yang sudah dihitung
  const statsObject = {
      totalAccounts, activeAccounts, inactiveAccounts, totalStudents,
      totalRequests, pendingRequests, approvedRequests, rejectedRequests,
      lastUpdated: new Date().toISOString()
  };

  // 5. Simpan objek tersebut sebagai string JSON di PropertiesService
  try {
    const scriptProperties = PropertiesService.getScriptProperties();
    scriptProperties.setProperty('superadminDashboardCache', JSON.stringify(statsObject));
    Logger.log('Cache Dashboard Superadmin berhasil disimpan ke PropertiesService.');
  } catch (e) {
    Logger.log('Gagal menyimpan cache ke PropertiesService: ' + e.message);
  }
  // ===== AKHIR PERUBAHAN =====
}

/**
 * [SUPERADMIN - BARU] Memulihkan data dari file backup menggunakan kode unik ke spreadsheet target.
 * Berbeda dari restore pengguna biasa, fungsi ini tidak memeriksa kepemilikan email.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {string} uniqueCode Kode restore unik dari sheet 'Data Backup Terdaftar'.
 * @param {string} targetSpreadsheetId ID spreadsheet pengguna yang akan ditimpa datanya.
 * @returns {object} Objek berisi status dan pesan.
 */
function adminRestoreFromCode_Superadmin(adminEmail, uniqueCode, targetSpreadsheetId) {
  // 1. Verifikasi bahwa yang menjalankan adalah Superadmin
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak. Hanya Superadmin." };
  }

  if (!uniqueCode || !targetSpreadsheetId) {
    return { status: "error", message: "Kode Unik dan ID Spreadsheet Tujuan wajib diisi." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    // 2. Cari kode di Spreadsheet Induk untuk mendapatkan ID file backup
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);
    if (!registrySheet) {
      throw new Error("Sistem registry backup tidak ditemukan.");
    }

    const data = registrySheet.getRange(2, 1, registrySheet.getLastRow() - 1, 2).getValues(); // Ambil kolom Kode dan ID File
    let backupFileId = null;

    for (let i = 0; i < data.length; i++) {
      if (data[i][0].toString().toUpperCase() === uniqueCode.toUpperCase()) {
        backupFileId = data[i][1];
        break;
      }
    }
    
    if (!backupFileId) {
      throw new Error(`Kode restore '${uniqueCode}' tidak valid atau tidak ditemukan.`);
    }

    // 3. Lakukan proses restore inti
    const backupSs = SpreadsheetApp.openById(backupFileId);
    const targetSs = SpreadsheetApp.openById(targetSpreadsheetId);

    performSheetCopyRestore(backupSs, targetSs); // Memanggil helper function yang sudah ada

    lock.releaseLock();
    return { status: "success", message: `Data berhasil dipulihkan dari kode ${uniqueCode} ke spreadsheet tujuan.` };

  } catch (e) {
    lock.releaseLock();
    Logger.log(`adminRestoreFromCode Error: ${e.stack}`);
    return { status: "error", message: `Gagal memulihkan data: ${e.message}` };
  }
}

// ===== [BARU] FUNGSI UNTUK VALIDASI KELENGKAPAN NILAI =====

/**
 * Memvalidasi kelengkapan semua nilai (ujian dan rapor) untuk setiap siswa.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi hasil validasi atau pesan error.
 */
function validateAllScores(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    
    // 1. Ambil data-data dasar yang diperlukan
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) {
      return { status: 'error', message: 'Tidak ada data siswa untuk divalidasi.' };
    }

    const mapel = getMapel(spreadsheetId);
    if (!mapel || mapel.length === 0) {
      return { status: 'error', message: 'Tidak ada data mata pelajaran untuk divalidasi.' };
    }
    
    const schoolData = getSchoolData(spreadsheetId);
    const jenjang = schoolData ? schoolData.jenjang : null;
    if (!jenjang) {
      return { status: 'error', message: 'Jenjang sekolah belum diatur di menu Data Sekolah.' };
    }

    // 2. Tentukan semua nama sheet yang akan diperiksa berdasarkan jenjang
    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    
    const semestersForJenjang = semesterKeys[jenjang] || [];
    
    const sheetNamesToCheck = [
      SHEET_NILAI_UJIAN_MADRASAH,
      SHEET_NILAI_UJIAN_PRAKTEK,
      ...semestersForJenjang.flatMap(smKey => [`Rapor_Pengetahuan_${smKey}`, `Rapor_Keterampilan_${smKey}`])
    ];

    // 3. Ambil semua data nilai dari semua sheet yang relevan
    const allScoreData = {};
    sheetNamesToCheck.forEach(sheetName => {
      // Menggunakan getSheetByName untuk memastikan sheet ada sebelum dibaca
      if (ss.getSheetByName(sheetName)) {
        allScoreData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName);
      } else {
        allScoreData[sheetName] = {}; // Jika sheet tidak ada, anggap datanya kosong
      }
    });

    // 4. Proses validasi untuk setiap siswa
    const validationResults = students.map(student => {
      const nisn = student.nisn;
      const studentStatus = {
        nisn: nisn,
        nama: student.nama,
        kelas: student.kelas,
        completeness: {}
      };
      
      let totalMissingCount = 0;

      sheetNamesToCheck.forEach(sheetName => {
        const studentScoresOnSheet = allScoreData[sheetName][nisn] || {};
        let isComplete = true; // Asumsikan lengkap pada awalnya

        // Tentukan mapel mana yang harus ada di sheet ini
        let requiredMapel;
        if (sheetName === SHEET_NILAI_UJIAN_MADRASAH) {
          requiredMapel = mapel.filter(m => m.jenisUjian === 'Ujian Madrasah' || m.jenisUjian === 'Keduanya');
        } else if (sheetName === SHEET_NILAI_UJIAN_PRAKTEK) {
          requiredMapel = mapel.filter(m => m.jenisUjian === 'Ujian Praktek' || m.jenisUjian === 'Keduanya');
        } else { // Untuk semua sheet rapor
          requiredMapel = mapel;
        }

        // Jika tidak ada mapel yang disyaratkan untuk sheet ini, anggap lengkap
        if (requiredMapel.length === 0) {
           studentStatus.completeness[sheetName] = true;
           return; // Lanjut ke sheet berikutnya
        }
        
        // Cek setiap mapel yang disyaratkan
        for (const m of requiredMapel) {
          const score = studentScoresOnSheet[m.kode];
          if (score === undefined || score === null || String(score).trim() === '') {
            isComplete = false;
            totalMissingCount++;
            break; // Cukup temukan satu yang kosong, sheet ini tidak lengkap
          }
        }
        studentStatus.completeness[sheetName] = isComplete;
      });
      
      studentStatus.missingCount = totalMissingCount;
      return studentStatus;
    });

    return {
      status: 'success',
      data: validationResults,
      sheetHeaders: sheetNamesToCheck
    };

  } catch (e) {
    Logger.log(`Error in validateAllScores: ${e.stack}`);
    return { status: 'error', message: 'Gagal melakukan validasi: ' + e.message };
  }
}

/**
 * [DIPERBARUI] Memvalidasi kelengkapan nilai berdasarkan per-mata pelajaran untuk setiap siswa.
 * Kini juga menyertakan daftar detail nilai yang kosong.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi hasil validasi atau pesan error.
 */
function validateScoresBySubject(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);

    // 1. Ambil data-data dasar
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) {
      return { status: 'error', message: 'Tidak ada data siswa untuk divalidasi.' };
    }

    const mapelList = getMapel(spreadsheetId);
    if (!mapelList || mapelList.length === 0) {
      return { status: 'error', message: 'Tidak ada data mata pelajaran untuk divalidasi.' };
    }
    
    const schoolData = getSchoolData(spreadsheetId);
    const jenjang = schoolData ? schoolData.jenjang : null;
    if (!jenjang) {
      return { status: 'error', message: 'Jenjang sekolah belum diatur di menu Data Sekolah.' };
    }

    // Peta untuk nama yang lebih ramah pengguna
    const semesterNameMap = {
      k4_ganjil: 'Kelas 4 Ganjil', k4_genap: 'Kelas 4 Genap', k5_ganjil: 'Kelas 5 Ganjil',
      k5_genap: 'Kelas 5 Genap', k6_ganjil: 'Kelas 6 Ganjil',
      k7_ganjil: 'Kelas 7 Ganjil', k7_genap: 'Kelas 7 Genap', k8_ganjil: 'Kelas 8 Ganjil',
      k8_genap: 'Kelas 8 Genap', k9_ganjil: 'Kelas 9 Ganjil',
      k10_ganjil: 'Kelas 10 Ganjil', k10_genap: 'Kelas 10 Genap', k11_ganjil: 'Kelas 11 Ganjil',
      k11_genap: 'Kelas 11 Genap', k12_ganjil: 'Kelas 12 Ganjil'
    };

    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    
    const semestersForJenjang = semesterKeys[jenjang] || [];
    const raporSheetNames = semestersForJenjang.flatMap(smKey => [`Rapor_Pengetahuan_${smKey}`, `Rapor_Keterampilan_${smKey}`]);
    const allSheetNames = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK, ...raporSheetNames];

    // Ambil semua data nilai sekali jalan
    const allScoreData = {};
    allSheetNames.forEach(sheetName => {
      if (ss.getSheetByName(sheetName)) {
        allScoreData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName);
      } else {
        allScoreData[sheetName] = {};
      }
    });

    // Proses validasi
    const validationResults = students.map(student => {
      const nisn = student.nisn;
      const studentResult = {
        nisn: nisn,
        nama: student.nama,
        kelas: student.kelas,
        subjectCompleteness: {}
      };

      mapelList.forEach(mapel => {
        let requiredCount = 0;
        let filledCount = 0;
        let missingDetails = []; // <-- [PERUBAHAN] Array untuk menyimpan detail yang kosong
        const mapelKode = mapel.kode;
        const jenisUjian = mapel.jenisUjian;

        // Cek Nilai Ujian Madrasah
        if (jenisUjian === 'Ujian Madrasah' || jenisUjian === 'Keduanya') {
          requiredCount++;
          const score = (allScoreData[SHEET_NILAI_UJIAN_MADRASAH][nisn] || {})[mapelKode];
          if (score !== undefined && score !== null && String(score).trim() !== '') {
            filledCount++;
          } else {
            missingDetails.push('Nilai Ujian Madrasah'); // <-- [PERUBAHAN] Catat jika kosong
          }
        }
        
        // Cek Nilai Ujian Praktek
        if (jenisUjian === 'Ujian Praktek' || jenisUjian === 'Keduanya') {
          requiredCount++;
          const score = (allScoreData[SHEET_NILAI_UJIAN_PRAKTEK][nisn] || {})[mapelKode];
          if (score !== undefined && score !== null && String(score).trim() !== '') {
            filledCount++;
          } else {
            missingDetails.push('Nilai Ujian Praktek'); // <-- [PERUBAHAN] Catat jika kosong
          }
        }
        
        // Cek semua nilai rapor
        semestersForJenjang.forEach(smKey => {
            // Cek Pengetahuan
            requiredCount++;
            const scoreP = (allScoreData[`Rapor_Pengetahuan_${smKey}`][nisn] || {})[mapelKode];
            if (scoreP !== undefined && scoreP !== null && String(scoreP).trim() !== '') {
                filledCount++;
            } else {
                missingDetails.push(`Rapor Pengetahuan ${semesterNameMap[smKey]}`); // <-- [PERUBAHAN] Catat jika kosong
            }

            // Cek Keterampilan
            requiredCount++;
            const scoreK = (allScoreData[`Rapor_Keterampilan_${smKey}`][nisn] || {})[mapelKode];
            if (scoreK !== undefined && scoreK !== null && String(scoreK).trim() !== '') {
                filledCount++;
            } else {
                missingDetails.push(`Rapor Keterampilan ${semesterNameMap[smKey]}`); // <-- [PERUBAHAN] Catat jika kosong
            }
        });

        studentResult.subjectCompleteness[mapelKode] = {
          complete: filledCount,
          total: requiredCount,
          missing: missingDetails // <-- [PERUBAHAN] Sertakan array detail yang kosong
        };
      });

      return studentResult;
    });

    return {
      status: 'success',
      data: validationResults,
      mapelHeaders: mapelList
    };

  } catch (e) {
    Logger.log(`Error in validateScoresBySubject: ${e.stack}`);
    return { status: 'error', message: 'Gagal melakukan validasi per mapel: ' + e.message };
  }
}

// ===== TAMBAHKAN FUNGSI BARU INI DI Kode.gs =====

/**
 * [SUPERADMIN] Mengambil data sesi pengguna target untuk impersonasi.
 * @param {string} adminEmail - Email superadmin yang meminta.
 * @param {number} targetUserRow - Nomor baris dari pengguna yang akan diimpersonasi.
 * @returns {object} Objek berisi data sesi pengguna target.
 */
function getImpersonationData_Superadmin(adminEmail, targetUserRow) {
  // Keamanan: Pastikan yang meminta adalah Superadmin
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak. Hanya Superadmin yang dapat melakukan aksi ini.");
  }

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    
    // Ambil data dari baris target (4 kolom: Email, Nama Sekolah, Spreadsheet ID, Role)
    const targetUserData = userSheet.getRange(targetUserRow, 2, 1, 6).getValues()[0];
    
    const impersonationData = {
      email: targetUserData[0],         // Kolom B
      namaSekolah: targetUserData[2],   // Kolom D
      spreadsheetId: targetUserData[4], // Kolom F
      role: targetUserData[5] || 'Pengguna' // Kolom G
    };

    if (!impersonationData.spreadsheetId) {
        throw new Error("Pengguna target tidak memiliki Spreadsheet ID yang valid.");
    }

    return { status: 'success', impersonationData: impersonationData };

  } catch (e) {
    Logger.log(`Error in getImpersonationData_Superadmin: ${e.message}`);
    return { status: 'error', message: `Gagal mendapatkan data impersonasi: ${e.message}` };
  }
}

// ===== GANTI KEMBALI KEDUA FUNGSI INI DI Kode.gs =====

/**
 * [AKSI MASSAL] Menghapus beberapa siswa berdasarkan nomor baris mereka.
 */
function bulkDeleteStudents(spreadsheetId, rowNumbers) {
  try {
    if (!rowNumbers || rowNumbers.length === 0) {
      return { status: "info", message: "Tidak ada siswa yang dipilih untuk dihapus." };
    }
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);

    rowNumbers.sort((a, b) => b - a);

    rowNumbers.forEach(rowNum => {
      sheet.deleteRow(rowNum);
    });
    
    SpreadsheetApp.flush();
    // Ambil dan kirim kembali daftar siswa yang sudah fresh
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: `${rowNumbers.length} data siswa berhasil dihapus.`,
      updatedStudentList: updatedStudentList 
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data siswa secara massal: " + e.message };
  }
}

/**
 * [AKSI MASSAL] Memperbarui kolom Tahun Lulus untuk beberapa siswa.
 */
function bulkUpdateTahunLulus(spreadsheetId, rowNumbers, tahunLulus) {
  try {
    if (!rowNumbers || rowNumbers.length === 0) {
      return { status: "info", message: "Tidak ada siswa yang dipilih." };
    }
    if (!tahunLulus || tahunLulus.toString().trim() === '') {
        return { status: "error", message: "Tahun lulus tidak boleh kosong." };
    }
      
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    const tahunLulusColumn = 11; // Kolom K

    rowNumbers.forEach(rowNum => {
      sheet.getRange(rowNum, tahunLulusColumn).setValue(tahunLulus);
    });

    SpreadsheetApp.flush();
    // Ambil dan kirim kembali daftar siswa yang sudah fresh
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: `${rowNumbers.length} data siswa berhasil diupdate tahun lurusnya.`,
      updatedStudentList: updatedStudentList
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengupdate tahun lulus secara massal: " + e.message };
  }
}

// GANTI FUNGSI generateNilaiTemplate DENGAN VERSI FINAL INI
/**
 * [FINAL v2] Menghasilkan file template Excel untuk upload nilai.
 * Menambahkan sheet '_validation_' tersembunyi yang berisi 'uploadType' untuk validasi.
 */
function generateNilaiTemplate(spreadsheetId, templateName, selectedKelas) {
  let tempFile;
  try {
    const ss = SpreadsheetApp.create(`Template_Upload_${templateName}_${new Date().getTime()}`);
    tempFile = DriveApp.getFileById(ss.getId());

    // [MODIFIKASI] Filter siswa berdasarkan kelas yang dipilih
    let students = getStudents(spreadsheetId);
    if (selectedKelas && selectedKelas !== 'semua') {
        students = students.filter(s => s.kelas === selectedKelas);
    }

    const studentData = (students || []).map(s => ["'" + s.nisn, s.nama.toUpperCase()]);

    const populateSheet = (sheet, mapel) => {
      // ... (sisa dari fungsi populateSheet tidak berubah)
      if (!mapel || mapel.length === 0) {
        sheet.appendRow(["Tidak ada mata pelajaran yang dikonfigurasi untuk jenis ini."]);
        return;
      }
      const headers = ["NISN", "Nama Lengkap", ...mapel.map(m => m.kode)];
      sheet.appendRow(headers);
      sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold").setBackground("#d9ead3");
      if (studentData.length > 0) {
        sheet.getRange(2, 1, studentData.length, 2).setValues(studentData);
      }
      sheet.getRange("A:A").setNumberFormat('@');
      sheet.setColumnWidth(1, 120);
      sheet.setColumnWidth(2, 250);
    };

    let uploadTypeIdentifier = '';

    if (templateName.startsWith('Rapor_')) {
      const sheetP = ss.getSheets()[0].setName('Pengetahuan');
      const sheetK = ss.insertSheet('Keterampilan');
      const allMapel = getMapel(spreadsheetId);
      populateSheet(sheetP, allMapel);
      populateSheet(sheetK, allMapel);
      uploadTypeIdentifier = templateName.toLowerCase(); // contoh: 'rapor_k7_ganjil'

    } else if (templateName === 'UjianGabungan') {
      const sheetUM = ss.getSheets()[0].setName('Ujian Madrasah');
      const sheetUP = ss.insertSheet('Ujian Praktek');
      const mapelUM = getMapelByJenis(spreadsheetId, 'madrasah');
      const mapelUP = getMapelByJenis(spreadsheetId, 'praktek');
      populateSheet(sheetUM, mapelUM);
      populateSheet(sheetUP, mapelUP);
      uploadTypeIdentifier = 'ujian_gabungan';
    
    } else {
      throw new Error(`Nama template "${templateName}" tidak valid.`);
    }

    const validationSheet = ss.insertSheet('_validation_');
    validationSheet.getRange("A1").setValue(uploadTypeIdentifier);
    validationSheet.hideSheet();
    
    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${ss.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, { headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` }, muteHttpExceptions: true });
    const blob = response.getBlob();

    return {
      fileName: `Template_${templateName}.xlsx`,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(`generateNilaiTemplate Error: ${e.stack}`);
    return { error: e.toString() };
  } finally {
    if (tempFile) tempFile.setTrashed(true);
  }
}

/**
 * [FINAL v3 - DENGAN RESOLUSI KONFLIK] Menerima file Excel dan mengimpor nilai ke sheet yang sesuai.
 * Fungsi ini sekarang mengumpulkan konflik dari semua sheet terkait dan mengembalikannya ke frontend.
 */
function uploadNilaiFromExcel(spreadsheetId, fileData, uploadType, selectedKelas) {
    let tempFileId = null;
    try {
        const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
        const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
        const tempSpreadsheetFile = Drive.Files.insert({ title: `temp_upload_${uploadType}` }, blob, { convert: true });

        if (!tempSpreadsheetFile || !tempSpreadsheetFile.id) {
            throw new Error("Gagal membuat file sementara di Google Drive. Pastikan Drive API telah diaktifkan.");
        }

        tempFileId = tempSpreadsheetFile.id;
        const importSs = SpreadsheetApp.openById(tempFileId);

        const validationSheet = importSs.getSheetByName('_validation_');
        if (!validationSheet) {
            throw new Error("File tidak valid. Harap gunakan template yang diunduh langsung dari aplikasi.");
        }
        const fileIdentifier = validationSheet.getRange("A1").getValue().toString().trim();
        if (fileIdentifier !== uploadType) {
            const formatTypeName = (typeStr) => typeStr.replace(/_/g, ' ').replace(/(^\w{1})|(\s+\w{1})/g, letter => letter.toUpperCase());
            throw new Error(`Kesalahan Upload: Anda mencoba mengunggah template untuk "${formatTypeName(fileIdentifier)}" ke slot "${formatTypeName(uploadType)}".`);
        }

        const targetSs = getSpreadsheet(spreadsheetId);
        
        // Objek untuk mengumpulkan hasil dari semua sheet
        const finalResult = {
            newValuesCount: 0,
            skippedCount: 0,
            conflicts: []
        };

        const processAndCombine = (sheetName, importSheet, mapelList) => {
            const result = processSheetImport(targetSs, sheetName, importSheet, mapelList, selectedKelas);
            finalResult.newValuesCount += result.newValuesCount;
            finalResult.skippedCount += result.skippedCount;
            finalResult.conflicts.push(...result.conflicts);
        };

        if (uploadType.startsWith('rapor_')) {
            const semesterKey = uploadType.split('_').slice(1).join('_');
            const allMapel = getMapel(spreadsheetId);
            processAndCombine(`Rapor_Pengetahuan_${semesterKey}`, importSs.getSheetByName('Pengetahuan'), allMapel);
            processAndCombine(`Rapor_Keterampilan_${semesterKey}`, importSs.getSheetByName('Keterampilan'), allMapel);
        } else if (uploadType === 'ujian_gabungan') {
            const mapelUM = getMapelByJenis(spreadsheetId, 'madrasah');
            const mapelUP = getMapelByJenis(spreadsheetId, 'praktek');
            processAndCombine(SHEET_NILAI_UJIAN_MADRASAH, importSs.getSheetByName('Ujian Madrasah'), mapelUM);
            processAndCombine(SHEET_NILAI_UJIAN_PRAKTEK, importSs.getSheetByName('Ujian Praktek'), mapelUP);
        } else {
            throw new Error("Tipe upload tidak dikenali.");
        }

        // Kembalikan objek finalResult yang sudah digabungkan
        return { 
            status: "success", 
            ...finalResult 
        };

    } catch (e) {
        Logger.log(`uploadNilaiFromExcel Error: ${e.stack}`);
        return { status: "error", message: e.toString() };
    } finally {
        if (tempFileId) {
            DriveApp.getFileById(tempFileId).setTrashed(true);
        }
    }
}

// ===== AWAL KODE TAMBAHAN UNTUK FITUR BROADCAST =====

/**
 * [SUPERADMIN] Mengirimkan pesan broadcast ke semua pengguna.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {string} title - Judul pesan.
 * @param {string} message - Isi pesan.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function sendBroadcast_Superadmin(adminEmail, title, message) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak. Hanya Superadmin." };
  }
  try {
    if (!title || !message) {
      return { status: "error", message: "Judul dan Isi Pesan tidak boleh kosong." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let broadcastSheet = ss.getSheetByName(SHEET_BROADCAST);

    // Buat sheet jika belum ada
    if (!broadcastSheet) {
      broadcastSheet = ss.insertSheet(SHEET_BROADCAST);
      broadcastSheet.appendRow(['Broadcast ID', 'Tanggal', 'Judul', 'Isi Pesan']);
      broadcastSheet.getRange("A1:D1").setFontWeight("bold");
    }

    const broadcastId = Utilities.getUuid();
    broadcastSheet.appendRow([broadcastId, new Date(), title, message]);

    return { status: "success", message: "Pesan broadcast berhasil dikirim." };

  } catch (e) {
    Logger.log("sendBroadcast_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal mengirim pesan: " + e.message };
  }
}

/**
 * [HELPER] Mengambil data broadcast terbaru dari sheet.
 * @returns {object|null} Objek berisi detail broadcast terbaru atau null jika tidak ada.
 */
function getLatestBroadcast() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_BROADCAST);

    if (!sheet || sheet.getLastRow() < 2) {
      return null;
    }

    const lastRow = sheet.getLastRow();
    const [id, timestamp, title, message] = sheet.getRange(lastRow, 1, 1, 4).getValues()[0];

    return {
      id: id,
      title: title,
      message: message
    };
  } catch (e) {
    Logger.log("getLatestBroadcast Error: " + e.message);
    return null;
  }
}

/**
 * [USER - DIPERBARUI] Menandai bahwa pengguna telah melihat broadcast terbaru.
 * Mencatat status ke sheet terpisah untuk pelacakan yang akurat.
 * @param {string} userEmail - Email pengguna yang akan ditandai.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function markBroadcastAsRead(userEmail) {
  try {
    if (!userEmail) {
      return { status: 'error', message: 'Email pengguna tidak valid.' };
    }

    const latestBroadcast = getLatestBroadcast();
    if (!latestBroadcast) {
      return { status: 'info', message: 'Tidak ada broadcast untuk ditandai.' };
    }
    const latestBroadcastId = latestBroadcast.id;

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let readStatusSheet = ss.getSheetByName(SHEET_BROADCAST_READ_STATUS);
    
    // Buat sheet jika belum ada
    if (!readStatusSheet) {
      readStatusSheet = ss.insertSheet(SHEET_BROADCAST_READ_STATUS);
      readStatusSheet.appendRow(['Broadcast ID', 'User Email', 'Read Timestamp']);
    }
    
    // Cek dulu apakah data sudah ada untuk mencegah duplikat
    if (!hasUserReadBroadcast(latestBroadcastId, userEmail)) {
        readStatusSheet.appendRow([latestBroadcastId, userEmail, new Date()]);
    }

    return { status: 'success', message: 'Status broadcast telah diperbarui.' };

  } catch (e) {
    Logger.log("markBroadcastAsRead Error: " + e.message);
    return { status: 'error', message: 'Gagal memperbarui status broadcast: ' + e.message };
  }
}

/**
 * [HELPER BARU] Mengecek apakah seorang pengguna sudah pernah membaca broadcast tertentu.
 * @param {string} broadcastId - ID broadcast yang ingin dicek.
 * @param {string} userEmail - Email pengguna.
 * @returns {boolean} True jika sudah membaca, false jika belum.
 */
function hasUserReadBroadcast(broadcastId, userEmail) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_BROADCAST_READ_STATUS);
    if (!sheet || sheet.getLastRow() < 2) return false;

    const data = sheet.getRange("A2:B" + sheet.getLastRow()).getValues();
    return data.some(row => row[0] === broadcastId && row[1].toLowerCase() === userEmail.toLowerCase());
  } catch (e) {
    Logger.log("hasUserReadBroadcast Error: " + e.message);
    return false; // Anggap belum baca jika error
  }
}

/**
 * [SUPERADMIN BARU - DIPERBAIKI] Mengambil riwayat semua broadcast beserta jumlah pembacanya.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek data broadcast.
 */
function getBroadcastHistory_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) throw new Error("Akses ditolak.");

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const broadcastSheet = ss.getSheetByName(SHEET_BROADCAST);
  if (!broadcastSheet || broadcastSheet.getLastRow() < 2) return [];

  const broadcasts = broadcastSheet.getRange("A2:D" + broadcastSheet.getLastRow()).getValues().map(row => ({
    id: row[0],
    // PERUBAHAN UTAMA: Ubah objek Date menjadi string ISO yang aman untuk dikirim ke browser.
    date: row[1] instanceof Date ? row[1].toISOString() : row[1],
    title: row[2],
    message: row[3]
  }));

  const readStatusSheet = ss.getSheetByName(SHEET_BROADCAST_READ_STATUS);
  const readCounts = new Map();

  if (readStatusSheet && readStatusSheet.getLastRow() >= 2) {
    const readData = readStatusSheet.getRange("A2:A" + readStatusSheet.getLastRow()).getValues().flat();
    readData.forEach(id => {
      readCounts.set(id, (readCounts.get(id) || 0) + 1);
    });
  }

  return broadcasts.map(b => ({
    ...b,
    readByCount: readCounts.get(b.id) || 0
  })).sort((a, b) => new Date(b.date) - new Date(a.date)); // Urutkan dari terbaru
}

/**
 * [SUPERADMIN BARU] Memperbarui data broadcast yang sudah ada.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {object} broadcastData - Data yang akan diupdate {id, title, message}.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function updateBroadcast_Superadmin(adminEmail, broadcastData) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };

  try {
    const { id, title, message } = broadcastData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_BROADCAST);
    const data = sheet.getRange("A2:A" + sheet.getLastRow()).getValues().flat();
    const rowIndex = data.findIndex(rowId => rowId === id);

    if (rowIndex === -1) throw new Error("Broadcast tidak ditemukan.");

    const rowToUpdate = rowIndex + 2;
    sheet.getRange(rowToUpdate, 3).setValue(title);
    sheet.getRange(rowToUpdate, 4).setValue(message);
    
    return { status: "success", message: "Pengumuman berhasil diperbarui." };
  } catch (e) {
    Logger.log("updateBroadcast_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memperbarui: " + e.message };
  }
}

/**
 * [SUPERADMIN BARU] Menghapus data broadcast dan semua catatan 'telah dibaca' yang terkait.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {string} broadcastId - ID broadcast yang akan dihapus.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function deleteBroadcast_Superadmin(adminEmail, broadcastId) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };

  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // Hapus dari sheet utama
    const broadcastSheet = ss.getSheetByName(SHEET_BROADCAST);
    const dataBroadcast = broadcastSheet.getRange("A2:A" + broadcastSheet.getLastRow()).getValues().flat();
    const indexToDelete = dataBroadcast.findIndex(id => id === broadcastId);
    if (indexToDelete !== -1) {
      broadcastSheet.deleteRow(indexToDelete + 2);
    }
    
    // Hapus dari sheet status baca
    const readStatusSheet = ss.getSheetByName(SHEET_BROADCAST_READ_STATUS);
    if (readStatusSheet && readStatusSheet.getLastRow() >= 2) {
      const readData = readStatusSheet.getRange("A2:A" + readStatusSheet.getLastRow()).getValues();
      const rowsToDelete = [];
      readData.forEach((row, index) => {
        if (row[0] === broadcastId) {
          rowsToDelete.push(index + 2);
        }
      });
      // Hapus dari bawah ke atas agar indeks tidak bergeser
      for (let i = rowsToDelete.length - 1; i >= 0; i--) {
        readStatusSheet.deleteRow(rowsToDelete[i]);
      }
    }
    
    lock.releaseLock();
    return { status: "success", message: "Pengumuman berhasil dihapus." };
  } catch (e) {
    lock.releaseLock();
    Logger.log("deleteBroadcast_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal menghapus: " + e.message };
  }
}

// ===== AWAL KODE TAMBAHAN (Fitur Portal Siswa) =====

/**
 * [PERBAIKAN FINAL] Mencari siswa dan mengambil semua data, termasuk standardisasi
 * nilai visibilitas transkrip sebelum dikirim ke frontend.
 * @param {string} kodeSekolah - Kode unik sekolah.
 * @param {string} nisn - NISN yang diinput siswa.
 * @param {string} tanggalLahir - Tanggal lahir dalam format yyyy-MM-dd.
 * @returns {object} Objek status berisi semua data yang dibutuhkan siswa jika berhasil.
 */
function loginSiswa(kodeSekolah, nisn, tanggalLahir) {
    try {
        if (!kodeSekolah || !nisn || !tanggalLahir) {
            return { status: "error", message: "Kode Sekolah, NISN, dan Tanggal Lahir wajib diisi." };
        }

        const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
        if (!userSheet || userSheet.getLastRow() < 2) {
            return { status: "error", message: "Sistem tidak menemukan data sekolah manapun." };
        }
        
        const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
        const schoolRow = data.find(row => row[12] && row[12].toUpperCase() === kodeSekolah.toUpperCase());

        if (!schoolRow) {
            return { status: "error", message: "Kode Sekolah tidak valid atau tidak ditemukan." };
        }

        const lockStatus = checkFiturLock(schoolRow[1]);
        if (lockStatus.isLocked) {
          return { 
            status: "locked", 
            message: "Akses untuk siswa dari sekolah ini sementara ditangguhkan. Silakan hubungi administrator sekolah Anda untuk informasi lebih lanjut." 
          };
        }
        
        const spreadsheetId = schoolRow[5];
        if (!spreadsheetId) {
            return { status: "error", message: "Konfigurasi untuk sekolah ini tidak lengkap." };
        }

        const studentInfo = findStudentInSheet(spreadsheetId, nisn, tanggalLahir);

        if (studentInfo) {
            const schoolData = getSchoolData(spreadsheetId);
            const gradSettingsResponse = getGraduationSettings(spreadsheetId);
            const gradSettings = gradSettingsResponse.settings || { announcementDate: null, showTranscriptGlobal: 'TIDAK' };
            const rekapIjazah = getSheetDataAsObject(spreadsheetId, SHEET_REKAP_IJAZAH);
            const studentRekap = rekapIjazah[nisn] || {};
            const statusLulus = studentRekap['Status'] || 'Belum Ditentukan';
            
            // --- AWAL PERBAIKAN ---
            // Baca nilai mentah dari spreadsheet.
            const studentDataSheet = getSpreadsheet(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
            const nisnColumnValues = studentDataSheet.getRange(2, 1, studentDataSheet.getLastRow() - 1, 1).getValues().flat();
            const studentRowIndex = nisnColumnValues.findIndex(val => val.toString() === nisn.toString());
            const rawVisibility = (studentRowIndex !== -1) ? studentDataSheet.getRange(studentRowIndex + 2, 13).getValue() : 'TIDAK';

            // Lakukan standardisasi: ubah ke string, hapus spasi, dan jadikan huruf besar.
            const perStudentVisibility = String(rawVisibility || 'TIDAK').trim().toUpperCase();
            // --- AKHIR PERBAIKAN ---

            return {
                status: "success",
                webAppUrl: ScriptApp.getService().getUrl(),
                nisn: nisn,
                spreadsheetId: spreadsheetId,
                studentData: studentInfo,
                schoolData: schoolData,
                announcementDate: gradSettings.announcementDate,
                showTranscriptGlobal: gradSettings.showTranscriptGlobal,
                showTranscriptPerStudent: perStudentVisibility, // Kirim data yang sudah bersih
                statusLulus: statusLulus
            };
        } else {
            return { status: "error", message: "Login Gagal. Pastikan NISN dan Tanggal Lahir Anda benar. Jika masih mengalami kendala login, silahkan hubungi Operator Sekolah/Madrasah." };
        }

    } catch (error) {
        Logger.log("loginSiswa Error: " + error.message + " Stack: " + error.stack);
        return { status: "error", message: "Terjadi kesalahan pada server." };
    }
}

/**
 * [DIPERBARUI v3] Mencari siswa dan menstandardisasi output visibilitas transkrip.
 */
function findStudentInSheet(spreadsheetId, nisn, tanggalLahir) {
  const ss = SpreadsheetApp.openById(spreadsheetId);
  const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
  if (!sheet || sheet.getLastRow() < 2) return null;

  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 15).getValues();

  for (const row of data) {
    const sheetNisn = String(row[0]).trim();

    if (sheetNisn === nisn) {
      const sheetTglLahir = row[6];
      
      if (sheetTglLahir instanceof Date) {
        const formattedSheetTglLahir = Utilities.formatDate(sheetTglLahir, Session.getScriptTimeZone(), "yyyy-MM-dd");
        
        if (formattedSheetTglLahir === tanggalLahir) {
          return {
            nisn: String(row[0] || ''),
            nis: String(row[1] || ''),
            nomorUjian: String(row[2] || ''),
            nama: String(row[3] || ''),
            jenisKelamin: String(row[4] || ''),
            tempatLahir: String(row[5] || ''),
            tanggalLahir: formattedSheetTglLahir,
            alamat: String(row[7] || ''),
            telepon: String(row[8] || ''),
            emailSiswa: String(row[9] || ''),
            tahunMasuk: String(row[10] || ''),
            tahunLulus: String(row[11] || ''),
            
            // --- PERBAIKAN DI SINI ---
            // Standardisasi output untuk memastikan konsistensi data.
            tampilkanTranskrip: String(row[12] || 'TIDAK').trim().toUpperCase(),
            
            kelas: String(row[13] || ''),
            ruangUjian: String(row[14] || '')
          };
        }
      }
    }
  }
  return null; // Tidak ada yang cocok di sheet ini
}
// ===== AKHIR KODE TAMBAHAN (Fitur Portal Siswa) =====

function generateMissingSchoolCodes_Superadmin() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEET_PENGGUNA);
  if (!sheet || sheet.getLastRow() < 2) {
    Logger.log("Sheet Data Pengguna kosong atau tidak ditemukan.");
    return;
  }
  
  const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 13);
  const data = dataRange.getValues();
  const existingCodes = data.map(row => row[12]).filter(Boolean);
  let updatedCount = 0;

  data.forEach((row, index) => {
    // Cek jika kolom Kode Sekolah (indeks 12) kosong
    if (!row[12]) {
      let newCode;
      let isUnique = false;
      while (!isUnique) {
        newCode = Math.random().toString(36).substring(2, 8).toUpperCase();
        if (!existingCodes.includes(newCode)) {
          isUnique = true;
        }
      }
      // Tulis kode baru ke spreadsheet di baris yang benar dan kolom M (13)
      sheet.getRange(index + 2, 13).setValue(newCode);
      existingCodes.push(newCode); // Tambahkan ke daftar agar tidak terduplikasi di loop yang sama
      updatedCount++;
    }
  });
  
  Logger.log(`Proses Selesai. ${updatedCount} kode sekolah baru telah dibuat.`);
  Browser.msgBox(`Proses Selesai. ${updatedCount} kode sekolah baru telah dibuat.`);
}

// ===== AWAL KODE TAMBAHAN UNTUK AKSI MASSAL ADMIN =====

/**
 * [AKSI MASSAL] Mengubah batas siswa untuk beberapa akun sekaligus.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {Array<number>} rowNumbers - Array berisi nomor baris akun yang akan diubah.
 * @param {number} newLimit - Batas siswa baru yang akan diterapkan.
 * @returns {object} Hasil operasi.
 */
function bulkUpdateLimit_Superadmin(adminEmail, rowNumbers, newLimit) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };
  
  try {
    const limit = parseInt(newLimit);
    if (isNaN(limit) || limit < 0) {
      return { status: "error", message: "Batas siswa harus berupa angka positif." };
    }
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    
    rowNumbers.forEach(rowNum => {
      userSheet.getRange(rowNum, 9).setValue(limit); // Kolom I adalah Student Limit
    });

    return { status: "success", message: `${rowNumbers.length} akun berhasil diupdate batas siswanya.` };
  } catch (e) {
    return { status: "error", message: "Gagal mengupdate batas secara massal: " + e.message };
  }
}

/**
 * [AKSI MASSAL] Mengubah status (Aktif/Nonaktif) untuk beberapa akun sekaligus.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {Array<number>} rowNumbers - Array berisi nomor baris akun yang akan diubah.
 * @param {string} newStatus - Status baru ('Aktif' atau 'Nonaktif').
 * @returns {object} Hasil operasi.
 */
function bulkSetStatus_Superadmin(adminEmail, rowNumbers, newStatus) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };

  if (newStatus !== 'Aktif' && newStatus !== 'Nonaktif') {
      return { status: "error", message: "Status tidak valid." };
  }
  
  try {
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    
    rowNumbers.forEach(rowNum => {
      userSheet.getRange(rowNum, 8).setValue(newStatus); // Kolom H adalah Status
    });

    return { status: "success", message: `${rowNumbers.length} akun berhasil diubah statusnya menjadi ${newStatus}.` };
  } catch (e) {
    return { status: "error", message: "Gagal mengubah status secara massal: " + e.message };
  }
}

// ===== AKHIR KODE TAMBAHAN UNTUK AKSI MASSAL ADMIN =====

/**
 * [BARU] Men-generate dan menyimpan Kode Sekolah unik untuk pengguna yang sudah ada.
 * Hanya akan membuat kode jika kolomnya masih kosong.
 * @param {string} spreadsheetId ID spreadsheet pengguna yang meminta.
 * @returns {{status: string, message: string, newCode?: string}} Hasil operasi.
 */
function generateSchoolCodeForUser(spreadsheetId) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);

    if (!userSheet || userSheet.getLastRow() < 2) {
      throw new Error("Sheet 'Data Pengguna' tidak ditemukan.");
    }

    const dataRange = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13);
    const usersData = dataRange.getValues();
    
    // Cari baris pengguna berdasarkan spreadsheetId (Kolom F, index 5)
    const userIndex = usersData.findIndex(row => row[5] === spreadsheetId);

    if (userIndex === -1) {
      throw new Error("Data pengguna tidak ditemukan.");
    }

    const rowToUpdate = userIndex + 2; // +2 karena data dimulai dari baris 2 dan index array dimulai dari 0
    const existingCode = usersData[userIndex][12]; // Kolom M (Kode Sekolah) adalah index 12

    if (existingCode && existingCode.toString().trim() !== '') {
      return { status: "error", message: "Anda sudah memiliki Kode Sekolah.", newCode: existingCode };
    }

    // Generate kode unik baru
    let schoolCode;
    let isCodeUnique = false;
    const allExistingCodes = usersData.map(row => row[12]).filter(Boolean);
    
    while (!isCodeUnique) {
      schoolCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      if (!allExistingCodes.includes(schoolCode)) {
        isCodeUnique = true;
      }
    }

    // Simpan kode baru ke sheet
    userSheet.getRange(rowToUpdate, 13).setValue(schoolCode);
    
    SpreadsheetApp.flush(); // Pastikan perubahan segera tersimpan

    return { status: "success", message: "Kode Sekolah berhasil dibuat!", newCode: schoolCode };

  } catch (e) {
    Logger.log("Error in generateSchoolCodeForUser: " + e.message);
    return { status: "error", message: "Gagal membuat kode: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [VERSI FINAL & PALING STABIL] Membuat PDF transkrip dengan mengambil pengaturan
 * langsung dari spreadsheet dan menyematkan token validasi unik ke dalam QR code.
 * Fungsi ini tidak lagi memerlukan parameter 'printOptions'.
 *
 * @param {string} spreadsheetId ID spreadsheet pengguna.
 * @param {string} nisn NISN siswa yang akan dibuatkan transkrip.
 * @returns {object} Objek berisi data file PDF yang telah di-encode base64.
 */
function generateTranscriptPdfForSiswa(spreadsheetId, nisn) {
  try {
    // 1. Ambil semua data utama yang diperlukan dalam satu panggilan
    const transcriptDataResponse = getTranscriptData(spreadsheetId, nisn);
    if (transcriptDataResponse.status !== 'success') {
      throw new Error(transcriptDataResponse.message);
    }
    const { student, school, subjects, bobot, printSettings } = transcriptDataResponse.data;

    // 2. Ambil pengaturan dokumen (gambar)
    const docSettingsResponse = getDocumentSettings(spreadsheetId);
    const docSettings = docSettingsResponse.settings || {};
    const { logo, signature, stamp, customHeader } = docSettings;

    // 3. Fungsi Helper dan Kalkulasi Nilai
    const toProperCase = (str) => {
        if (!str || typeof str !== 'string') return '';
        return str.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
    };
    const tglLahirFormatted = new Date(student.tanggalLahir).toLocaleDateString('id-ID', { day: 'numeric', month: 'long', year: 'numeric' });
    const nomorIndukGabungan = student.nis ? (school.nsm || '') + student.nis : '-';
    const formatScore = (score) => {
      if (score === null || score === undefined || isNaN(score)) return '0';
      return `${Math.round(score)}`;
    };
    let totalNilaiIjazah = 0;
    const mapelCount = subjects.length;
    subjects.forEach(s => {
      totalNilaiIjazah += (s.nilaiIjazah !== null && !isNaN(s.nilaiIjazah)) ? Math.round(s.nilaiIjazah) : 0;
    });
    const rataRataIjazah = mapelCount > 0 ? (totalNilaiIjazah / mapelCount).toFixed(2).replace('.', ',') : '0,00';

    // 4. Logika Dinamis untuk Teks Transkrip (berdasarkan data yang sudah diambil)
    let tahunAjaranText = '';
    if (printSettings && printSettings.tahunAjaran && printSettings.tahunAjaran.trim() !== '') {
        tahunAjaranText = printSettings.tahunAjaran;
    } else if (student.tahunLulus && !isNaN(parseInt(student.tahunLulus))) {
        const tahunLulus = parseInt(student.tahunLulus);
        tahunAjaranText = `${tahunLulus - 1}/${tahunLulus}`;
    }

    const tempatTTD = printSettings.tempatTtd || toProperCase(school.kabupaten) || '(Tempat)';
    let tanggalTTD = new Date().toLocaleDateString('id-ID', { day: '2-digit', month: 'long', year: 'numeric' });
    if (printSettings.tanggalTtd) {
        const inputDate = new Date(printSettings.tanggalTtd);
        inputDate.setMinutes(inputDate.getMinutes() + inputDate.getTimezoneOffset());
        tanggalTTD = inputDate.toLocaleDateString('id-ID', { day: '2-digit', month: 'long', year: 'numeric' });
    }

    let qrCodeHtml = '';
    if (printSettings.showQRCode) {
        // PENTING: Pastikan nisn dan spreadsheetId dikirim ke sini
        const qrCodeBase64 = getQrCodeAsBase64(nisn, spreadsheetId);
        if (qrCodeBase64) {
            qrCodeHtml = `<img src="data:image/png;base64,${qrCodeBase64}" style="width: 80px; height: 80px;" alt="QR Code"><br><span style="font-size:7pt;">Scan untuk validasi</span>`;
        }
    }
    
    // 6. Logika untuk Kop Surat
    let headerHtml;
    if (customHeader) {
        headerHtml = `<div style="width: 100%; margin-bottom: 10px; border-bottom: 3px solid black;"><img src="${customHeader}" alt="Kop Surat" style="width: 100%; height: auto;"></div>`;
    } else {
        const kantorKemenagLine = `KANTOR KEMENTERIAN AGAMA ${school.tipeKabupaten || ''} ${school.kabupaten || ''}`.toUpperCase();
        const tipeKabSingkat = school.tipeKabupaten === 'Kabupaten' ? 'Kab.' : 'Kota';
        const tipeKelSingkat = school.tipeKelurahan === 'Kelurahan' ? 'Kel.' : 'Desa';
        const alamatLengkap = [ school.alamat, `${tipeKelSingkat} ${toProperCase(school.kelurahan || '')}`, `Kec. ${toProperCase(school.kecamatan || '')}`, `${tipeKabSingkat} ${toProperCase(school.kabupaten || '')}`, toProperCase(school.provinsi || ''), school.kodePos ].filter(Boolean).join(', ');
        
        const phone = school.telepon ? `Telepon : ${school.telepon}` : '';
        const web = school.website ? `Website : ${school.website}` : '';
        let contactLine = '';
        if (phone && web) {
          contactLine = `${phone} | ${web}`;
        } else {
          contactLine = phone || web;
        }
        const contactLineHtml = contactLine ? `<div style="font-family: Arial, sans-serif; font-size: 9pt;">${contactLine}</div>` : '';

        headerHtml = `
            <div style="display: flex; align-items: flex-start; padding-bottom: 5px; border-bottom: 3px solid black; margin-bottom: 10px;">
                ${logo ? `<img src="${logo}" style="width:75px; height:75px; margin-right: 20px;" alt="Logo">` : '<div style="width:75px; height:75px; margin-right: 20px;"></div>'}
                <div style="text-align: center; flex-grow: 1; line-height: 1.4; font-family: Arial, sans-serif;">
                   <div style="font-size: 14pt; font-weight: bold;">KEMENTERIAN AGAMA REPUBLIK INDONESIA</div>
                   <div style="font-size: 12pt; font-weight: bold;">${kantorKemenagLine}</div>
                   <div style="font-size: 11pt; font-weight: bold;">${(school.namaSekolah || 'NAMA SEKOLAH').toUpperCase()}</div>
                   <div style="font-size: 9pt;">Alamat : ${alamatLengkap}</div>
                   ${contactLineHtml}
                </div>
            </div>`;
    }

    // 7. Template HTML untuk PDF
    const htmlContent = `
      <html>
        <head>
          <style>
            body{font-family: Arial, sans-serif; font-size: 10pt;} 
            table{border-collapse: collapse; width: 100%;} 
            th, td{border: 1px solid black; padding: 4px; text-align: left; vertical-align: middle;} 
            .no-border{border: none !important;}
            .text-center{text-align: center;} 
            .font-bold{font-weight: bold;} 
            .bg-gray{background-color: #f2f2f2;}
            .footer-container { margin-top: 40px; width: 100%; display: flex; justify-content: space-between; align-items: flex-end; }
            .ttd-block { width: 45%; text-align: center; font-size: 10pt; }
            .qr-block { text-align: center; font-size: 8pt; color: #555; }
            .ttd-signature-area { position: relative; height: 80px; margin-top: 10px; margin-bottom: 5px; }
            .ttd-signature { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); max-width: 150px; max-height: 100px; z-index: 1; }
            .ttd-stamp { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) rotate(-15deg); opacity: 0.75; max-width: 120px; max-height: 120px; z-index: 2; }
            .ttd-name-nip { position: absolute; bottom: -25px; width: 100%; left: 0; }
            .ttd-name { font-weight: bold; text-decoration: underline; margin-bottom: 2px; margin-top: 0; }
            .ttd-nip { margin-top: 0; }
          </style>
        </head>
        <body>
          ${headerHtml}
          <div class="text-center" style="margin-top: 10px; line-height: 1.2;">
             <h3 class="font-bold" style="text-decoration: underline; font-size: 14pt; margin-bottom: 0;">TRANSKRIP NILAI</h3>
             ${tahunAjaranText ? `<p style="font-size: 11pt; font-weight: bold; margin-top: 0; margin-bottom: 10px;">TAHUN AJARAN ${tahunAjaranText}</p>` : ''}
          </div>
          
          <table class="no-border" style="margin-top: 1rem; margin-bottom: 1rem;">
              <tbody>
                  <tr><td class="no-border" style="padding: 1px; width: 180px;">Nama Peserta Didik</td><td class="no-border" style="padding: 1px; width: 10px;">:</td><td class="no-border font-bold" style="padding: 1px;">${student.nama.toUpperCase()}</td></tr>
                  <tr><td class="no-border" style="padding: 1px;">Tempat, Tanggal Lahir</td><td class="no-border" style="padding: 1px;">:</td><td class="no-border font-bold" style="padding: 1px;">${student.tempatLahir ? toProperCase(student.tempatLahir) + ', ' : ''}${tglLahirFormatted}</td></tr>
                  <tr><td class="no-border" style="padding: 1px;">Nomor Induk / NISN</td><td class="no-border" style="padding: 1px;">:</td><td class="no-border font-bold" style="padding: 1px;">${nomorIndukGabungan} / ${student.nisn}</td></tr>
              </tbody>
          </table>

          <table>
            <thead class="bg-gray">
              <tr><th class="text-center" rowspan="2">No</th><th rowspan="2">Mata Pelajaran</th><th class="text-center" colspan="3">Nilai</th></tr>
              <tr><th class="text-center">Rata-Rata Rapor</th><th class="text-center">Ujian Madrasah</th><th class="text-center">Nilai Ijazah</th></tr>
            </thead>
            <tbody>${subjects.map((s, index) => `<tr><td class="text-center">${index + 1}</td><td>${s.nama}</td><td class="text-center">${formatScore(s.nilaiRapor)}</td><td class="text-center">${formatScore(s.nilaiUjian)}</td><td class="text-center font-bold">${formatScore(s.nilaiIjazah)}</td></tr>`).join('')}</tbody>
            <tfoot class="font-bold"><tr><td class="text-center" colspan="4">Rata-rata Nilai Akhir Ijazah</td><td class="text-center bg-gray">${rataRataIjazah}</td></tr></tfoot>
          </table>

          <div style="font-style: italic; font-size: 8pt; margin-top: 15px;">
              Ket: Nilai Ijazah = ${bobot.bobotUjian}% Nilai Ujian Madrasah + ${bobot.bobotRapor}% Nilai Rapor 5 Semester
          </div>

          <div class="footer-container">
              <div class="qr-block">
                ${qrCodeHtml}
              </div>
              <div class="ttd-block">
                  <p>${tempatTTD}, ${tanggalTTD}</p>
                  <p>Kepala Madrasah,</p>
                  <div class="ttd-signature-area">
                      ${stamp ? `<img src="${stamp}" alt="Stempel" class="ttd-stamp">` : ''}
                      ${signature ? `<img src="${signature}" alt="Tanda Tangan" class="ttd-signature">` : ''}
                      <div class="ttd-name-nip">
                        <p class="ttd-name">${school.namaKepsek || '(Nama Kepala Sekolah)'}</p>
                        <p class="ttd-nip">NIP. ${school.nipKepsek || '-'}</p>
                      </div>
                  </div>
              </div>
          </div>
        </body>
      </html>
    `;

    // 8. Konversi ke PDF
    const pdfBlob = Utilities.newBlob(htmlContent, MimeType.HTML).getAs(MimeType.PDF);
    pdfBlob.setName(`Transkrip - ${student.nama}.pdf`);
    
    return {
      status: 'success',
      fileName: pdfBlob.getName(),
      pdfData: Utilities.base64Encode(pdfBlob.getBytes())
    };

  } catch (e) {
    Logger.log("Error in generateTranscriptPdfForSiswa: " + e.message + " | Stack: " + e.stack);
    return { status: "error", message: "Gagal membuat PDF: " + e.message };
  }
}

/**
 * [BARU - VERSI DINAMIS & WARNA UNIK] Mengambil data perkembangan nilai per semester untuk seorang siswa.
 * Membaca dari semua sheet Rapor dan menampilkan SEMUA mapel yang ada di Data Mata Pelajaran.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @param {string} nisn NISN siswa yang datanya akan diambil.
 * @returns {object} Objek berisi data yang siap digunakan untuk membuat grafik.
 */
function getStudentGradeProgress(spreadsheetId, nisn) {
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    
    // 1. Dapatkan jenjang sekolah untuk menentukan daftar semester yang relevan
    const schoolData = getSchoolData(spreadsheetId);
    if (!schoolData || !schoolData.jenjang) {
      throw new Error("Jenjang sekolah tidak ditemukan.");
    }
    
    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    const semestersForJenjang = semesterKeys[schoolData.jenjang] || [];

    // 2. Ambil semua data nilai dari semua sheet rapor yang relevan sekali jalan
    const allScoreData = {};
    semestersForJenjang.forEach(smKey => {
        allScoreData[`Rapor_Pengetahuan_${smKey}`] = getSheetDataAsObject(spreadsheetId, `Rapor_Pengetahuan_${smKey}`);
        allScoreData[`Rapor_Keterampilan_${smKey}`] = getSheetDataAsObject(spreadsheetId, `Rapor_Keterampilan_${smKey}`);
    });
    
    // 3. Ambil SEMUA mata pelajaran dari sheet pengguna untuk ditampilkan di grafik
    const subjectsToChart = getMapel(spreadsheetId);

    if (!subjectsToChart || subjectsToChart.length === 0) {
      return { status: 'nodata', message: 'Tidak ada mata pelajaran yang ditemukan untuk dibuatkan grafik.' };
    }

    // 4. Proses data untuk setiap mapel dan semester
    const datasets = [];
    // Palet warna yang lebih besar untuk memastikan keunikan warna
    const colorPalette = [
        '#3B82F6', '#10B981', '#EF4444', '#F97316', '#8B5CF6', '#EC4899', 
        '#6366F1', '#F59E0B', '#14B8A6', '#65A30D', '#A855F7', '#D97706', 
        '#06B6D4', '#F472B6', '#4B5563', '#059669', '#DB2777', '#7C3AED'
    ];

    subjectsToChart.forEach((mapel, index) => {
      const subjectData = [];
      let hasAnyGrade = false;

      semestersForJenjang.forEach(smKey => {
        const scoresP = (allScoreData[`Rapor_Pengetahuan_${smKey}`] || {})[nisn] || {};
        const scoresK = (allScoreData[`Rapor_Keterampilan_${smKey}`] || {})[nisn] || {};
        
        const nilaiP = parseFloat(scoresP[mapel.kode]);
        const nilaiK = parseFloat(scoresK[mapel.kode]);
        
        let avgScore = null;
        if (!isNaN(nilaiP) && !isNaN(nilaiK)) {
          avgScore = (nilaiP + nilaiK) / 2;
          hasAnyGrade = true;
        } else if (!isNaN(nilaiP)) {
          avgScore = nilaiP;
          hasAnyGrade = true;
        } else if (!isNaN(nilaiK)) {
          avgScore = nilaiK;
          hasAnyGrade = true;
        }
        subjectData.push(avgScore);
      });
      
      if (hasAnyGrade) {
        const colorIndex = index % colorPalette.length; // Gunakan modulo untuk mencegah error jika mapel > warna
        datasets.push({
          label: mapel.nama,
          data: subjectData,
          borderColor: colorPalette[colorIndex],
          backgroundColor: colorPalette[colorIndex] + '33', // Warna transparan untuk area di bawah garis
          fill: false,
          tension: 0.1
        });
      }
    });

    if (datasets.length === 0) {
       return { status: 'nodata', message: 'Siswa ini belum memiliki nilai rapor untuk mata pelajaran yang ada.' };
    }

    const semesterLabels = semestersForJenjang.map(key => key.replace('k','Kls ').replace('_',' '));

    return {
      status: 'success',
      labels: semesterLabels,
      datasets: datasets
    };

  } catch (e) {
    Logger.log("Error in getStudentGradeProgress: " + e.message + " Stack: " + e.stack);
    return { status: 'error', message: 'Gagal mengambil data grafik: ' + e.message };
  }
}

// ===== TAMBAHKAN DUA FUNGSI BARU INI DI BAGIAN SUPERADMIN PADA Kode.gs =====

/**
 * [SUPERADMIN] Membuat Kode Sekolah unik untuk satu pengguna tertentu.
 * @param {string} adminEmail Email Superadmin untuk verifikasi.
 * @param {number} targetUserRow Nomor baris pengguna yang akan dibuatkan kode.
 * @returns {object} Hasil operasi berisi status dan kode baru jika berhasil.
 */
function generateSchoolCodeForSingleUser_Superadmin(adminEmail, targetUserRow) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);

    const codeCell = userSheet.getRange(targetUserRow, 13); // Kolom M

    if (codeCell.getValue()) {
      return { status: "info", message: "Pengguna ini sudah memiliki Kode Sekolah." };
    }

    const allExistingCodes = userSheet.getLastRow() > 1 
      ? userSheet.getRange(2, 13, userSheet.getLastRow() - 1, 1).getValues().flat().filter(Boolean)
      : [];

    let newCode;
    let isCodeUnique = false;
    while (!isCodeUnique) {
      newCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      if (!allExistingCodes.includes(newCode)) {
        isCodeUnique = true;
      }
    }
    
    codeCell.setValue(newCode);
    SpreadsheetApp.flush(); // Pastikan perubahan segera tersimpan

    return { status: "success", message: `Kode ${newCode} berhasil dibuat.` };

  } catch (e) {
    Logger.log("generateSchoolCodeForSingleUser_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal membuat kode: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [AKSI MASSAL SUPERADMIN] Membuat Kode Sekolah untuk beberapa akun terpilih yang belum memilikinya.
 * @param {string} adminEmail Email Superadmin untuk verifikasi.
 * @param {Array<number>} rowNumbers Array nomor baris akun yang akan diproses.
 * @returns {object} Hasil operasi.
 */
function bulkGenerateSchoolCodes_Superadmin(adminEmail, rowNumbers) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) throw new Error("Sheet Pengguna tidak ditemukan.");
    
    let generatedCount = 0;
    const allUserData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
    const existingCodes = new Set(allUserData.map(row => row[12]).filter(Boolean));

    rowNumbers.forEach(rowNum => {
      const arrayIndex = rowNum - 2; // Konversi nomor baris ke indeks array
      if (allUserData[arrayIndex] && !allUserData[arrayIndex][12]) { // Cek jika data ada dan kode kosong
        let newCode;
        let isCodeUnique = false;
        while (!isCodeUnique) {
          newCode = Math.random().toString(36).substring(2, 8).toUpperCase();
          if (!existingCodes.has(newCode)) {
            isCodeUnique = true;
          }
        }
        
        userSheet.getRange(rowNum, 13).setValue(newCode);
        existingCodes.add(newCode); // Tambahkan ke Set agar tidak duplikat di iterasi berikutnya
        generatedCount++;
      }
    });

    if (generatedCount > 0) {
      SpreadsheetApp.flush();
    }

    return { status: "success", message: `${generatedCount} kode sekolah baru berhasil dibuat.` };
  } catch (e) {
    Logger.log("bulkGenerateSchoolCodes_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memproses: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [KHUSUS TRIGGER & DENGAN PROPERTIES SERVICE] Menjalankan pembaruan cache akun pengguna.
 * Menyimpan hasil ke Sheet Cache dan PropertiesService.
 */
function runUserCacheUpdateTrigger() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const cacheSheet = ss.getSheetByName(SHEET_CACHE_AKUN);

    if (!userSheet || !cacheSheet) {
      Logger.log("runUserCacheUpdateTrigger: Sheet Pengguna atau Cache Akun tidak ditemukan.");
      return; 
    }

    if (cacheSheet.getLastRow() > 1) {
      cacheSheet.getRange(2, 1, cacheSheet.getLastRow() - 1, cacheSheet.getLastColumn()).clearContent();
    }

    // --- PERBAIKAN 1: BACA HINGGA KOLOM O (15) ---
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 15).getValues();
    const cacheData = [];

    usersData.forEach((row, index) => {
      const email = row[1];
      if (!email || row[0] === 'last_updated') return;

      let currentStudentCount = '-';
      const role = row[6];
      const spreadsheetId = row[5];

      if (role !== 'Superadmin' && spreadsheetId) {
        try {
          const studentSheet = SpreadsheetApp.openById(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
          currentStudentCount = studentSheet ? Math.max(0, studentSheet.getLastRow() - 1) : 0;
        } catch (e) {
          currentStudentCount = 'Error Akses';
        }
      }

      // --- PERBAIKAN 2: Simpan data dari kolom O (indeks 14) ---
      cacheData.push([
        email,            // 1
        row[3],           // 2. Nama Sekolah
        row[4],           // 3. Jenjang
        row[12],          // 4. Kode Sekolah
        row[7],           // 5. Status Akun
        row[8],           // 6. Batas Siswa
        currentStudentCount, // 7
        index + 2,        // 8. Nomor Baris
        role,             // 9. Role
        row[14] || 'TIDAK' // 10. FiturTerkunci dari kolom O
      ]);
    });

    if (cacheData.length > 0) {
      cacheSheet.getRange(2, 1, cacheData.length, cacheData[0].length).setValues(cacheData);
    }

    cacheSheet.appendRow(['last_updated', new Date().toISOString()]);

    try {
        const scriptProperties = PropertiesService.getScriptProperties();
        scriptProperties.setProperty('userManagementCache', JSON.stringify(cacheData));
        Logger.log('Cache Manajemen Akun berhasil disimpan ke PropertiesService.');
    } catch (e) {
        Logger.log('Gagal menyimpan cache Manajemen Akun ke PropertiesService: ' + e.message);
    }

  } catch(e) {
    Logger.log("Error pada runUserCacheUpdateTrigger: " + e.message);
  }
}

/**
 * [FUNGSI INTI BARU] Membangun ulang dan menyimpan data nilai ke sheet yang ditentukan.
 * Fungsi ini menangani data yang datang langsung dari input web.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet tujuan.
 * @param {Array<object>} mapelList Daftar mata pelajaran yang relevan untuk sheet ini.
 * @param {Array<object>} nilaiData Daftar objek nilai dari frontend.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveScoresToSheet(spreadsheetId, sheetName, mapelList, nilaiData) {
  try {
    const ss = getSpreadsheet(spreadsheetId); //
    let sheet = ss.getSheetByName(sheetName); //
    const headers = ["NISN", "Nama Lengkap", ...mapelList.map(m => m.kode)]; //

    // Buat sheet jika belum ada
    if (!sheet) {
      sheet = ss.insertSheet(sheetName); //
    }

    // 1. Dapatkan daftar siswa utama sebagai sumber kebenaran
    const students = getStudents(spreadsheetId); //
    if (!students || students.length === 0) {
      return { status: 'error', message: 'Tidak ada data siswa. Harap isi data siswa terlebih dahulu.' };
    }

    // 2. Ubah array nilai dari input menjadi Map untuk pencarian cepat
    const nilaiDataMap = new Map();
    nilaiData.forEach(n => {
      if (n.nisn) {
        nilaiDataMap.set(n.nisn.toString(), n.scores);
      }
    });

    // 3. Bangun kembali seluruh data yang akan ditulis
    const finalDataToWrite = [];
    students.forEach(student => {
      const nisn = student.nisn.toString();
      const studentScores = nilaiDataMap.get(nisn) || {}; // Ambil skor dari input, atau objek kosong jika tidak ada
      const newRow = [student.nisn, student.nama];

      mapelList.forEach(mapel => {
        // Gunakan nilai dari input jika ada, jika tidak, biarkan kosong
        const score = studentScores[mapel.kode] !== undefined ? studentScores[mapel.kode] : '';
        newRow.push(score);
      });
      finalDataToWrite.push(newRow);
    });

    // 4. Hapus semua data lama dan tulis kembali dengan data yang baru dan lengkap
    sheet.clear();
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold"); //
    sheet.getRange("A:A").setNumberFormat('@'); //
    
    if (finalDataToWrite.length > 0) {
      sheet.getRange(2, 1, finalDataToWrite.length, headers.length).setValues(finalDataToWrite); //
    }

    SpreadsheetApp.flush();
    return { status: 'success', message: `Data nilai untuk sheet '${sheetName}' berhasil disimpan.` }; //

  } catch (e) {
    Logger.log(e);
    return { status: 'error', message: `Gagal menyimpan data: ${e.message}` }; //
  }
}

// Tambahkan dua fungsi baru ini di bagian mana saja di dalam file

/**
 * [BARU] Menerima dan menyimpan saran dari pengguna ke dalam sheet.
 * @param {string} userEmail Email pengguna yang mengirim.
 * @param {object} saranData Objek berisi {judul, penjelasan}.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function submitSaran(userEmail, saranData) {
  try {
    const { judul, penjelasan } = saranData;
    if (!userEmail || !judul || !penjelasan) {
      throw new Error("Data tidak lengkap.");
    }
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let saranSheet = ss.getSheetByName(SHEET_SARAN);

    if (!saranSheet) {
      saranSheet = ss.insertSheet(SHEET_SARAN);
      const headers = ["Saran ID", "Email Pengguna", "Tanggal", "Judul", "Pesan", "Status", "Balasan Admin", "Tanggal Balasan"];
      saranSheet.appendRow(headers);
      saranSheet.getRange("A1:H1").setFontWeight("bold");
    }

    const saranId = Utilities.getUuid();
    saranSheet.appendRow([
      saranId, userEmail, new Date(), judul, penjelasan, "Baru", "", ""
    ]);

    return { status: "success", message: "Saran Anda telah berhasil dikirim. Terima kasih atas masukannya!" };
  } catch (e) {
    Logger.log("submitSaran Error: " + e.message);
    return { status: "error", message: "Gagal mengirim saran: " + e.message };
  }
}

/**
 * [BARU] Mengambil riwayat saran dan balasan untuk pengguna tertentu.
 * @param {string} userEmail Email pengguna yang sedang login.
 * @returns {Array<object>} Array objek riwayat saran.
 */
function getSaranForUser(userEmail) {
  try {
    if (!userEmail) return [];

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return [];
    }
    
    const data = saranSheet.getDataRange().getValues();
    const headers = data.shift(); // Ambil header untuk mapping
    const emailIndex = headers.indexOf("Email Pengguna");

    const history = data
      .filter(row => row[emailIndex] === userEmail)
      .map(row => ({
        id: row[headers.indexOf("Saran ID")],
        tanggal: row[headers.indexOf("Tanggal")].toISOString(),
        judul: row[headers.indexOf("Judul")],
        pesan: row[headers.indexOf("Pesan")],
        status: row[headers.indexOf("Status")],
        balasanAdmin: row[headers.indexOf("Balasan Admin")],
        tanggalBalasan: row[headers.indexOf("Tanggal Balasan")] ? row[headers.indexOf("Tanggal Balasan")].toISOString() : null
      }))
      .sort((a, b) => new Date(b.tanggal) - new Date(a.tanggal)); // Urutkan dari terbaru

    return history;
  } catch (e) {
    Logger.log("getSaranForUser Error: " + e.message);
    return []; // Kembalikan array kosong jika error
  }
}

// File: Kode.gs.html

/**
 * [SUPERADMIN] Mengambil semua saran yang masuk dari semua pengguna.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek data saran, diurutkan berdasarkan status dan tanggal.
 */
function getAllSaran_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return [];
    }

    const data = saranSheet.getDataRange().getValues();
    const headers = data.shift();
    
    const history = data.map(row => ({
        id: row[headers.indexOf("Saran ID")],
        userEmail: row[headers.indexOf("Email Pengguna")],
        tanggal: row[headers.indexOf("Tanggal")].toISOString(),
        judul: row[headers.indexOf("Judul")],
        pesan: row[headers.indexOf("Pesan")],
        status: row[headers.indexOf("Status")],
        balasanAdmin: row[headers.indexOf("Balasan Admin")],
        tanggalBalasan: row[headers.indexOf("Tanggal Balasan")] ? row[headers.indexOf("Tanggal Balasan")].toISOString() : null
    }));
    
    // Urutkan: Tampilkan status "Baru" di atas, lalu urutkan berdasarkan tanggal terbaru
    history.sort((a, b) => {
        if (a.status === 'Baru' && b.status !== 'Baru') return -1;
        if (a.status !== 'Baru' && b.status === 'Baru') return 1;
        return new Date(b.tanggal) - new Date(a.tanggal);
    });

    return history;
  } catch (e) {
    Logger.log("getAllSaran_Superadmin Error: " + e.message);
    throw new Error("Gagal mengambil data saran: " + e.message);
  }
}

/**
 * [SUPERADMIN] Menyimpan balasan untuk sebuah saran dan mengubah statusnya.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {object} replyData - Objek berisi {saranId, balasanText}.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function replyToSaran_Superadmin(adminEmail, replyData) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try {
    const { saranId, balasanText } = replyData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);

    const idColumn = saranSheet.getRange("A2:A").getValues().flat();
    const rowIndex = idColumn.findIndex(id => id === saranId);

    if (rowIndex === -1) {
      throw new Error("Saran tidak ditemukan.");
    }
    const rowToUpdate = rowIndex + 2;

    // Update kolom Status, Balasan, Tanggal Balasan, dan Status Baca Pengguna
    saranSheet.getRange(rowToUpdate, 6, 1, 4).setValues([
        ['Dibalas', balasanText, new Date(), 'Belum Dibaca']
    ]);

    return { status: "success", message: "Balasan berhasil dikirim." };
  } catch (e) {
    Logger.log("replyToSaran_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal mengirim balasan: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

// ===== AWAL FUNGSI BARU UNTUK BADGE SARAN =====

/**
 * [SUPERADMIN] Menghitung jumlah saran baru yang belum diproses.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {number} Jumlah saran dengan status "Baru".
 */
function getNewSaranCount_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    return 0;
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return 0;
    }
    // Hitung semua baris di kolom F (Status) yang nilainya "Baru"
    const statusColumn = saranSheet.getRange(2, 6, saranSheet.getLastRow() - 1, 1).getValues();
    return statusColumn.filter(row => row[0] === 'Baru').length;
  } catch (e) {
    Logger.log("getNewSaranCount_Superadmin Error: " + e.message);
    return 0;
  }
}

/**
 * [PENGGUNA] Menghitung jumlah balasan dari admin yang belum dibaca oleh pengguna.
 * @param {string} userEmail - Email pengguna yang sedang login.
 * @returns {number} Jumlah saran berstatus "Dibalas" dan "Belum Dibaca".
 */
function getUnreadRepliesCount_User(userEmail) {
  if (!userEmail) return 0;
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return 0;
    }
    // Ambil data: Email (B), Status (F), Status Baca (I)
    const data = saranSheet.getRange(2, 2, saranSheet.getLastRow() - 1, 8).getValues();
    let unreadCount = 0;
    data.forEach(row => {
      const email = row[0]; // Kolom B -> indeks 0
      const status = row[4]; // Kolom F -> indeks 4
      const statusBaca = row[7]; // Kolom I -> indeks 7
      if (email === userEmail && status === 'Dibalas' && statusBaca === 'Belum Dibaca') {
        unreadCount++;
      }
    });
    return unreadCount;
  } catch (e) {
    Logger.log("getUnreadRepliesCount_User Error: " + e.message);
    return 0;
  }
}

/**
 * [PENGGUNA] Menandai semua balasan yang belum dibaca menjadi "Sudah Dibaca".
 * @param {string} userEmail - Email pengguna yang sedang login.
 * @returns {{status: string}} Hasil operasi.
 */
function markAllSaranRepliesAsRead_User(userEmail) {
  if (!userEmail) return { status: 'error' };
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return { status: 'no_data' };
    }
    const data = saranSheet.getRange(2, 1, saranSheet.getLastRow() - 1, 9).getValues();
    const rowsToUpdate = [];
    data.forEach((row, index) => {
      const email = row[1]; // Kolom B -> indeks 1
      const status = row[5]; // Kolom F -> indeks 5
      const statusBaca = row[8]; // Kolom I -> indeks 8
      if (email === userEmail && status === 'Dibalas' && statusBaca === 'Belum Dibaca') {
        // Tandai baris ini untuk diupdate
        rowsToUpdate.push(index + 2); // +2 karena indeks array mulai dari 0 dan data dari baris 2
      }
    });

    // Lakukan update dalam satu batch jika ada yang perlu diubah
    if (rowsToUpdate.length > 0) {
      rowsToUpdate.forEach(rowNum => {
        saranSheet.getRange(rowNum, 9).setValue('Sudah Dibaca'); // Kolom I
      });
    }
    return { status: 'success' };
  } catch (e) {
    Logger.log("markAllSaranRepliesAsRead_User Error: " + e.message);
    return { status: 'error' };
  }
}
// ===== AKHIR FUNGSI BARU UNTUK BADGE SARAN =====

// =================================================================
// [FITUR BARU] FUNGSI PENGATURAN KELULUSAN & TRANSKRIP
// =================================================================

/**
 * [BARU] Helper untuk mencari baris pengaturan atau membuatnya jika tidak ada.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - Objek sheet 'Pengaturan'.
 * @param {string} settingName - Nama pengaturan yang dicari (misal: "KKM Sekolah").
 * @returns {number} Nomor baris dari pengaturan tersebut.
 */
function findOrCreateSettingRow(sheet, settingName) {
    const data = sheet.getRange("A:A").getValues().flat();
    const rowIndex = data.indexOf(settingName);
    if (rowIndex !== -1) {
        return rowIndex + 1; // Mengembalikan nomor baris yang sudah ada
    } else {
        // Jika tidak ditemukan, tambahkan di baris baru dan kembalikan nomor baris terakhir
        sheet.appendRow([settingName, '']);
        return sheet.getLastRow();
    }
}

/**
 * [VERSI FINAL 2.1 - FIX PENYIMPANAN TANGGAL]
 * Menyimpan pengaturan kelulusan dan transkrip.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} settings Objek berisi { announcementDate, showTranscriptGlobal }.
 * @returns {object} Status penyimpanan.
 */
function saveGraduationSettings(spreadsheetId, settings) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        let sheet = ss.getSheetByName(SHEET_PENGATURAN);

        if (!sheet) {
            sheet = ss.insertSheet(SHEET_PENGATURAN);
            sheet.getRange("A1:B1").setValues([['Nama Pengaturan', 'Value']]).setFontWeight('bold');
        }
        
        // ---- AWAL PERBAIKAN PENTING ----
        // Kita tidak perlu lagi menggunakan 'new Date()'. 
        // Langsung simpan string tanggal ISO yang dikirim dari frontend.
        // Google Sheets akan secara otomatis mengenalinya sebagai tanggal.
        if (settings.announcementDate) {
            const row = findOrCreateSettingRow(sheet, "Tanggal Pengumuman Kelulusan");
            sheet.getRange(row, 2).setValue(settings.announcementDate);
        } else {
            // Jika tanggal dikosongkan, hapus nilainya di sheet
            const row = findOrCreateSettingRow(sheet, "Tanggal Pengumuman Kelulusan");
            sheet.getRange(row, 2).clearContent();
        }
        // ---- AKHIR PERBAIKAN PENTING ----

        if (settings.showTranscriptGlobal) {
            const row = findOrCreateSettingRow(sheet, "Tampilkan Transkrip Global");
            sheet.getRange(row, 2).setValue(settings.showTranscriptGlobal);
        }

        return { status: "success", message: "Pengaturan kelulusan berhasil disimpan." };
    } catch (e) {
        Logger.log("saveGraduationSettings Error: " + e.message);
        return { status: "error", message: "Gagal menyimpan pengaturan: " + e.message };
    }
}

/**
 * [BARU] Mengambil pengaturan kelulusan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi pengaturan.
 */
function getGraduationSettings(spreadsheetId) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_PENGATURAN);
        if (!sheet) return { announcementDate: null, showTranscriptGlobal: 'TIDAK' };

        const data = sheet.getDataRange().getValues();
        const settings = { announcementDate: null, showTranscriptGlobal: 'TIDAK' }; // Default values

        data.forEach(row => {
            if (row[0] === "Tanggal Pengumuman Kelulusan" && row[1]) {
                settings.announcementDate = new Date(row[1]).toISOString();
            }
            if (row[0] === "Tampilkan Transkrip Global" && row[1]) {
                settings.showTranscriptGlobal = row[1];
            }
        });
        return { status: 'success', settings: settings };
    } catch (e) {
        return { status: 'error', message: e.message };
    }
}

/**
 * [BARU] Mengatur visibilitas transkrip untuk siswa yang dipilih.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<string>} nisnList Array berisi NISN siswa yang dipilih.
 * @param {string} isVisible Status baru ('YA' atau 'TIDAK').
 * @returns {object} Status operasi.
 */
function setPerStudentTranscriptVisibility(spreadsheetId, nisnList, isVisible) {
    try {
        const sheet = getSpreadsheet(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
        const nisnColumnValues = sheet.getRange(2, 1, sheet.getLastRow() - 1, 1).getValues().flat();
        
        // PERBAIKAN DI SINI: Ubah dari 12 menjadi 13
        const visibilityColumnIndex = 13; // Kolom M

        nisnList.forEach(nisn => {
            const rowIndex = nisnColumnValues.indexOf(nisn.toString());
            if (rowIndex !== -1) {
                // rowIndex adalah 0-based dari data, baris aktual di sheet adalah rowIndex + 2
                sheet.getRange(rowIndex + 2, visibilityColumnIndex).setValue(isVisible);
            }
        });
        
        SpreadsheetApp.flush(); // Pastikan perubahan segera disimpan
        return { status: "success", message: `${nisnList.length} data siswa berhasil diupdate.` };
    } catch (e) {
        return { status: "error", message: "Gagal mengupdate visibilitas: " + e.message };
    }
}

/**
 * [SUPERADMIN] Menyimpan pengaturan kelulusan GLOBAL.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {object} settings - Objek berisi { announcementDate }.
 * @returns {object} Status penyimpanan.
 */
function saveGlobalGraduationSettings_Superadmin(adminEmail, settings) {
    if (!isSuperadmin(adminEmail)) {
        return { status: "error", message: "Akses ditolak." };
    }
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        let sheet = ss.getSheetByName(SHEET_PENGATURAN);

        if (!sheet) {
            sheet = ss.insertSheet(SHEET_PENGATURAN);
            sheet.getRange("A1:B1").setValues([['Nama Pengaturan', 'Value']]).setFontWeight('bold');
        }

        if (settings.announcementDate) {
            const row = findOrCreateSettingRow(sheet, "Tanggal Pengumuman Kelulusan Global");
            sheet.getRange(row, 2).setValue(settings.announcementDate);
        } else {
            const row = findOrCreateSettingRow(sheet, "Tanggal Pengumuman Kelulusan Global");
            sheet.getRange(row, 2).clearContent();
        }

        return { status: "success", message: "Pengaturan pengumuman global berhasil disimpan." };
    } catch (e) {
        Logger.log("saveGlobalGraduationSettings_Superadmin Error: " + e.message);
        return { status: "error", message: "Gagal menyimpan pengaturan: " + e.message };
    }
}

/**
 * [PUBLIC] Mengambil pengaturan kelulusan GLOBAL.
 * Fungsi ini dapat diakses tanpa login untuk menampilkan countdown.
 * @returns {object} Objek berisi pengaturan.
 */
function getGlobalGraduationSettings() {
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sheet = ss.getSheetByName(SHEET_PENGATURAN);
        if (!sheet) return { announcementDate: null };

        const data = sheet.getDataRange().getValues();
        const settings = { announcementDate: null }; 

        data.forEach(row => {
            if (row[0] === "Tanggal Pengumuman Kelulusan Global" && row[1]) {
                settings.announcementDate = new Date(row[1]).toISOString();
            }
        });
        return settings;
    } catch (e) {
        // Jika error, kembalikan null agar halaman login tetap tampil
        return { announcementDate: null };
    }
}

/**
 * [BARU] Menghapus aset dokumen tertentu (logo, ttd, atau stempel).
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @param {string} settingKey - Kunci pengaturan yang akan dihapus (misal: 'ID Logo Sekolah').
 * @returns {object} Status penghapusan.
 */
function deleteDocumentAsset(spreadsheetId, settingKey) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
      return { status: 'info', message: 'Tidak ada pengaturan untuk dihapus.' };
    }

    const settingRow = findOrCreateSettingRow(sheet, settingKey);
    const fileIdCell = sheet.getRange(settingRow, 2);
    const fileId = fileIdCell.getValue();

    if (fileId) {
      try {
        DriveApp.getFileById(fileId).setTrashed(true);
      } catch (e) {
        Logger.log(`File dengan ID ${fileId} tidak dapat dihapus (mungkin sudah dihapus manual): ${e.message}`);
      }
      fileIdCell.clearContent(); // Hapus ID dari sel
    }
    
    // Konversi nama kunci menjadi nama yang lebih ramah pengguna untuk pesan sukses
    const assetName = settingKey.replace('ID ', '').replace(' Sekolah', '');
    return { status: 'success', message: `${assetName} berhasil dihapus.` };

  } catch (e) {
    Logger.log('deleteDocumentAsset Error: ' + e.message);
    return { status: 'error', message: 'Gagal menghapus aset: ' + e.message };
  }
}

/**
 * [PUBLIC BARU] Mengambil pengaturan sekolah berdasarkan Kode Sekolah.
 * Fungsi ini digunakan untuk menampilkan countdown per sekolah sebelum login.
 * @param {string} kodeSekolah - Kode unik sekolah yang dimasukkan siswa.
 * @returns {object} Objek berisi nama sekolah dan tanggal pengumuman.
 */
function getSchoolSettingsByCode(kodeSekolah) {
  try {
    if (!kodeSekolah) {
      return { status: "error", message: "Kode Sekolah tidak boleh kosong." };
    }

    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    if (!userSheet || userSheet.getLastRow() < 2) {
      return { status: "error", message: "Sistem tidak dapat menemukan data sekolah." };
    }
    
    // Cari baris yang cocok dengan Kode Sekolah (kolom M, indeks 12)
    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
    const schoolRow = data.find(row => row[12] && row[12].toUpperCase() === kodeSekolah.toUpperCase());

    if (!schoolRow) {
      return { status: "error", message: "Kode Sekolah tidak valid atau tidak ditemukan." };
    }
    
    const spreadsheetId = schoolRow[5]; // Kolom F adalah Spreadsheet ID
    const namaSekolah = schoolRow[3];   // Kolom D adalah Nama Sekolah

    if (!spreadsheetId) {
      return { status: "error", message: "Konfigurasi untuk sekolah ini tidak lengkap." };
    }

    // Ambil pengaturan spesifik sekolah tersebut
    const gradSettingsResponse = getGraduationSettings(spreadsheetId);
    const gradSettings = gradSettingsResponse.settings || { announcementDate: null };

    // [MODIFIKASI] Panggil getDocumentSettings untuk mendapatkan logo
    const docSettingsResponse = getDocumentSettings(spreadsheetId);
    const docSettings = docSettingsResponse.settings || {};

    return {
      status: "success",
      namaSekolah: namaSekolah,
      announcementDate: gradSettings.announcementDate,
      portalLogo: docSettings.portalLogo || null
    };

  } catch (error) {
    Logger.log("getSchoolSettingsByCode Error: " + error.message);
    return { status: "error", message: "Terjadi kesalahan pada server saat memeriksa kode." };
  }
}

// ===== AWAL FITUR BARU: PENGATURAN KOP SURAT =====

// ===== AWAL DARI KODE BARU UNTUK PENYIMPANAN GAMBAR DI DRIVE =====

/**
 * [BARU] Helper untuk mencari atau membuat folder 'Aset Aplikasi' di Google Drive
 * tempat spreadsheet pengguna berada.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {DriveApp.Folder} Objek folder aset.
 */
function getOrCreateAssetFolder(spreadsheetId) {
  try {
    const userSpreadsheetFile = DriveApp.getFileById(spreadsheetId);
    const parentFolder = userSpreadsheetFile.getParents().next();
    const assetFolderName = `_Aset Aplikasi Ijazah [JANGAN DIHAPUS]`;
    
    let assetFolderIterator = parentFolder.getFoldersByName(assetFolderName);

    if (assetFolderIterator.hasNext()) {
      return assetFolderIterator.next();
    } else {
      return parentFolder.createFolder(assetFolderName);
    }
  } catch (e) {
    Logger.log(`Gagal mendapatkan folder induk untuk SS ID: ${spreadsheetId}. Membuat di Root. Error: ${e.message}`);
    const rootFolder = DriveApp.getRootFolder();
    const fallbackFolderName = `_Aset Aplikasi Ijazah - ${spreadsheetId}`;
    let fallbackFolderIterator = rootFolder.getFoldersByName(fallbackFolderName);
    if (fallbackFolderIterator.hasNext()) {
      return fallbackFolderIterator.next();
    } else {
      return rootFolder.createFolder(fallbackFolderName);
    }
  }
}

/**
 * [VERSI BARU] Menyimpan gambar ke Google Drive dan menyimpan ID filenya ke sheet Pengaturan.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @param {object} settings - Objek berisi data gambar Base64 { logo, signature, stamp }.
 * @returns {object} Status penyimpanan.
 */
function saveDocumentSettings(spreadsheetId, settings) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
        sheet = ss.insertSheet(SHEET_PENGATURAN);
        sheet.appendRow(['Nama Pengaturan', 'Value']);
    }

    const assetFolder = getOrCreateAssetFolder(spreadsheetId);

    // Helper untuk menyimpan satu file
    const saveFile = (settingKey, base64Data, fileName) => {
      if (!base64Data) return;

      const decoded = Utilities.base64Decode(base64Data.split(',')[1]);
      const blob = Utilities.newBlob(decoded, MimeType.PNG, fileName);
      
      // Hapus file lama jika ada untuk mencegah penumpukan file
      const oldFileIdRow = findOrCreateSettingRow(sheet, settingKey);
      const oldFileId = sheet.getRange(oldFileIdRow, 2).getValue();
      if (oldFileId) {
        try { DriveApp.getFileById(oldFileId).setTrashed(true); } catch(e) { Logger.log(`File lama ${oldFileId} tidak ditemukan untuk dihapus.`);}
      }

      const newFile = assetFolder.createFile(blob);
      const newFileId = newFile.getId();
      sheet.getRange(oldFileIdRow, 2).setValue(newFileId);
    };

    saveFile('ID Logo Sekolah', settings.logo, 'logo_sekolah.png');
    saveFile('ID Tanda Tangan', settings.signature, 'tanda_tangan.png');
    saveFile('ID Stempel', settings.stamp, 'stempel_sekolah.png');
    saveFile('ID Logo Portal', settings.portalLogo, 'logo_portal.png');
    saveFile('ID Header Kustom', settings.customHeader, 'header_kustom.png');

    return { status: 'success', message: 'Pengaturan kop surat dan tanda tangan berhasil disimpan.' };
  } catch (e) {
    Logger.log('saveDocumentSettings Error: ' + e.message);
    return { status: 'error', message: 'Gagal menyimpan pengaturan dokumen: ' + e.message };
  }
}

/**
 * [VERSI BARU] Mengambil ID file dari sheet Pengaturan, lalu mengambil data gambar
 * dari Google Drive dan mengubahnya menjadi Base64.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {object} Objek berisi data gambar Base64.
 */
/**
 * [VERSI BARU] Mengambil ID file dari sheet Pengaturan, lalu mengambil data gambar
 * dari Google Drive dan mengubahnya menjadi Base64.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {object} Objek berisi data gambar Base64.
 */
function getDocumentSettings(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    // [PERBAIKAN UTAMA] Pastikan semua properti diinisialisasi sebagai null
    const settings = { logo: null, signature: null, stamp: null, portalLogo: null, customHeader: null };
    if (!sheet) return { status: 'success', settings: settings };
    
    const data = sheet.getDataRange().getValues();
    
    const settingsMap = new Map(data.map(row => [row[0], row[1]]));

    const getBase64 = (fileId) => {
      if (!fileId) return null;
      try {
        const file = DriveApp.getFileById(fileId);
        return `data:image/png;base64,${Utilities.base64Encode(file.getBlob().getBytes())}`;
      } catch (e) {
        Logger.log(`Gagal mengambil file gambar dengan ID ${fileId}: ${e.message}`);
        return null;
      }
    };
    
    // Ambil nilai untuk setiap pengaturan
    settings.logo = getBase64(settingsMap.get('ID Logo Sekolah'));
    settings.signature = getBase64(settingsMap.get('ID Tanda Tangan'));
    settings.stamp = getBase64(settingsMap.get('ID Stempel'));
    settings.portalLogo = getBase64(settingsMap.get('ID Logo Portal'));
    settings.customHeader = getBase64(settingsMap.get('ID Header Kustom'));

    return { status: 'success', settings: settings };
  } catch (e) {
    Logger.log('getDocumentSettings Error: ' + e.message);
    return { status: 'error', settings: {} };
  }
}

//=================================================================
// [BARU] FUNGSI UNTUK VALIDASI QR CODE
//=================================================================

// GANTI FUNGSI LAMA DENGAN INI DI Kode.gs.html

/**
 * [VERSI BARU - SUPER CEPAT] Membuat token validasi yang aman menggunakan schoolCode.
 * @param {string} nisn - NISN siswa.
 * @param {string} schoolCode - Kode unik sekolah yang lebih pendek.
 * @returns {string} Token JWT yang self-contained dan lebih pendek.
 */
function generateValidationToken(nisn, schoolCode) {
    const SECRET_KEY = PropertiesService.getScriptProperties().getProperty('JWT_SECRET');
    if (!SECRET_KEY) {
        throw new Error("Kunci rahasia JWT tidak diatur di Properti Skrip.");
    }

    const header = { "alg": "HS256", "typ": "JWT" };
    
    // PAYLOAD SEKARANG MENGGUNAKAN 'code' YANG PENDEK, BUKAN 'ssId' YANG PANJANG
    const payload = {
      "nisn": nisn,
      "code": schoolCode, // <-- Perubahan utama di sini
      "exp": Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60) // Expired dalam 1 tahun
    };

    const base64UrlEncode = (data) => {
      const jsonString = JSON.stringify(data);
      return Utilities.base64EncodeWebSafe(jsonString).replace(/=/g, '');
    };
    
    const encodedHeader = base64UrlEncode(header);
    const encodedPayload = base64UrlEncode(payload);

    const signatureInput = `${encodedHeader}.${encodedPayload}`;
    const signatureBytes = Utilities.computeHmacSignature(
        Utilities.MacAlgorithm.HMAC_SHA_256, signatureInput, SECRET_KEY, Utilities.Charset.UTF_8
    );
    const encodedSignature = Utilities.base64EncodeWebSafe(signatureBytes).replace(/=/g, '');

    return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
}

// GANTI FUNGSI LAMA DENGAN INI DI Kode.gs.html

/**
 * [VERSI BARU - SUPER CEPAT] Mengambil data validasi dengan mencari ssId berdasarkan schoolCode dari token.
 */
function getValidationData(token) {
    try {
        const SECRET_KEY = PropertiesService.getScriptProperties().getProperty('JWT_SECRET');
        if (!SECRET_KEY) {
            throw new Error("Kunci rahasia server tidak dikonfigurasi.");
        }

        const parts = token.split('.');
        if (parts.length !== 3) return { status: 'error', message: 'Format token tidak valid.' };
        
        // Verifikasi signature (tidak ada perubahan di sini)
        const signatureInput = `${parts[0]}.${parts[1]}`;
        const expectedSignatureBytes = Utilities.computeHmacSignature(Utilities.MacAlgorithm.HMAC_SHA_256, signatureInput, SECRET_KEY, Utilities.Charset.UTF_8);
        const expectedSignature = Utilities.base64EncodeWebSafe(expectedSignatureBytes).replace(/=/g, '');
        if (expectedSignature !== parts[2]) {
            return { status: 'error', message: 'Token tidak asli atau telah dimodifikasi.' };
        }

        const decodedPayload = Utilities.newBlob(Utilities.base64DecodeWebSafe(parts[1])).getDataAsString();
        const payload = JSON.parse(decodedPayload);

        if (payload.exp < Math.floor(Date.now() / 1000)) {
            return { status: 'error', message: 'Token validasi telah kedaluwarsa.' };
        }
        
        // === PERUBAHAN UTAMA DIMULAI DI SINI ===
        // 1. Ambil 'code' (Kode Sekolah) dari payload
        const schoolCode = payload.code;
        const nisn = payload.nisn;

        // 2. Cari baris pengguna di sheet 'Data Pengguna' berdasarkan 'code'
        const masterSs = SpreadsheetApp.getActiveSpreadsheet();
        const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
        const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
        const schoolRow = data.find(row => row[12] && row[12].toUpperCase() === schoolCode.toUpperCase());

        if (!schoolRow) {
          return { status: 'error', message: 'Kode sekolah di dalam token tidak ditemukan atau tidak valid.' };
        }
        
        // 3. Ambil 'spreadsheetId' dari baris yang ditemukan
        const spreadsheetId = schoolRow[5];
        // === PERUBAHAN UTAMA SELESAI ===

        // Lanjutkan proses seperti biasa menggunakan spreadsheetId yang sudah ditemukan
        const schoolData = getSchoolData(spreadsheetId);
        if (!schoolData) return { status: 'error', message: 'Data sekolah tidak dapat ditemukan.' };

        const student = getStudents(spreadsheetId).find(s => s.nisn === nisn);
        if (!student) return { status: 'error', message: 'Data siswa tidak ditemukan.' };
        
        const rekapIjazah = getSheetDataAsObject(spreadsheetId, SHEET_REKAP_IJAZAH);
        const studentRekap = rekapIjazah[student.nisn] || {};
        const rataRata = studentRekap['Rata-rata'] !== undefined ? parseFloat(studentRekap['Rata-rata']).toFixed(2) : 'N/A';
        
        return {
            status: 'success',
            data: {
                namaSekolah: schoolData.namaSekolah, nisn: student.nisn, namaLengkap: student.nama, rataRataIjazah: rataRata
            }
        };

    } catch (e) {
        Logger.log("getValidationData (JWT) Error: " + e.message);
        return { status: 'error', message: 'Token tidak valid atau rusak.' };
    }
}

/**
 * [VERSI FINAL - MENGGUNAKAN SHEET] Membuat QR code dengan kode pendek
 * yang disimpan di sheet "QR_Redirects" untuk skalabilitas.
 */
function getQrCodeAsBase64(nisn, spreadsheetId) {
  try {
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
    const schoolRow = data.find(row => row[5] === spreadsheetId);
    if (!schoolRow || !schoolRow[12]) {
      throw new Error("Kode Sekolah untuk QR Code tidak ditemukan.");
    }
    const schoolCode = schoolRow[12];

    // 1. Buat token JWT yang aman (tidak berubah)
    const fullToken = generateValidationToken(nisn, schoolCode);
    
    // 2. Siapkan sheet untuk menyimpan kode
    let qrSheet = masterSs.getSheetByName(SHEET_QR_REDIRECTS);
    if (!qrSheet) {
      qrSheet = masterSs.insertSheet(SHEET_QR_REDIRECTS);
      qrSheet.appendRow(['ShortCode', 'FullToken']);
    }

    // 3. Buat shortCode yang unik
    const existingCodes = qrSheet.getLastRow() > 1 ? qrSheet.getRange(2, 1, qrSheet.getLastRow() - 1, 1).getValues().flat() : [];
    let shortCode;
    let isUnique = false;
    while (!isUnique) {
      shortCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      if (!existingCodes.includes(shortCode)) {
        isUnique = true;
      }
    }

    // 4. Simpan pasangan kode ke dalam sheet, bukan Properti Skrip
    qrSheet.appendRow([shortCode, fullToken]);

    // 5. Buat URL pendek untuk QR Code
    const shortUrl = `${ScriptApp.getService().getUrl()}?v=${shortCode}`;
    
    // 6. Generate QR Code dari URL pendek tersebut
    const qrCodeApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(shortUrl)}&ecc=H`;
    const qrCodeBlob = UrlFetchApp.fetch(qrCodeApiUrl).getBlob();
    
    return Utilities.base64Encode(qrCodeBlob.getBytes());

  } catch (e) {
    Logger.log("Gagal membuat QR Code Base64: " + e.message);
    return null;
  }
}

/**
 * [VERSI FINAL] Membandingkan nilai JUMLAH ijazah yang dihitung secara live
 * dengan nilai JUMLAH yang tersimpan di sheet rekapitulasi untuk deteksi yang lebih akurat.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {{needsUpdate: boolean}} Objek yang berisi status apakah rekap perlu diperbarui.
 */
function checkRekapSyncStatus(spreadsheetId) {
  try {
    // 1. Ambil data rekap yang tersimpan saat ini
    const storedRekapData = getSheetDataAsObject(spreadsheetId, SHEET_REKAP_IJAZAH);

    // 2. Lakukan perhitungan live
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) return { needsUpdate: false }; 

    const mapel = getMapel(spreadsheetId);
    if (!mapel || mapel.length === 0) return { needsUpdate: false };

    const bobot = getBobot(spreadsheetId);
    const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang;
    if (!jenjang) return { needsUpdate: true }; 

    const semesterKeys = { MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'], MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'], MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil'] };
    const semestersForJenjang = semesterKeys[jenjang] || [];

    const sheetsToRead = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK, ...semestersForJenjang.flatMap(smKey => [`Rapor_Pengetahuan_${smKey}`, `Rapor_Keterampilan_${smKey}`])];
    const allData = {};
    sheetsToRead.forEach(sheetName => { allData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName); });

    // 3. Bandingkan nilai untuk setiap siswa
    for (const student of students) {
        const nisn = student.nisn.toString().trim();
        const storedStudentData = storedRekapData[nisn];
        
        // Jika data siswa tidak ada di rekap, berarti perlu update
        if (!storedStudentData) {
          Logger.log(`Siswa baru ditemukan (${nisn}), rekap perlu diupdate.`);
          return { needsUpdate: true };
        }

        let liveTotalNilaiIjazah = 0;

        mapel.forEach(m => {
            const kode = m.kode;
            const nilaiUM = parseFloat((allData[SHEET_NILAI_UJIAN_MADRASAH][nisn] || {})[kode]);
            const nilaiUP = parseFloat((allData[SHEET_NILAI_UJIAN_PRAKTEK][nisn] || {})[kode]);

            let rataUjian = null;
            if (!isNaN(nilaiUM) && !isNaN(nilaiUP)) rataUjian = (nilaiUM + nilaiUP) / 2;
            else if (!isNaN(nilaiUM)) rataUjian = nilaiUM;
            else if (!isNaN(nilaiUP)) rataUjian = nilaiUP;
            
            let totalNilaiRapor = 0;
            let semesterCount = 0;
            semestersForJenjang.forEach(smKey => {
                const nilaiP = parseFloat(((allData[`Rapor_Pengetahuan_${smKey}`] || {})[nisn] || {})[kode]);
                const nilaiK = parseFloat(((allData[`Rapor_Keterampilan_${smKey}`] || {})[nisn] || {})[kode]);
                if (!isNaN(nilaiP) && !isNaN(nilaiK)) { totalNilaiRapor += (nilaiP + nilaiK) / 2; semesterCount++; }
                else if (!isNaN(nilaiP)) { totalNilaiRapor += nilaiP; semesterCount++; }
                else if (!isNaN(nilaiK)) { totalNilaiRapor += nilaiK; semesterCount++; }
            });
            const rataRapor = semesterCount > 0 ? totalNilaiRapor / semesterCount : null;

            if (rataUjian !== null || rataRapor !== null) {
                const finalRataUjian = rataUjian !== null ? rataUjian : 0;
                const finalRataRapor = rataRapor !== null ? rataRapor : 0;
                const nilaiIjazah = (finalRataUjian * (bobot.bobotUjian / 100)) + (finalRataRapor * (bobot.bobotRapor / 100));
                // Nilai total adalah penjumlahan dari setiap nilai ijazah yang DIBULATKAN
                liveTotalNilaiIjazah += Math.round(nilaiIjazah);
            }
        });
        
        // [PERUBAHAN UTAMA] Bandingkan nilai 'Jumlah' (bilangan bulat)
        const storedTotal = parseInt(storedStudentData['Jumlah']) || 0;

        if (liveTotalNilaiIjazah !== storedTotal) {
            Logger.log(`Data tidak sinkron untuk NISN ${nisn}. Live Total: ${liveTotalNilaiIjazah}, Stored Total: ${storedTotal}`);
            return { needsUpdate: true }; // Ditemukan perbedaan, langsung hentikan dan kirim status
        }
    }
    
    // Jika loop selesai tanpa menemukan perbedaan, data sudah sinkron
    return { needsUpdate: false };
  } catch (e) {
    Logger.log("Error di checkRekapSyncStatus: " + e.message);
    return { needsUpdate: true }; // Jika terjadi error, lebih aman untuk menampilkan notifikasi
  }
}

// ===== AWAL KODE BARU UNTUK DATABASE WILAYAH DARI SHEET =====

// HAPUS FUNGSI getWilayahData_, getProvinsiList, getKabupatenList, dll. LAMA
// GANTI DENGAN SATU FUNGSI BARU INI

function getWilayahData() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Data Wilayah"); // Pastikan nama sheet sudah benar
    if (!sheet) {
      throw new Error("Sheet 'Data Wilayah' tidak ditemukan.");
    }
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 5).getValues(); // Ambil dari baris 2
    
    // Kelompokkan data untuk mempermudah frontend
    const wilayah = {
      provinsi: {},
      kodepos: {}
    };

    data.forEach(row => {
      const [prov, kab, kec, kel, pos] = row;
      
      if (!wilayah.provinsi[prov]) wilayah.provinsi[prov] = {};
      if (!wilayah.provinsi[prov][kab]) wilayah.provinsi[prov][kab] = {};
      if (!wilayah.provinsi[prov][kab][kec]) wilayah.provinsi[prov][kab][kec] = [];
      
      wilayah.provinsi[prov][kab][kec].push(kel);
      
      // Buat peta kodepos untuk pencarian cepat
      const key = `${prov}-${kab}-${kec}-${kel}`;
      wilayah.kodepos[key] = pos;
    });

    return { status: 'success', data: wilayah };

  } catch (e) {
    Logger.log("Error di getWilayahData: " + e.message);
    return { status: 'error', message: e.message };
  }
}

// Fungsi yang akan dipanggil dari frontend untuk mendapatkan daftar provinsi unik
function getProvinsiList() {
  try {
    const data = getWilayahData_();
    const provinsiSet = new Set(data.map(item => item.provinsi));
    return [...provinsiSet].sort();
  } catch (e) {
    return { error: e.message };
  }
}

// Fungsi untuk mendapatkan daftar kabupaten berdasarkan provinsi
function getKabupatenList(provinsi) {
  try {
    const data = getWilayahData_();
    const kabupatenSet = new Set(
      data
        .filter(item => item.provinsi === provinsi)
        .map(item => item.kabupaten)
    );
    return [...kabupatenSet].sort();
  } catch (e) {
    return { error: e.message };
  }
}

// Fungsi untuk mendapatkan daftar kecamatan berdasarkan kabupaten
function getKecamatanList(provinsi, kabupaten) {
  try {
    const data = getWilayahData_();
    const kecamatanSet = new Set(
      data
        .filter(item => item.provinsi === provinsi && item.kabupaten === kabupaten)
        .map(item => item.kecamatan)
    );
    return [...kecamatanSet].sort();
  } catch (e) {
    return { error: e.message };
  }
}

// Fungsi untuk mendapatkan daftar kelurahan berdasarkan kecamatan
function getKelurahanList(provinsi, kabupaten, kecamatan) {
  try {
    const data = getWilayahData_();
    const kelurahanData = data
      .filter(item => item.provinsi === provinsi && item.kabupaten === kabupaten && item.kecamatan === kecamatan)
      .map(item => ({ nama: item.kelurahan, kodepos: item.kodepos }));
    return kelurahanData.sort((a, b) => a.nama.localeCompare(b.nama));
  } catch (e) {
    return { error: e.message };
  }
}

// ===== AWAL KODE FITUR LOCK & DONASI =====

// --- FUNGSI UNTUK SUPERADMIN ---

/**
 * [SUPERADMIN] Mengunci atau membuka fitur untuk pengguna tertentu.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {string} targetUserEmail - Email pengguna yang akan diubah statusnya.
 * @param {boolean} isLocked - true untuk mengunci, false untuk membuka.
 * @returns {object} Hasil operasi.
 */
function setFiturLock_Superadmin(adminEmail, targetUserEmail, isLocked) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const emailColumn = userSheet.getRange("B2:B").getValues().flat();
    const userIndex = emailColumn.findIndex(email => email && email.toLowerCase() === targetUserEmail.toLowerCase());

    if (userIndex === -1) {
      throw new Error("Pengguna tidak ditemukan.");
    }
    const rowToUpdate = userIndex + 2;
    // Asumsi kolom FiturTerkunci adalah kolom ke-15 (O)
    userSheet.getRange(rowToUpdate, 15).setValue(isLocked ? 'YA' : 'TIDAK');
    
    const action = isLocked ? "dikunci" : "dibuka";
    return { status: "success", message: `Fitur untuk akun ${targetUserEmail} berhasil ${action}.` };
  } catch (e) {
    Logger.log("setFiturLock_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal mengubah status fitur: " + e.message };
  }
}

/**
 * [SUPERADMIN] Mengambil daftar semua donasi yang masuk.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {Array<object>} Daftar donasi.
 */
function getDonasiList_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data Donasi");
    if (!sheet || sheet.getLastRow() < 2) return [];
    
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    return data.map(row => ({
      id: row[0],
      tanggal: row[1].toISOString(),
      email: row[2],
      namaSekolah: row[3],
      fileId: row[4],
      fileUrl: row[5],
      status: row[6]
    })).sort((a, b) => new Date(b.tanggal) - new Date(a.tanggal));
  } catch (e) {
    Logger.log("getDonasiList_Superadmin Error: " + e.message);
    return [];
  }
}

/**
 * [SUPERADMIN - DIPERBARUI] Memverifikasi donasi, membuka kunci fitur, DAN menaikkan limit siswa.
 * @param {string} adminEmail - Email Superadmin.
 * @param {string} donasiId - ID donasi yang akan diverifikasi.
 * @param {string} targetUserEmail - Email pengguna yang fiturnya akan dibuka.
 * @returns {object} Hasil operasi.
 */
function verifyDonasi_Superadmin(adminEmail, donasiId, targetUserEmail) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    
    // 1. Ubah status di sheet Data Donasi
    const donasiSheet = ss.getSheetByName("Data Donasi");
    const idColumn = donasiSheet.getRange("A2:A").getValues().flat();
    const donasiRowIndex = idColumn.findIndex(id => id === donasiId);

    if (donasiRowIndex === -1) throw new Error("Donasi tidak ditemukan.");
    
    donasiSheet.getRange(donasiRowIndex + 2, 7).setValue("Terverifikasi");

    // --- AWAL MODIFIKASI ---

    // 2. Temukan pengguna di sheet 'Data Pengguna' untuk update limit
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const userEmailColumn = userSheet.getRange("B2:B").getValues().flat();
    const userRowIndex = userEmailColumn.findIndex(email => email && email.toLowerCase() === targetUserEmail.toLowerCase());

    if (userRowIndex !== -1) {
        const userRowToUpdate = userRowIndex + 2;
        // Kolom I (indeks 9) adalah 'Batas Siswa'
        userSheet.getRange(userRowToUpdate, 9).setValue(500);
    } else {
        Logger.log(`Peringatan: Pengguna ${targetUserEmail} tidak ditemukan untuk update limit saat verifikasi donasi.`);
    }

    // 3. Buka kunci fitur pengguna (fungsi ini sudah ada)
    const unlockResult = setFiturLock_Superadmin(adminEmail, targetUserEmail, false);
    if (unlockResult.status === 'error') throw new Error(unlockResult.message);
    
    // --- AKHIR MODIFIKASI ---

    return { status: "success", message: `Donasi dari ${targetUserEmail} berhasil diverifikasi. Fitur telah dibuka dan limit siswa diatur ke 500.` };

  } catch (e) {
    return { status: "error", message: e.message };
  }
}

/**
 * [AKSI MASSAL SUPERADMIN] Mengunci atau membuka fitur premium untuk beberapa akun sekaligus.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {Array<number>} rowNumbers - Array berisi nomor baris akun yang akan diubah.
 * @param {boolean} isLocked - true untuk mengunci, false untuk membuka.
 * @returns {object} Hasil operasi.
 */
function bulkSetFiturLock_Superadmin(adminEmail, rowNumbers, isLocked) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  if (!rowNumbers || rowNumbers.length === 0) {
    return { status: "info", message: "Tidak ada akun yang dipilih." };
  }

  try {
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    const newValue = isLocked ? 'YA' : 'TIDAK';
    const lockColumn = 15; // Kolom N untuk 'FiturTerkunci'

    // Lakukan update untuk setiap baris yang dipilih
    rowNumbers.forEach(rowNum => {
      userSheet.getRange(rowNum, lockColumn).setValue(newValue);
    });

    const actionText = isLocked ? "dikunci" : "dibuka";
    return { status: "success", message: `${rowNumbers.length} akun berhasil ${actionText}.` };

  } catch (e) {
    Logger.log("bulkSetFiturLock_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memproses aksi massal: " + e.message };
  }
}


// --- FUNGSI UNTUK PENGGUNA & SISWA ---

/**
 * [HELPER] Fungsi pusat untuk memeriksa apakah fitur pengguna terkunci.
 * @param {string} email - Email pengguna atau spreadsheetId.
 * @returns {{isLocked: boolean, message: string}}
 */
function checkFiturLock(emailOrId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const data = userSheet.getRange("A2:O" + userSheet.getLastRow()).getValues(); // Baca hingga kolom O
    
    let userRow = data.find(row => row[1].toLowerCase() === emailOrId.toLowerCase() || row[5] === emailOrId);
    
    if (userRow) {
      const isLocked = userRow[14] === 'YA'; // Kolom O adalah indeks ke-14
      if (isLocked) {
        return { isLocked: true, message: "Fitur ini terkunci. Silakan lakukan donasi untuk membukanya." };
      }
    }
    return { isLocked: false, message: "" };
  } catch (e) {
    Logger.log("checkFiturLock Error: " + e.message);
    return { isLocked: false, message: "" }; // Default ke tidak terkunci jika ada error
  }
}

/**
 * [PUBLIC] Menerima data form donasi dan file bukti transfer.
 * @param {object} donationData - Data dari form { email, namaSekolah }.
 * @param {object} fileData - Objek file dari frontend.
 * @returns {object} Hasil penyimpanan.
 */
function simpanDonasi(donationData, fileData) {
  try {
    // 1. Buat folder 'Bukti Donasi' jika belum ada di root Drive Anda
    let folder;
    const folders = DriveApp.getFoldersByName("Bukti Donasi Aplikasi Ijazah");
    if (folders.hasNext()) {
      folder = folders.next();
    } else {
      folder = DriveApp.createFolder("Bukti Donasi Aplikasi Ijazah");
    }

    // 2. Simpan file
    const decoded = Utilities.base64Decode(fileData.content.split(',')[1]);
    const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); // Agar admin bisa lihat

    // 3. Simpan data ke sheet 'Data Donasi'
    const donasiSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data Donasi");
    donasiSheet.appendRow([
      Utilities.getUuid(),
      new Date(),
      donationData.email,
      donationData.namaSekolah,
      file.getId(),
      file.getUrl(),
      "Menunggu Verifikasi"
    ]);

    // --- AWAL KODE NOTIFIKASI EMAIL SUPERADMIN ---
    try {
      const superadminEmail = "syamsulbahri.agro27b@gmail.com"; // GANTI DENGAN EMAIL SUPERADMIN ANDA
      const subject = "[Aplikasi Ijazah] Konfirmasi Donasi Baru";
      const body = `
        <p>Halo Superadmin,</p>
        <p>Ada konfirmasi donasi baru yang masuk dari pengguna:</p>
        <ul>
          <li><b>Email Pengguna:</b> ${donationData.email}</li>
          <li><b>Nama Sekolah:</b> ${donationData.namaSekolah}</li>
          <li><b>Tanggal Konfirmasi:</b> ${new Date().toLocaleString('id-ID')}</li>
        </ul>
        <p>Bukti transfer dapat dilihat melalui link di panel Manajemen Donasi.</p>
        <p>Silakan masuk untuk melakukan verifikasi dan membuka fitur premium untuk pengguna tersebut.</p>
        <br>
        <p>Terima kasih.</p>
      `;
      MailApp.sendEmail(superadminEmail, subject, "", { htmlBody: body });
    } catch (e) {
      Logger.log("Gagal mengirim notifikasi email donasi ke Superadmin: " + e.message);
    }
    // --- AKHIR KODE NOTIFIKASI EMAIL SUPERADMIN ---

    return { status: "success", message: "Data donasi dan bukti transfer berhasil dikirim. Admin akan segera memverifikasinya. Terima kasih!" };
  } catch (e) {
    Logger.log("simpanDonasi Error: " + e.message);
    return { status: "error", message: "Gagal menyimpan data donasi: " + e.message };
  }
}

/**
 * [PENGGUNA] Memeriksa status donasi terakhir dari pengguna.
 * @param {string} userEmail - Email pengguna yang akan diperiksa.
 * @returns {object|null} Detail donasi jika ada yang menunggu, atau null jika tidak.
 */
function getDonationStatus_User(userEmail) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data Donasi");
    if (!sheet || sheet.getLastRow() < 2) return null;

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    // Cari dari bawah ke atas untuk mendapatkan data terbaru
    for (let i = data.length - 1; i >= 0; i--) {
      const row = data[i];
      // Cek email dan status
      if (row[2].toLowerCase() === userEmail.toLowerCase() && row[6] === "Menunggu Verifikasi") {
        return {
          id: row[0],
          fileUrl: row[5],
          status: row[6]
        };
      }
    }
    return null; // Tidak ada donasi yang menunggu dari pengguna ini
  } catch (e) {
    Logger.log("getDonationStatus_User Error: " + e.message);
    return null;
  }
}

/**
 * [PENGGUNA] Membatalkan pengajuan donasi dan menghapus file terkait.
 * @param {string} donationId - ID donasi yang akan dibatalkan.
 * @param {string} userEmail - Email pengguna untuk verifikasi kepemilikan.
 * @returns {object} Hasil operasi.
 */
function cancelDonation_User(donationId, userEmail) {
  if (!donationId || !userEmail) {
    return { status: "error", message: "Informasi tidak lengkap." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data Donasi");
    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn());
    const data = dataRange.getValues();
    
    const rowIndex = data.findIndex(row => row[0] === donationId);

    if (rowIndex === -1) {
      throw new Error("Data donasi tidak ditemukan.");
    }

    const rowData = data[rowIndex];
    const ownerEmail = rowData[2];
    const fileId = rowData[4];

    if (ownerEmail.toLowerCase() !== userEmail.toLowerCase()) {
      throw new Error("Anda tidak memiliki izin untuk membatalkan donasi ini.");
    }
    
    // Hapus file dari Google Drive
    if (fileId) {
      try {
        DriveApp.getFileById(fileId).setTrashed(true);
      } catch (driveError) {
        Logger.log(`Gagal menghapus file di Drive (ID: ${fileId}): ${driveError.message}`);
        // Tetap lanjutkan proses hapus data di sheet
      }
    }
    
    // Hapus baris dari sheet
    sheet.deleteRow(rowIndex + 2); // +2 karena data dimulai dari baris 2 dan indeks array dari 0

    return { status: "success", message: "Konfirmasi donasi berhasil dibatalkan." };

  } catch (e) {
    Logger.log("cancelDonation_User Error: " + e.message);
    return { status: "error", message: "Gagal membatalkan donasi: " + e.message };
  } finally {
    lock.releaseLock();
  }
}
// ===== AKHIR KODE FITUR LOCK & DONASI =====

/**
 * [MODIFIKASI FINAL v2.3] Memproses kelulusan dan pengarsipan untuk kelas yang dipilih.
 * Memperbaiki metode penyalinan data antar-spreadsheet untuk mengatasi error 'copyTo'.
 * @param {string} spreadsheetId ID spreadsheet pengguna.
 * @param {string} userEmail Email pengguna untuk pengiriman notifikasi.
 * @param {Array<string>} selectedKelasList Daftar kelas yang akan diluluskan.
 * @returns {object} Hasil dari proses pengarsipan.
 */
function prosesKelulusan(spreadsheetId, userEmail, selectedKelasList) {
  if (!selectedKelasList || selectedKelasList.length === 0) {
    return { status: 'error', message: 'Tidak ada kelas yang dipilih untuk diluluskan.' };
  }

  const FOLDER_ARSIP_NAME = "Arsip Aplikasi Ijazah";
  const now = new Date();
  const timestamp = Utilities.formatDate(now, Session.getScriptTimeZone(), "yyyy-MM-dd");
  let archiveFile = null;

  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const schoolName = ss.getSheetByName(SHEET_DATA_SEKOLAH).getRange("B2").getValue() || "Data Sekolah";
    const archiveFileName = `[ARSIP KELAS ${selectedKelasList.join(', ')} ${timestamp}] - ${schoolName}`;

    const archiveSs = SpreadsheetApp.create(archiveFileName);
    archiveFile = DriveApp.getFileById(archiveSs.getId());
    const defaultSheet = archiveSs.getSheets()[0];

    const fileInduk = DriveApp.getFileById(spreadsheetId);
    const folderInduk = fileInduk.getParents().next();
    let folderArsip = folderInduk.getFoldersByName(FOLDER_ARSIP_NAME);
    folderArsip = folderArsip.hasNext() ? folderArsip.next() : folderInduk.createFolder(FOLDER_ARSIP_NAME);
    archiveFile.moveTo(folderArsip);

    const allStudents = getStudents(spreadsheetId);
    const graduatingStudentsNisns = new Set(
      allStudents.filter(s => selectedKelasList.includes(s.kelas)).map(s => s.nisn)
    );

    const liveSheets = ss.getSheets();
    liveSheets.forEach(liveSheet => {
      const sheetName = liveSheet.getName();
      const newSheet = archiveSs.insertSheet(sheetName);
      const lastRow = liveSheet.getLastRow();
      if (lastRow === 0) return;

      // === AWAL PERBAIKAN UTAMA ===
      // Baca header dari sheet lama
      const headerRange = liveSheet.getRange(1, 1, 1, liveSheet.getLastColumn());
      const headerValues = headerRange.getValues();
      // Tulis header ke sheet baru
      newSheet.getRange(1, 1, 1, headerValues[0].length).setValues(headerValues).setFontWeight('bold');
      // === AKHIR PERBAIKAN UTAMA ===

      if (lastRow > 1) {
        const dataRange = liveSheet.getRange(2, 1, lastRow - 1, liveSheet.getLastColumn());
        const values = dataRange.getDisplayValues();
        let filteredValues;

        if (sheetName === SHEET_DATA_GURU) {
          filteredValues = values.map(row => {
            let newRow = [...row];
            newRow[1] = '******';
            newRow[2] = '******';
            return newRow;
          });
        } else {
          const isStudentDataSheet = sheetName.startsWith('Rapor_') || 
                                     [SHEET_DATA_SISWA, SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK, 
                                      SHEET_REKAP_UJIAN, SHEET_REKAP_RAPOR, SHEET_REKAP_IJAZAH].includes(sheetName);
          
          if (isStudentDataSheet) {
            filteredValues = values.filter(row => graduatingStudentsNisns.has(row[0]));
          } else {
            filteredValues = values;
          }
        }

        if (filteredValues && filteredValues.length > 0) {
          newSheet.getRange(2, 1, filteredValues.length, filteredValues[0].length).setValues(filteredValues);
        }
      }
    });

    archiveSs.deleteSheet(defaultSheet);

    const allSheetsLive = ss.getSheets();
    allSheetsLive.forEach(sheet => {
      const sheetName = sheet.getName();
      const isStudentDataSheet = sheetName.startsWith('Rapor_') || 
                                 [SHEET_DATA_SISWA, SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK, 
                                  SHEET_REKAP_UJIAN, SHEET_REKAP_RAPOR, SHEET_REKAP_IJAZAH].includes(sheetName);

      if (isStudentDataSheet && sheet.getLastRow() > 1) {
        const values = sheet.getRange(2, 1, sheet.getLastRow() - 1, 1).getDisplayValues();
        const rowsToDelete = [];
        values.forEach((row, index) => {
          if (graduatingStudentsNisns.has(row[0])) {
            rowsToDelete.push(index + 2);
          }
        });
        for (let i = rowsToDelete.length - 1; i >= 0; i--) {
          sheet.deleteRow(rowsToDelete[i]);
        }
      }
    });

    const urlArsip = archiveSs.getUrl();
    archiveFile.addEditor(userEmail);

    const subject = `Proses Kelulusan Aplikasi Ijazah Telah Selesai`;
    const body = `<p>Halo,</p>
      <p>Proses kelulusan dan pengarsipan data untuk kelas <b>${selectedKelasList.join(', ')}</b> dari sekolah <b>${schoolName}</b> telah berhasil.</p>
      <p>File arsip Anda dapat diakses melalui link berikut:</p>
      <p><a href="${urlArsip}" style="font-size: 16px; font-weight: bold;">Buka File Arsip</a></p>
      <p>Data siswa dari kelas tersebut telah dihapus dari aplikasi utama Anda. Harap simpan email ini dengan baik.</p>
      <br><p>Terima kasih.</p>`;
    MailApp.sendEmail(userEmail, subject, "", { htmlBody: body });

    return { status: 'success', message: 'Proses kelulusan & arsip berhasil! File telah disimpan dan link dikirim ke email Anda.', fileUrl: urlArsip };

  } catch (e) {
    Logger.log(`Proses Kelulusan Gagal: ${e.toString()}`);
    if (archiveFile) {
        try { DriveApp.getFileById(archiveFile.getId()).setTrashed(true); } catch (delErr) {}
    }
    return { status: 'error', message: `Terjadi kesalahan saat proses kelulusan: ${e.message}` };
  }
}

// Kode.gs: Fungsi baru untuk menyimpan dan mengambil pengaturan

/**
 * [MODIFIKASI] Menyimpan pengaturan cetak transkrip ke dalam sheet 'Pengaturan'
 * di spreadsheet pengguna.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @param {object} settings - Objek berisi pengaturan cetak.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function savePrintSettings(spreadsheetId, settings) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
        sheet = ss.insertSheet(SHEET_PENGATURAN);
        sheet.appendRow(['Nama Pengaturan', 'Value']);
    }

    // Menggunakan helper yang sudah ada untuk mencari atau membuat baris pengaturan
    const findAndSet = (key, value) => {
        const row = findOrCreateSettingRow(sheet, key);
        sheet.getRange(row, 2).setValue(value);
    };

    findAndSet('Cetak - Tahun Ajaran', settings.tahunAjaran);
    findAndSet('Cetak - Tempat TTD', settings.tempatTtd);
    findAndSet('Cetak - Tanggal TTD', settings.tanggalTtd);
    findAndSet('Cetak - Tampilkan QR', settings.showQRCode ? 'YA' : 'TIDAK'); // Simpan sebagai YA/TIDAK

    return { status: 'success', message: 'Pengaturan berhasil disimpan di spreadsheet.' };
  } catch (e) {
    Logger.log("savePrintSettings Error: " + e.message);
    return { status: 'error', message: 'Gagal menyimpan pengaturan ke spreadsheet.' };
  }
}

/**
 * [MODIFIKASI] Mengambil pengaturan cetak dari sheet 'Pengaturan'.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {{status: string, settings?: object}} Hasil operasi.
 */
function getPrintSettings(spreadsheetId) {
  // Fungsi ini dibuat agar bisa dipanggil dari Index.html (admin) dan Siswa.html (publik)
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    const settings = {
        tahunAjaran: '',
        tempatTtd: '',
        tanggalTtd: '',
        showQRCode: true 
    };

    if (sheet) {
        const data = sheet.getDataRange().getValues();
        const settingsMap = new Map(data.map(row => [row[0], row[1]]));
        
        settings.tahunAjaran = settingsMap.get('Cetak - Tahun Ajaran') || '';
        settings.tempatTtd = settingsMap.get('Cetak - Tempat TTD') || '';
        const tgl = settingsMap.get('Cetak - Tanggal TTD');
        settings.tanggalTtd = (tgl instanceof Date) ? Utilities.formatDate(tgl, Session.getScriptTimeZone(), "yyyy-MM-dd") : '';
        settings.showQRCode = settingsMap.get('Cetak - Tampilkan QR') !== 'TIDAK';
    }
    
    return { status: 'success', settings: settings };
  } catch (e) {
    Logger.log("getPrintSettings Error: " + e.message);
    return { status: 'error', message: 'Gagal memuat pengaturan.' };
  }
}

// GANTI FUNGSI buildValidationPage LAMA ANDA DENGAN VERSI FINAL INI

/**
 * [FUNGSI BARU - SUPER CEPAT] Membangun halaman validasi HTML lengkap secara dinamis.
 * Fungsi ini melakukan validasi di server SEBELUM mengirim HTML, menghilangkan
 * satu round-trip dan membuat proses terasa instan bagi pengguna.
 * @param {string} token - Token validasi yang diambil dari URL.
 * @returns {HtmlService.HtmlOutput} Halaman HTML yang siap ditampilkan.
 */
function buildValidationPage(token) {
  let validationResultHtml = '';
  let schoolName = 'Validasi Dokumen';
  const webAppUrl = ScriptApp.getService().getUrl();

  try {
    const validationResponse = getValidationData(token);
    if (validationResponse && validationResponse.status === 'success') {
      const data = validationResponse.data;
      schoolName = data.namaSekolah;
      
      validationResultHtml = `
        <p class="text-center text-gray-600 font-semibold mt-1 mb-6">${data.namaSekolah}</p>
        <div class="overflow-x-auto border rounded-lg">
          <table class="min-w-full text-left text-sm md:text-base">
             <thead class="bg-gray-50"><tr><th class="px-4 py-3 font-medium text-gray-600">Data</th><th class="px-4 py-3 font-medium text-gray-800">Informasi Siswa</th></tr></thead><tbody class="divide-y divide-gray-200"><tr class="border-b"><td class="px-4 py-3 text-gray-500">NISN</td><td class="px-4 py-3 font-bold text-gray-900">${data.nisn}</td></tr><tr class="border-b"><td class="px-4 py-3 text-gray-500">Nama Lengkap Siswa</td><td class="px-4 py-3 font-bold text-gray-900">${data.namaLengkap.toUpperCase()}</td></tr><tr><td class="px-4 py-3 text-gray-500">Nilai Rata-Rata Ijazah</td><td class="px-4 py-3 font-bold text-blue-600 text-lg">${data.rataRataIjazah}</td></tr></tbody>
          </table>
        </div>
        <div class="mt-6 p-3 bg-green-100 text-green-800 rounded-lg flex items-center justify-center gap-3">
          <svg class="w-6 h-6 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>
          <span class="font-semibold text-center">DATA TERVERIFIKASI DAN VALID</span>
        </div>
        <div class="mt-8">
            <button id="backToLoginBtn" class="inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition-colors shadow-md w-64 h-12">
                <span id="backBtnText">Kembali ke Halaman Login</span>
                <span id="backBtnSpinner" class="hidden loading-animation">Mengarahkan</span>
            </button>
        </div>
      `;
    } else {
      const message = validationResponse ? validationResponse.message : "Token tidak valid.";
      validationResultHtml = `
        <div class="mt-6 p-3 bg-red-100 text-red-800 rounded-lg flex items-center justify-center gap-3">
          <svg class="w-6 h-6 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>
          <span class="font-semibold text-center">VALIDASI GAGAL: ${message}</span>
        </div>
      `;
    }
  } catch (e) {
    validationResultHtml = `<div class="mt-6 p-3 bg-red-100 text-red-800 rounded-lg">Terjadi error internal: ${e.message}</div>`;
  }

  const html = `
    <!DOCTYPE html>
    <html lang="id">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Validasi Dokumen - ${schoolName}</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            .loading-animation::after { display: inline-block; animation: loading-dots 1.4s infinite; content: '.'; width: 1em; text-align: left; }
            @keyframes loading-dots { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }
        </style>
    </head>
    <body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
        <div class="w-full max-w-2xl mx-auto">
            <div class="bg-white rounded-lg shadow-xl p-6 md:p-8">
                <h1 class="text-xl md:text-2xl font-bold text-center text-gray-800">
                    Hasil Validasi Keaslian Dokumen
                </h1>
                <div id="validation-result" class="text-center mt-4">${validationResultHtml}</div>
                <p class="text-xs text-center text-gray-400 mt-8">
                    Aplikasi Pengolahan Nilai Ijazah by Syamsul Bahri
                </p>
            </div>
        </div>
        <script>
            // [PERUBAHAN] Menambahkan Javascript untuk menangani klik tombol
            window.addEventListener('load', () => {
                const backButton = document.getElementById('backToLoginBtn');
                if (backButton) {
                    backButton.addEventListener('click', function() {
                        this.disabled = true;
                        document.getElementById('backBtnText').classList.add('hidden');
                        document.getElementById('backBtnSpinner').classList.remove('hidden');
                        window.top.location.href = "${webAppUrl}";
                    });
                }
            });
        </script>
    </body>
    </html>
  `;
  
  return HtmlService.createHtmlOutput(html)
      .setTitle(`Validasi Dokumen - ${schoolName}`)
      .setFaviconUrl("https://i.imgur.com/CmVVVxB.png")
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}


// GANTI FUNGSI createErrorPage LAMA DENGAN VERSI BARU INI

/**
 * [BARU] Membuat halaman HTML error yang profesional dan informatif.
 * @param {string} title Judul besar yang akan ditampilkan.
 * @param {string} message Pesan penjelasan yang lebih detail.
 * @returns {HtmlService.HtmlOutput} Halaman HTML yang siap ditampilkan.
 */
function createErrorPage(title, message) {
  const webAppUrl = ScriptApp.getService().getUrl();

  const html = `
    <!DOCTYPE html>
    <html lang="id">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Error: ${title}</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            .loading-animation::after { display: inline-block; animation: loading-dots 1.4s infinite; content: '.'; width: 1em; text-align: left; }
            @keyframes loading-dots { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }
        </style>
    </head>
    <body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
        <div class="w-full max-w-lg mx-auto bg-white rounded-2xl shadow-xl p-8 text-center">
            
            <div class="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-red-100 mb-6">
                <svg class="h-10 w-10 text-red-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126z" />
                </svg>
            </div>

            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">${title}</h1>
            <p class="mt-3 text-gray-600">${message}</p>
            
            <div class="mt-8">
                <button id="backToLoginBtn" class="inline-flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition-colors shadow-md">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clip-rule="evenodd" />
                    </svg>
                    <span id="backBtnText">Kembali ke Halaman Utama</span>
                    <span id="backBtnSpinner" class="hidden loading-animation">Mengarahkan</span>
                </button>
            </div>

        </div>
        <script>
            window.addEventListener('load', () => {
                const backButton = document.getElementById('backToLoginBtn');
                if (backButton) {
                    backButton.addEventListener('click', function() {
                        this.disabled = true;
                        // Sembunyikan ikon dan teks normal
                        this.querySelector('svg').classList.add('hidden');
                        document.getElementById('backBtnText').classList.add('hidden');
                        // Tampilkan spinner
                        document.getElementById('backBtnSpinner').classList.remove('hidden');
                        window.top.location.href = "${webAppUrl}";
                    });
                }
            });
        </script>
    </body>
    </html>
  `;

  return HtmlService.createHtmlOutput(html)
      .setTitle(`Error: ${title}`)
      .setFaviconUrl("https://i.imgur.com/CmVVVxB.png")
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

// =================================================================
// [BARU] FUNGSI UNTUK PORTAL GURU
// =================================================================

// [PERUBAHAN] Ganti fungsi loginGuru() dengan versi ini
function loginGuru(schoolCode, username, password) {
    try {
        if (!schoolCode || !username || !password) { return { status: "error", message: "Kode Sekolah, Username, dan Password wajib diisi." }; }
    
        const masterSs = SpreadsheetApp.getActiveSpreadsheet();
        const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
        if (!userSheet) throw new Error("Sheet 'Data Pengguna' tidak ditemukan.");
        
        const users = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
        const schoolRow = users.find(row => row[12] && row[12].toUpperCase() === schoolCode.toUpperCase());
        
        if (!schoolRow) { return { status: "error", message: "Kode Sekolah tidak valid." }; }
        
        const lockStatus = checkFiturLock(schoolRow[1]);
        if (lockStatus.isLocked) {
          return { 
            status: "locked", 
            message: "Akses untuk guru dari sekolah ini ditangguhkan. Silakan hubungi administrator sekolah Anda." 
          };
        }
        
        const schoolSpreadsheetId = schoolRow[5];
        if (!schoolSpreadsheetId) { return { status: "error", message: "Konfigurasi sekolah ini tidak lengkap. Hubungi Admin." }; }
        
        const ss = SpreadsheetApp.openById(schoolSpreadsheetId);
        const guruSheet = ss.getSheetByName(SHEET_DATA_GURU);
        if (!guruSheet || guruSheet.getLastRow() < 2) { return { status: "error", message: "Data guru tidak ditemukan di sekolah ini." }; }
        
        const data = guruSheet.getRange(2, 1, guruSheet.getLastRow() - 1, 7).getValues();

        // --- AWAL PERUBAHAN LOGIKA VERIFIKASI ---
        let guruUserRow = null;
        for (const row of data) {
            if (row[1] === username) { // Temukan username yang cocok dulu
                const storedPasswordString = row[2].toString();
                // Gunakan fungsi verifyPassword yang sudah ada
                if (verifyPassword(password, storedPasswordString)) {
                    guruUserRow = row; // Jika password cocok, simpan data barisnya
                    break; // Hentikan loop karena guru sudah ditemukan
                }
            }
        }
        // --- AKHIR PERUBAHAN LOGIKA VERIFIKASI ---

        if (guruUserRow) {
            const mapelSheet = ss.getSheetByName(SHEET_MAPEL);
            const allMapel = mapelSheet.getLastRow() > 1 ? mapelSheet.getRange(2, 1, mapelSheet.getLastRow() - 1, 4).getValues() : [];
            const kodeMapelGuru = guruUserRow[3].split(',').map(k => k.trim());
            
            const kelasDiajarString = guruUserRow[6] || '';
            const kelasMap = new Map();

            if (kelasDiajarString) {
                const assignments = kelasDiajarString.split(',').map(a => a.trim()).filter(Boolean);
                assignments.forEach(assignment => {
                    const parts = assignment.split(':');
                    if (parts.length === 2) {
                        const mapelCode = parts[0].trim().toUpperCase();
                        const kelas = parts[1].trim();
                        if (!kelasMap.has(mapelCode)) {
                            kelasMap.set(mapelCode, []);
                        }
                        kelasMap.get(mapelCode).push(kelas);
                    }
                });
            }

            const mapelGuru = allMapel
                .filter(m => kodeMapelGuru.includes(m[0]))
                .map(m => ({ 
                    kode: m[0], 
                    nama: m[1], 
                    jenisUjian: m[3],
                    kelas: kelasMap.get(m[0]) || [] 
                }));
            
            const submissionStatus = getNilaiSubmissionStatus(schoolSpreadsheetId);

            return {
                status: "success",
                data: {
                    spreadsheetId: schoolSpreadsheetId,
                    nama: guruUserRow[0],
                    username: guruUserRow[1],
                    nip: guruUserRow[4], 
                    mapel: mapelGuru,
                    isSubmissionEnabled: submissionStatus.isEnabled
                }
            };
        } else {
            return { status: "error", message: "Username atau password salah." };
        }
    } catch (e) {
        Logger.log("loginGuru Error: " + e.message + " Stack: " + e.stack);
        return { status: "error", message: "Terjadi kesalahan server saat login." };
    }
}

/**
 * [PERBAIKAN FINAL] Mengambil daftar siswa dari spreadsheet ID tertentu.
 * Menggunakan .getDisplayValues() untuk memastikan NISN terbaca sebagai Teks.
 */
function getStudentsForGuru(spreadsheetId, className = null) { // Tambah parameter opsional
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const studentSheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (!studentSheet || studentSheet.getLastRow() < 2) return [];

    const data = studentSheet.getRange(2, 1, studentSheet.getLastRow() - 1, 15).getDisplayValues();
    
    let filteredData = data;
    // Jika nama kelas diberikan, filter data
    if(className) {
        // Kolom Kelas adalah kolom ke-14 (indeks 13)
        filteredData = data.filter(row => row[13] === className);
    }

    const students = filteredData.map(row => ({ 
        nisn: row[0],
        nama: row[3],
        nomorUjian: row[2],
        ruangUjian: row[14]
    }));

    // Baris di bawah ini yang mengurutkan berdasarkan nama telah dihapus.
    // students.sort((a, b) => a.nama.localeCompare(b.nama)); 

    return students;
}

/**
 * [DIPERBARUI] Mengambil daftar siswa dan jenjang dari spreadsheet ID tertentu.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @returns {object} Objek berisi daftar siswa dan jenjang.
 */
function getStudentsAndJenjangForGuru(spreadsheetId) {
  const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang;
  const students = getStudentsForGuru(spreadsheetId);
  return { students, jenjang };
}

/**
 * [DIPERBARUI] Menerima data nilai dan menyimpan ke sheet persetujuan di spreadsheet yang benar.
 * @param {object} payload - Objek berisi data nilai.
 * @returns {object} Hasil penyimpanan.
 */
function submitNilaiUntukPersetujuan(payload) {
  try {
    const { spreadsheetId, guru, mapelKode, tipeNilai, dataNilai } = payload;
    const ss = SpreadsheetApp.openById(spreadsheetId); // Buka spreadsheet sekolah yang benar
    const sheetName = "Pengajuan Nilai";
    let approvalSheet = ss.getSheetByName(sheetName);

    if (!approvalSheet) {
      approvalSheet = ss.insertSheet(sheetName);
      approvalSheet.appendRow(["ID Pengajuan", "Guru", "Mapel", "Tipe Nilai", "NISN", "Nama Siswa", "Nilai", "Tanggal Ajuan", "Status"]);
      approvalSheet.getRange("A1:I1").setFontWeight("bold");
    }
    
    const students = getStudentsForGuru(spreadsheetId); // Ambil siswa dari spreadsheet yang sama
    const studentMap = new Map(students.map(s => [s.nisn.toString(), s.nama]));
    const submissionId = Utilities.getUuid();
    const timestamp = new Date();

    const rowsToAppend = dataNilai.map(item => [
      submissionId, guru, mapelKode, tipeNilai, item.nisn,
      studentMap.get(item.nisn.toString()) || 'Siswa tidak ditemukan',
      item.nilai, timestamp, "Menunggu Persetujuan"
    ]);

    if (rowsToAppend.length > 0) {
        approvalSheet.getRange(approvalSheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
    }

    return { status: "success", message: "Nilai berhasil dikirim dan menunggu persetujuan admin." };
  } catch(e) {
    Logger.log("submitNilaiUntukPersetujuan Error: " + e.message);
    return { status: "error", message: "Gagal mengirim nilai: " + e.message };
  }
}

// =================================================================
// [BARU] FUNGSI UNTUK PERSETUJUAN NILAI OLEH ADMIN
// =================================================================

/**
 * [ADMIN - PERBAIKAN] Mengambil semua data dari sheet "Pengajuan Nilai".
 * Menggunakan getDisplayValues() untuk memastikan NISN dengan awalan nol terbaca sebagai teks.
 */
function getPengajuanNilaiUntukAdmin(spreadsheetId) {
    try {
        const ss = SpreadsheetApp.openById(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
        if (!sheet || sheet.getLastRow() < 2) return [];

        // === PERUBAHAN UTAMA ADA DI SINI ===
        // Menggunakan .getDisplayValues() untuk membaca semua data sebagai Teks.
        const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getDisplayValues();
        // ===================================
        
        const result = [];
        const originalData = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues(); // Untuk mengambil objek tanggal asli

        data.forEach((row, index) => {
            if (row[8] === "Menunggu Persetujuan") {
                result.push({
                    rowNum: index + 2,
                    guru: row[1],
                    mapelKode: row[2],
                    tipeNilai: row[3],
                    nisn: row[4], // NISN sekarang akan menjadi string "098", bukan angka 98.
                    namaSiswa: row[5],
                    nilai: row[6],
                    tanggal: originalData[index][7].toISOString() // Ambil tanggal sebagai objek Date lalu ubah ke ISO string
                });
            }
        });
        return result.sort((a, b) => new Date(b.tanggal) - new Date(a.tanggal));
    } catch (e) {
        Logger.log("getPengajuanNilaiUntukAdmin Error: " + e.message);
        throw new Error("Gagal mengambil data pengajuan nilai: " + e.message);
    }
}

// GANTI FUNGSI INI DI Kode.gs
/**
 * [PERBAIKAN FINAL] Memproses persetujuan nilai dengan penanganan untuk sheet yang belum ada.
 * Kini fungsi ini akan membuat header yang benar jika sheet tujuan baru dibuat.
 */
function processNilaiSubmission(spreadsheetId, rowNum, status) {
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);
    try {
        const ss = SpreadsheetApp.openById(spreadsheetId);
        const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
        
        const dataRowDisplay = approvalSheet.getRange(rowNum, 1, 1, 9).getDisplayValues()[0];

        if (dataRowDisplay[8] !== 'Menunggu Persetujuan') {
            return { status: "error", message: "Pengajuan ini sudah pernah diproses." };
        }

        approvalSheet.getRange(rowNum, 9).setValue(status);

        if (status === 'Disetujui') {
            const tipeNilaiLengkap = dataRowDisplay[3];
            const nisn = dataRowDisplay[4];
            const mapelKode = dataRowDisplay[2];
            const nilai = dataRowDisplay[6];

            let targetSheetName = '';
            const parts = tipeNilaiLengkap.split('_');

            if (parts[0] === 'ujian') {
                targetSheetName = (parts[1] === 'um') ? SHEET_NILAI_UJIAN_MADRASAH : SHEET_NILAI_UJIAN_PRAKTEK;
            } else if (parts[0] === 'rapor') {
                const semesterKey = `${parts[1]}_${parts[2]}`;
                const jenisNilai = parts[3] === 'peng' ? 'Pengetahuan' : 'Keterampilan';
                targetSheetName = `Rapor_${jenisNilai}_${semesterKey}`;
            }

            if (targetSheetName) {
                let targetSheet = ss.getSheetByName(targetSheetName);

                // ===== AWAL BLOK PERBAIKAN UTAMA =====
                if (!targetSheet) {
                    targetSheet = ss.insertSheet(targetSheetName);
                    
                    // Tentukan daftar mapel yang relevan untuk header
                    let mapelForSheet;
                    if (targetSheetName === SHEET_NILAI_UJIAN_MADRASAH) {
                        mapelForSheet = getMapelByJenis(spreadsheetId, 'madrasah');
                    } else if (targetSheetName === SHEET_NILAI_UJIAN_PRAKTEK) {
                        mapelForSheet = getMapelByJenis(spreadsheetId, 'praktek');
                    } else { // Untuk semua jenis sheet rapor
                        mapelForSheet = getMapel(spreadsheetId);
                    }
                    
                    const newHeaders = ["NISN", "Nama Lengkap", ...mapelForSheet.map(m => m.kode)];
                    targetSheet.getRange(1, 1, 1, newHeaders.length).setValues([newHeaders]).setFontWeight("bold");
                    SpreadsheetApp.flush(); // Paksa spreadsheet untuk menerapkan perubahan header
                }
                // ===== AKHIR BLOK PERBAIKAN UTAMA =====
                
                targetSheet.getRange("A:A").setNumberFormat('@');
                
                let studentRowIndex = -1;
                // Cek apakah sheet punya data sebelum mencoba membaca
                if (targetSheet.getLastRow() > 1) {
                    const nisnValues = targetSheet.getRange(2, 1, targetSheet.getLastRow() - 1, 1).getDisplayValues().flat();
                    studentRowIndex = nisnValues.findIndex(n => n === nisn);
                }
                
                let studentSheetRow;

                if (studentRowIndex !== -1) {
                    studentSheetRow = studentRowIndex + 2;
                } else {
                    const allStudentsData = getStudents(spreadsheetId);
                    const studentFullData = allStudentsData.find(s => s.nisn === nisn);
                    const newRowData = ["'" + nisn, studentFullData ? studentFullData.nama : dataRowDisplay[5]];
                    targetSheet.appendRow(newRowData);
                    studentSheetRow = targetSheet.getLastRow();
                }

                const headers = targetSheet.getRange(1, 1, 1, targetSheet.getLastColumn()).getDisplayValues()[0];
                const mapelCol = headers.indexOf(mapelKode);
                
                if (mapelCol !== -1) {
                    targetSheet.getRange(studentSheetRow, mapelCol + 1).setValue(nilai);
                } else {
                    // Jika kolom mapel belum ada, tambahkan di akhir
                    const newHeaderCol = targetSheet.getLastColumn() + 1;
                    targetSheet.getRange(1, newHeaderCol).setValue(mapelKode).setFontWeight("bold");
                    targetSheet.getRange(studentSheetRow, newHeaderCol).setValue(nilai);
                }
            }
        }
        SpreadsheetApp.flush();
        return { status: "success", message: `Nilai berhasil ${status.toLowerCase()}.` };
    } catch (e) {
        Logger.log("processNilaiSubmission Error: " + e.message + " Stack: " + e.stack);
        return { status: "error", message: "Gagal memproses pengajuan: " + e.message };
    } finally {
        lock.releaseLock();
    }
}

// =================================================================
// [BARU] FUNGSI UNTUK MANAJEMEN DATA GURU OLEH PENGGUNA/SEKOLAH
// =================================================================

/**
 * [PENGGUNA - DIPERBARUI] Mengambil daftar guru, kini termasuk status "Diubah Guru" dan "Kelas Diajar".
 */
function getGuru(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_DATA_GURU);
    
    if (!sheet) {
      sheet = ss.insertSheet(SHEET_DATA_GURU);
      // Tambahkan header baru "Kelas Diajar" di kolom G
      sheet.appendRow(["Nama Guru", "Username", "Password", "Kode Mapel", "NIP", "Diubah Guru", "Kelas Diajar"]);
      sheet.getRange("A1:G1").setFontWeight("bold");
      return [];
    }
    
    // Pastikan semua header ada jika sheet sudah ada sebelumnya
    if (sheet.getRange("F1").getValue() !== "Diubah Guru") {
        sheet.getRange("F1").setValue("Diubah Guru").setFontWeight("bold");
    }
    if (sheet.getRange("G1").getValue() !== "Kelas Diajar") {
        sheet.getRange("G1").setValue("Kelas Diajar").setFontWeight("bold");
    }
    
    sheet.getRange("E:E").setNumberFormat('@');
    if (sheet.getLastRow() < 2) return [];

    // Baca 7 kolom untuk menyertakan data baru
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 7).getDisplayValues();
    return data.map((row, index) => ({
        row: index + 2,
        nama: row[0],
        username: row[1],
        password: '',
        mapel: row[3],
        nip: row[4],
        isModifiedByGuru: row[5],
        kelas: row[6] || '' // Ambil data kelas atau string kosong jika kosong
    }));
  } catch (e) {
    Logger.log(`getGuru Error: ${e.message}`);
    return [];
  }
}

function saveGuru(spreadsheetId, guruData) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_GURU);

        if (sheet.getLastRow() > 1) {
            const usernames = sheet.getRange(2, 2, sheet.getLastRow() - 1, 1).getValues().flat();
            if (usernames.some(u => u.toLowerCase() === guruData.username_guru.toLowerCase())) {
                return { status: "error", message: "Username sudah digunakan." };
            }
        }
        
        // --- AWAL PERUBAHAN KEAMANAN ---
        // 1. Buat "garam" (salt) yang unik untuk setiap password
        const salt = generateSalt();

        // 2. Lakukan hashing pada password dengan salt yang sudah dibuat
        const hashedPassword = hashPassword(guruData.password_guru, salt);

        // 3. Gabungkan salt dan hash untuk disimpan. Format: "salt:hash"
        const storedPasswordString = `${salt}:${hashedPassword}`;
        // --- AKHIR PERUBAHAN KEAMANAN ---

        sheet.appendRow([
            guruData.nama_guru,
            guruData.username_guru,
            storedPasswordString, // <-- AMAN: Simpan string hasil hash
            guruData.mapel_kode_guru,
            guruData.nip_guru ? "'" + guruData.nip_guru : '',
            'TIDAK',
            guruData.kelas_diajar || ''
        ]);

        return { status: "success", message: "Data guru berhasil disimpan." };
    } catch (e) {
        Logger.log(`saveGuru Error: ${e.message}`);
        return { status: "error", message: `Gagal menyimpan: ${e.message}` };
    }
}

/**
 * [PENGGUNA - DIPERBARUI & DIPERBAIKI KEAMANANNYA] Memperbarui data guru dengan logika kondisional untuk username/password
 * dan memastikan password SELALU di-hash.
 */
function updateGuru(spreadsheetId, guruData) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_GURU);
        const rowToUpdate = parseInt(guruData.guruRow);

        const currentRowData = sheet.getRange(rowToUpdate, 1, 1, 7).getValues()[0];
        const isModifiedByGuru = currentRowData[5] === 'YA';

        if (isModifiedByGuru) {
            // Admin hanya bisa mengubah data non-kredensial jika guru sudah pernah mengubahnya.
            sheet.getRange(rowToUpdate, 1).setValue(guruData.nama_guru);      // Nama
            sheet.getRange(rowToUpdate, 4).setValue(guruData.mapel_kode_guru); // Mapel
            sheet.getRange(rowToUpdate, 5).setValue(guruData.nip_guru ? "'" + guruData.nip_guru : ''); // NIP
            sheet.getRange(rowToUpdate, 7).setValue(guruData.kelas_diajar || ''); // Kelas
        } else {
            // Admin dapat mengubah semua data jika guru belum pernah mengubahnya.

            // PERUBAHAN DI SINI:
            // Ambil nilai yang ada saat ini dari spreadsheet
            const dataToUpdate = sheet.getRange(rowToUpdate, 1, 1, 7).getValues()[0];

            // Perbarui data non-kredensial
            dataToUpdate[0] = guruData.nama_guru;
            dataToUpdate[1] = guruData.username_guru;
            dataToUpdate[3] = guruData.mapel_kode_guru;
            dataToUpdate[4] = guruData.nip_guru ? "'" + guruData.nip_guru : '';
            dataToUpdate[6] = guruData.kelas_diajar || '';

            // HANYA perbarui password jika ada nilai baru yang diinput
            if (guruData.password_guru && guruData.password_guru.trim() !== '') {
                const salt = generateSalt();
                const hashedPassword = hashPassword(guruData.password_guru, salt);
                dataToUpdate[2] = `${salt}:${hashedPassword}`; // Timpa password lama dengan hash baru
            }
            // Jika guruData.password_guru kosong, dataToUpdate[2] (password lama) tidak akan diubah.

            // Tulis kembali seluruh baris dengan data yang sudah diperbarui
            sheet.getRange(rowToUpdate, 1, 1, 7).setValues([dataToUpdate]);
        }
        
        return { status: "success", message: "Data guru berhasil diperbarui." };
    } catch (e) {
        Logger.log(`updateGuru Error: ${e.message}`);
        return { status: "error", message: `Gagal memperbarui: ${e.message}` };
    }
}

/**
 * [PENGGUNA] Menghapus data guru.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {number} rowNum - Nomor baris yang akan dihapus.
 * @returns {object} Status penghapusan.
 */
function deleteGuru(spreadsheetId, rowNum) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_GURU);
        sheet.deleteRow(rowNum);
        return { status: "success", message: "Data guru berhasil dihapus." };
    } catch (e) {
        Logger.log(`deleteGuru Error: ${e.message}`);
        return { status: "error", message: `Gagal menghapus: ${e.message}` };
    }
}

/**
 * [PERBAIKAN] Mengambil nilai yang sudah disimpan (draf), yang sudah dikirim,
 * dan ID pengajuan spesifik untuk setiap jenis nilai.
 */
function getGuruNilai(spreadsheetId, username, mapelKode) {
  const ss = SpreadsheetApp.openById(spreadsheetId);

  // Fungsi helper untuk mengambil data dari sheet draf dan terkirim (tidak berubah)
  const getValuesFromSheet = (sheetName) => {
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) return {};
    const data = sheet.getDataRange().getValues();
    const result = {};
    data.forEach(row => {
      // row[0]=username, row[1]=mapelKode, row[2]=tipe, row[3]=nilai (JSON string)
      if (row[0] === username && row[1] === mapelKode) {
        try {
            result[row[2]] = JSON.parse(row[3]);
        } catch(e){
            result[row[2]] = {};
        }
      }
    });
    return result;
  };

  // Fungsi helper yang telah diperbaiki untuk mendapatkan ID pengajuan per jenis nilai
  const getApprovalData = () => {
      const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
      // Jika sheet tidak ada, kembalikan objek kosong
      if (!approvalSheet || approvalSheet.getLastRow() < 2) {
        return { statuses: {}, submissionIds: {} };
      }

      const data = approvalSheet.getRange(2, 1, approvalSheet.getLastRow() - 1, 9).getValues();
      const statuses = {}; // Untuk menyimpan status per nilai individu (contoh: ujian_um_12345)
      const latestSubmissions = {}; // Untuk melacak ID pengajuan terbaru untuk setiap TIPE nilai

      data.forEach(row => {
          // Hanya proses baris yang relevan dengan guru dan mapel ini
          if (row[1] === username && row[2] === mapelKode) {
              const tipeLengkap = row[3]; // contoh: 'ujian_um', 'rapor_k7_ganjil_peng'
              const nisn = row[4];
              const status = row[8];
              const timestamp = new Date(row[7]);
              const submissionId = row[0];

              // Tentukan tipe utama (misalnya, 'ujian' atau 'rapor_k7_ganjil')
              const mainType = tipeLengkap.startsWith('rapor') ? tipeLengkap.split('_').slice(0, 3).join('_') : tipeLengkap.split('_')[0];

              // Simpan status individu (tidak berubah)
              const key = `${tipeLengkap}_${nisn}`;
              statuses[key] = status;

              // Lacak pengajuan terbaru untuk setiap tipe utama
              if (!latestSubmissions[mainType] || timestamp > latestSubmissions[mainType].timestamp) {
                  latestSubmissions[mainType] = {
                      submissionId: submissionId,
                      timestamp: timestamp
                  };
              }
          }
      });

      // Ubah dari { 'ujian': {submissionId: 'abc', ...} } menjadi { 'ujian': 'abc' }
      const submissionIds = {};
      for (const type in latestSubmissions) {
          submissionIds[type] = latestSubmissions[type].submissionId;
      }
      
      // Kembalikan objek yang berisi SEMUA ID pengajuan yang relevan
      return { statuses, submissionIds };
  };
  
  const approvalData = getApprovalData();

  return {
      savedValues: getValuesFromSheet(SHEET_NILAI_GURU_DRAFT),
      submittedValues: getValuesFromSheet(SHEET_NILAI_GURU_SUBMITTED),
      approvalStatus: approvalData.statuses,
      // Kirim objek/peta ID pengajuan, bukan hanya satu ID
      submissionIds: approvalData.submissionIds
  };
}

// [PERBAIKAN] Mengganti 'tipe' menjadi 'type'
function saveGuruDraftNilai(payload) {
  const { spreadsheetId, username, mapelKode, type, nilai } = payload;
  const ss = SpreadsheetApp.openById(spreadsheetId);
  let sheet = ss.getSheetByName(SHEET_NILAI_GURU_DRAFT);
  if (!sheet) {
    sheet = ss.insertSheet(SHEET_NILAI_GURU_DRAFT).hideSheet();
    sheet.appendRow(["Username", "MapelKode", "Tipe", "NilaiJSON"]);
  }
  
  const data = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === username && data[i][1] === mapelKode && data[i][2] === type) {
      rowIndex = i + 1;
      break;
    }
  }

  const nilaiJSON = JSON.stringify(nilai);
  if (rowIndex !== -1) {
    sheet.getRange(rowIndex, 4).setValue(nilaiJSON);
  } else {
    sheet.appendRow([username, mapelKode, type, nilaiJSON]);
  }
  return { status: 'success', message: 'Draf berhasil disimpan.' };
}

/**
 * [DIPERBARUI & PERBAIKAN FINAL] Menerima data nilai dari guru, memvalidasi izin,
 * dan menyimpannya ke sheet persetujuan di spreadsheet yang benar.
 */
function submitGuruNilai(payload) {
  try {
    const { spreadsheetId, username, nama, mapelKode, type, nilai } = payload;

    const submissionStatus = getNilaiSubmissionStatus(spreadsheetId);
    if (!submissionStatus.isEnabled) {
      return { 
        status: "error", 
        message: "Gagal: Pengiriman nilai saat ini sedang ditutup oleh admin. Silakan simpan sebagai draf." 
      };
    }

    const ss = SpreadsheetApp.openById(spreadsheetId);

    let submittedSheet = ss.getSheetByName(SHEET_NILAI_GURU_SUBMITTED);
    if (!submittedSheet) {
      submittedSheet = ss.insertSheet(SHEET_NILAI_GURU_SUBMITTED).hideSheet();
      submittedSheet.appendRow(["Username", "MapelKode", "Tipe", "NilaiJSON", "Tanggal"]);
    }
    const nilaiJSON = JSON.stringify(nilai);
    submittedSheet.appendRow([username, mapelKode, type, nilaiJSON, new Date()]);

    let draftSheet = ss.getSheetByName(SHEET_NILAI_GURU_DRAFT);
    if (draftSheet) {
        const data = draftSheet.getDataRange().getValues();
        for (let i = data.length - 1; i >= 1; i--) {
            if (data[i][0] === username && data[i][1] === mapelKode && data[i][2] === type) {
                draftSheet.deleteRow(i + 1);
            }
        }
    }

    let approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet) {
      approvalSheet = ss.insertSheet(SHEET_PENGAJUAN_NILAI);
      // [PERUBAHAN] Kembalikan header menjadi 9 kolom, tanpa "Status Baca Admin"
      approvalSheet.appendRow(["ID Pengajuan", "Guru", "Mapel", "Tipe Nilai", "NISN", "Nama Siswa", "Nilai", "Tanggal Ajuan", "Status"]);
      approvalSheet.getRange("A1:I1").setFontWeight("bold");
    }

    const students = getStudentsForGuru(spreadsheetId);
    const studentMap = new Map(students.map(s => [s.nisn.toString(), s.nama]));
    const submissionId = Utilities.getUuid(); // ID pengajuan dibuat di sini
    const timestamp = new Date();
    const rowsToAppend = [];

    for (const [key, value] of Object.entries(nilai)) {
      if (value === null || String(value).trim() === '') {
        continue;
      }

      const parts = key.split('_'); 
      const nisn = parts[0];
      const subTipe = parts[1];
      
      let tipeNilaiLengkap = '';
      if (type.startsWith('rapor')) {
        tipeNilaiLengkap = `${type}_${subTipe}`;
      } else if (type === 'ujian') {
        tipeNilaiLengkap = `ujian_${subTipe}`;
      }

      rowsToAppend.push([
        submissionId, username, mapelKode, tipeNilaiLengkap,
        "'" + nisn,
        studentMap.get(nisn) || 'Siswa tidak ditemukan',
        value, timestamp, "Menunggu Persetujuan"
        // Kolom ke-10 untuk "Status Baca Admin" telah dihapus
      ]);
    }

    if (rowsToAppend.length > 0) {
      // [PERUBAHAN] Sesuaikan jumlah kolom penulisan menjadi 9
      approvalSheet.getRange(approvalSheet.getLastRow() + 1, 1, rowsToAppend.length, 9).setValues(rowsToAppend);
      approvalSheet.getRange("E:E").setNumberFormat('@'); 
    }

    try {
        const masterSs = SpreadsheetApp.getActiveSpreadsheet();
        const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
        const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 6).getValues();
        const schoolAdminRow = usersData.find(row => row[5] === spreadsheetId);

        if (schoolAdminRow) {
            const adminEmail = schoolAdminRow[1];
            const schoolName = schoolAdminRow[3];
            const mapelInfo = getMapel(spreadsheetId).find(m => m.kode === mapelKode);
            const mapelName = mapelInfo ? mapelInfo.nama : mapelKode;
            const subject = `[Notifikasi Aplikasi Ijazah] Pengajuan Nilai Baru dari ${nama}`;
            const body = `
              <p>Halo Admin ${schoolName},</p>
              <p>Anda telah menerima pengajuan nilai baru dengan detail sebagai berikut:</p>
              <ul>
                <li><b>Guru Pengirim:</b> ${nama}</li> 
                <li><b>Mata Pelajaran:</b> ${mapelName}</li>
                <li><b>Jenis Nilai:</b> ${type.replace(/_/g, ' ')}</li>
                <li><b>Jumlah Data Nilai Diajukan:</b> ${rowsToAppend.length}</li>
                <li><b>Tanggal Pengajuan:</b> ${timestamp.toLocaleString('id-ID')}</li>
              </ul>
              <p>Silakan masuk ke aplikasi untuk meninjau dan memproses pengajuan ini di menu "Persetujuan Nilai".</p>
              <br>
              <p>Terima kasih.</p>
            `;
            MailApp.sendEmail({ to: adminEmail, subject: subject, htmlBody: body });
        }
    } catch (e) {
        Logger.log(`Gagal mengirim email notifikasi pengajuan nilai ke admin: ${e.message}`);
    }
    
    // ===== PERUBAHAN UTAMA DI SINI =====
    return { 
        status: 'success', 
        message: 'Nilai berhasil dikirim untuk persetujuan admin.',
        submissionId: submissionId // Kirim ID pengajuan kembali ke frontend
    };
    // ===================================
  } catch(e) {
    Logger.log("submitGuruNilai Error: " + e.message);
    return { status: "error", message: "Gagal mengirim nilai: " + e.message };
  }
}

/**
 * [BARU] Menghitung jumlah pengajuan nilai yang masih menunggu.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @returns {number} Jumlah pengajuan yang pending.
 */
function getPendingApprovalCount(spreadsheetId) {
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!sheet || sheet.getLastRow() < 2) {
      return 0;
    }
    const statusColumn = sheet.getRange(2, 9, sheet.getLastRow() - 1, 1).getValues();
    const pendingCount = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
    return pendingCount;
  } catch (e) {
    Logger.log(`getPendingApprovalCount Error: ${e.message}`);
    return 0;
  }
}

/**
 * [BARU] Memproses beberapa pengajuan nilai sekaligus (aksi massal).
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {Array<number>} rowNumbers - Array nomor baris yang akan diproses.
 * @param {string} status - Keputusan ("Disetujui" atau "Ditolak").
 * @returns {object} Hasil proses.
 */
function processMultipleSubmissions(spreadsheetId, rowNumbers, status) {
  if (!rowNumbers || rowNumbers.length === 0) {
    return { status: "info", message: "Tidak ada item yang dipilih." };
  }
  let successCount = 0;
  let errorCount = 0;
  
  rowNumbers.forEach(rowNum => {
    try {
      // Memanggil fungsi yang sudah ada untuk setiap baris
      const result = processNilaiSubmission(spreadsheetId, rowNum, status);
      if (result.status === 'success') {
        successCount++;
      } else {
        errorCount++;
        Logger.log(`Gagal memproses baris ${rowNum}: ${result.message}`);
      }
    } catch (e) {
      errorCount++;
      Logger.log(`Error saat memproses baris ${rowNum}: ${e.message}`);
    }
  });

  let message = `${successCount} item berhasil diproses.`;
  if (errorCount > 0) {
    message += ` ${errorCount} item gagal diproses (lihat log untuk detail).`;
  }
  return { status: "success", message: message };
}

// =================================================================
// [BARU] FUNGSI CETAK PDF UNTUK GURU
// =================================================================

/**
 * [REVISI FINAL] Helper function untuk mengubah angka menjadi teks terbilang dalam Bahasa Indonesia.
 * Logika ini telah diperbaiki untuk menangani angka 100, 70, dll. dengan benar.
 * @param {number} angka - Angka yang akan diubah.
 * @returns {string} Teks terbilang dari angka.
 */
function terbilang(angka) {
    angka = Number(angka);
    // Kasus khusus HANYA untuk input angka nol
    if (angka === 0) return "Nol";

    const bilangan = ["", "Satu", "Dua", "Tiga", "Empat", "Lima", "Enam", "Tujuh", "Delapan", "Sembilan", "Sepuluh", "Sebelas"];
    
    // Fungsi rekursif internal yang tidak akan menghasilkan "Nol"
    function toWords(n) {
        if (n < 12) {
            return bilangan[n];
        } else if (n < 20) {
            return toWords(n - 10) + " Belas";
        } else if (n < 100) {
            return toWords(Math.floor(n / 10)) + " Puluh " + toWords(n % 10);
        } else if (n < 200) {
            return "Seratus " + toWords(n - 100);
        } else if (n < 1000) {
            return toWords(Math.floor(n / 100)) + " Ratus " + toWords(n % 100);
        }
        return ""; // Untuk angka 0 dalam rekursi, kembalikan string kosong
    }

    // Panggil fungsi internal dan bersihkan spasi ganda atau di akhir
    let hasil = toWords(angka).replace(/  +/g, ' ').trim();
    return hasil;
}

/**
 * [REVISI FINAL] Membuat file PDF daftar nilai dengan validasi yang sudah diperbarui.
 */
function generateNilaiPdfForGuru(payload) {
  try {
    const { spreadsheetId, tipe, mapelKode, guruData, submissionId, kelas } = payload;
    
    // --- PERBAIKAN: Gunakan fungsi helper yang baru ---
    if (!isSubmissionFullyApproved(spreadsheetId, submissionId)) {
      throw new Error("Cetak nilai gagal. Pastikan semua nilai siswa untuk pengajuan ini telah disetujui oleh admin.");
    }
    // --- AKHIR PERBAIKAN ---
    
    // --- Sisa dari fungsi ini tidak ada yang berubah ---
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const schoolData = getSchoolData(spreadsheetId);
    const students = getStudentsForGuru(spreadsheetId);
    const allMapel = getMapel(spreadsheetId);
    const mapelInfo = allMapel.find(m => m.kode === mapelKode);
    const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet) throw new Error("Sheet 'Pengajuan Nilai' tidak ditemukan.");
    
    const approvalData = approvalSheet.getRange(2, 1, approvalSheet.getLastRow() - 1, 9).getValues();
    const nilaiPerSiswa = [];
    students.forEach(s => {
        let nilaiAkhir = null;
        if (tipe === 'ujian') {
            const nilaiUMRow = approvalData.find(row => row[0].toString() === submissionId.toString() && row[1] === guruData.username && row[2] === mapelKode && row[3] === 'ujian_um' && row[4].toString() === s.nisn.toString() && row[8] === 'Disetujui');
            const nilaiUPrRow = approvalData.find(row => row[0].toString() === submissionId.toString() && row[1] === guruData.username && row[2] === mapelKode && row[3] === 'ujian_upr' && row[4].toString() === s.nisn.toString() && row[8] === 'Disetujui');
            const nilaiUM = nilaiUMRow ? parseFloat(nilaiUMRow[6]) : null;
            const nilaiUPr = nilaiUPrRow ? parseFloat(nilaiUPrRow[6]) : null;

            if (nilaiUM !== null && nilaiUPr !== null) { nilaiAkhir = Math.round((nilaiUM + nilaiUPr) / 2); } 
            else if (nilaiUM !== null) { nilaiAkhir = Math.round(nilaiUM); } 
            else if (nilaiUPr !== null) { nilaiAkhir = Math.round(nilaiUPr); }
        } else {
            const tipeNilaiCari = `rapor_${tipe.split('_')[1]}_${tipe.split('_')[2]}`;
            const tipePeng = `${tipeNilaiCari}_peng`;
            const nilaiPengRow = approvalData.find(row => row[0].toString() === submissionId.toString() && row[1] === guruData.username && row[2] === mapelKode && row[3] === tipePeng && row[4].toString() === s.nisn.toString() && row[8] === 'Disetujui');
            if (nilaiPengRow) { nilaiAkhir = Math.round(parseFloat(nilaiPengRow[6])); }
        }
        if (nilaiAkhir !== null) { nilaiPerSiswa.push({ ...s, nilai: nilaiAkhir }); }
    });
    if (nilaiPerSiswa.length === 0) { throw new Error("Tidak ada data nilai yang disetujui untuk dicetak."); }

    const printSettings = getPrintSettings(spreadsheetId).settings || {};
    const tahunSekarang = new Date().getFullYear();
    const tahunAjaran = printSettings.tahunAjaran || `${tahunSekarang - 1}/${tahunSekarang}`;
    const tahunUntukJudul = tahunAjaran.split('/')[1] || tahunSekarang;
    let reportTitle = "";
    if (tipe === 'ujian') {
        reportTitle = `NILAI UJIAN MADRASAH TAHUN ${tahunUntukJudul}`;
    } else if (tipe.startsWith('rapor_')) {
        const semesterKey = tipe.split('_').slice(1).join('_');
        const semesterMap = { k4_ganjil: 'KELAS IV SEMESTER GANJIL', k4_genap: 'KELAS IV SEMESTER GENAP', k5_ganjil: 'KELAS V SEMESTER GANJIL', k5_genap: 'KELAS V SEMESTER GENAP', k6_ganjil: 'KELAS VI SEMESTER GANJIL', k7_ganjil: 'KELAS VII SEMESTER GANJIL', k7_genap: 'KELAS VII SEMESTER GENAP', k8_ganjil: 'KELAS VIII SEMESTER GANJIL', k8_genap: 'KELAS VIII SEMESTER GENAP', k9_ganjil: 'KELAS IX SEMESTER GANJIL', k10_ganjil: 'KELAS X SEMESTER GANJIL', k10_genap: 'KELAS X SEMESTER GENAP', k11_ganjil: 'KELAS XI SEMESTER GANJIL', k11_genap: 'KELAS XI SEMESTER GENAP', k12_ganjil: 'KELAS XII SEMESTER GANJIL' };
        reportTitle = `DAFTAR NILAI RAPOR ${semesterMap[semesterKey] || ''} TAHUN AJARAN ${tahunAjaran}`;
    }
    const { logo, customHeader } = getDocumentSettings(spreadsheetId).settings || {};
    let headerHtml;
    if (customHeader) {
        headerHtml = `<div style="width: 100%; margin-bottom: 10px; border-bottom: 3px solid black;"><img src="${customHeader}" alt="Kop Surat" style="width: 100%; height: auto;"></div>`;
    } else {
        const kantorKemenagLine = `KANTOR KEMENTERIAN AGAMA ${schoolData.tipeKabupaten || ''} ${schoolData.kabupaten || ''}`.toUpperCase();
        const tipeKabSingkat = schoolData.tipeKabupaten === 'Kabupaten' ? 'Kab.' : 'Kota';
        const tipeKelSingkat = schoolData.tipeKelurahan === 'Kelurahan' ? 'Kel.' : 'Desa';
        const alamatLengkap = [ schoolData.alamat, `${tipeKelSingkat} ${toProperCase(schoolData.kelurahan || '')}`, `Kec. ${toProperCase(schoolData.kecamatan || '')}`, `${tipeKabSingkat} ${toProperCase(schoolData.kabupaten || '')}`, toProperCase(schoolData.provinsi || ''), schoolData.kodePos ].filter(Boolean).join(', ');
        const phone = schoolData.telepon ? `Telepon : ${schoolData.telepon}` : '';
        const web = schoolData.website ? `Website : ${schoolData.website}` : '';
        let contactLine = '';
        if (phone && web) { contactLine = `${phone} | ${web}`; } 
        else { contactLine = phone || web; }
        const contactLineHtml = contactLine ? `<div style="font-family: 'Times New Roman', Times, serif; font-size: 9pt;">${contactLine}</div>` : '';
        headerHtml = `
            <div style="display: flex; align-items: flex-start; padding-bottom: 5px; border-bottom: 3px solid black; margin-bottom: 10px;">
                ${logo ? `<img src="${logo}" style="width:75px; height:75px; margin-right: 20px;" alt="Logo">` : '<div style="width:75px; height:75px; margin-right: 20px;"></div>'}
                <div style="text-align: center; flex-grow: 1; line-height: 1.4; font-family: 'Times New Roman', Times, serif;">
                   <div style="font-size: 14pt; font-weight: bold;">KEMENTERIAN AGAMA REPUBLIK INDONESIA</div>
                   <div style="font-size: 12pt; font-weight: bold;">${kantorKemenagLine}</div>
                   <div style="font-size: 11pt; font-weight: bold;">${(schoolData.namaSekolah || 'NAMA SEKOLAH').toUpperCase()}</div>
                   <div style="font-size: 9pt;">Alamat : ${alamatLengkap}</div>
                   ${contactLineHtml}
                </div>
            </div>`;
    }
    const tanggalCetak = new Date().toLocaleDateString('id-ID', { day: 'numeric', month: 'long', year: 'numeric' });
    const tempatCetak = schoolData.kabupaten ? toProperCase(schoolData.kabupaten) : 'Tempat';
    const htmlContent = `
      <html><head><style>
        body{font-family: 'Times New Roman', Times, serif; font-size: 11pt;} table{border-collapse: collapse; width: 100%;} 
        thead th { text-align: center; } th, td{border: 1px solid black; padding: 4px; vertical-align: middle;}
        .text-center{text-align: center;} .font-bold{font-weight: bold;} .no-border{border: none !important;}
      </style></head><body>
        ${headerHtml}
        <h3 style="text-align:center; font-size: 13pt; margin-top: 20px; margin-bottom: 20px; text-decoration: underline; font-weight: bold;">${reportTitle}</h3>
        <table class="no-border" style="width: 100%; font-size: 12pt; margin-bottom: 15px;">
            <tr><td class="no-border" style="width: 180px;">Nama Mata Pelajaran</td><td class="no-border" style="width:10px;">:</td><td class="no-border font-bold" style="white-space: nowrap;">${mapelInfo.nama.toUpperCase()}</td></tr>
            <tr><td class="no-border">Tahun Pelajaran</td><td class="no-border">:</td><td class="no-border font-bold">${tahunAjaran}</td></tr>
            <tr><td class="no-border">Kelas</td><td class="no-border">:</td><td class="no-border font-bold">${kelas ? kelas.toUpperCase() : '-'}</td></tr>
            <tr><td class="no-border">Guru Pemeriksa</td><td class="no-border">:</td><td class="no-border font-bold">${guruData.nama.toUpperCase()}</td></tr>
        </table>
        <table><thead style="background-color: #e5e5e5; font-weight:bold;"><tr><th>No</th><th>Ruang<br>Ujian</th><th>Nomor Ujian</th><th>Nama Peserta Ujian</th><th>Nilai</th><th>Nilai dengan huruf</th></tr></thead>
            <tbody>${nilaiPerSiswa.map((s, i) => `<tr><td class="text-center">${i + 1}</td><td class="text-center">${s.ruangUjian || '-'}</td><td class="text-center">${s.nomorUjian || '-'}</td><td>${s.nama}</td><td class="text-center font-bold">${s.nilai}</td><td style="font-style: italic;">${terbilang(s.nilai)}</td></tr>`).join('')}</tbody>
        </table>
        <div style="margin-top: 40px; width: 100%; display: flex; justify-content: space-between; page-break-inside: avoid;">
            <div style="width: 45%; text-align: center;"><p style="margin-bottom: 60px;">Mengetahui,<br>Kepala Madrasah,</p><p style="font-weight: bold; text-decoration: underline; margin: 0; padding: 0;">${schoolData.namaKepsek ? schoolData.namaKepsek.toUpperCase() : '(NAMA KEPALA SEKOLAH)'}</p><p style="margin: 0; padding: 0;">NIP. ${schoolData.nipKepsek || '-'}</p></div>
            <div style="width: 45%; text-align: center;"><p style="margin-bottom: 60px;">${tempatCetak}, ${tanggalCetak}<br>Guru Pemeriksa,</p><p style="font-weight: bold; text-decoration: underline; margin: 0; padding: 0;">${guruData.nama.toUpperCase()}</p><p style="margin: 0; padding: 0;">NIP. ${guruData.nip || '-'}</p></div>
        </div>
      </body></html>`;

    const pdfBlob = Utilities.newBlob(htmlContent, MimeType.HTML).getAs(MimeType.PDF);
    const fileName = `Nilai_${mapelKode}_${tipe}.pdf`;
    pdfBlob.setName(fileName);
    
    return { status: 'success', fileName: fileName, pdfData: Utilities.base64Encode(pdfBlob.getBytes()) };
  } catch(e) {
    Logger.log("generateNilaiPdfForGuru Error: " + e.stack);
    return { status: "error", message: e.message };
  }
}

/**
 * [PERBAIKAN FINAL] Mengekspor data siswa ke dalam file Excel.
 * Menambahkan kutip tunggal di depan NISN, NIS, No. Ujian, dan Telepon
 * untuk memastikan format teks tetap terjaga (termasuk angka 0 di depan).
 */
function exportSiswaToExcel(spreadsheetId) {
  let tempFile;
  try {
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) {
      return { error: "Tidak ada data siswa untuk diekspor." };
    }

    const schoolData = getSchoolData(spreadsheetId);
    const schoolName = schoolData ? schoolData.namaSekolah.replace(/ /g, "_") : "Data_Siswa";
    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd");
    const exportFileName = `Data_Siswa_${schoolName}_${timestamp}`;
    
    const tempSpreadsheet = SpreadsheetApp.create(exportFileName);
    tempFile = DriveApp.getFileById(tempSpreadsheet.getId());
    
    const sheet = tempSpreadsheet.getSheets()[0];
    const headers = [
      "NISN", "NIS (2 digit tahun lulus 4 digit nomor urut)", "Nomor Ujian", "Nama Lengkap", "Jenis Kelamin (L/P)", 
      "Tempat Lahir", "Tanggal Lahir (Format: yyyy-MM-dd)",
      "Alamat Lengkap Siswa", "Nomor Telepon", "Email", 
      "Tahun Masuk", "Tahun Lulus", "Kelas", "Ruang Ujian"
    ];
    sheet.appendRow(headers);
    sheet.getRange("A1:N1").setFontWeight("bold").setBackground("#d9ead3");

    // [PERBAIKAN DI SINI] Tambahkan kutip tunggal (') di depan data yang relevan
    const rowsToWrite = students.map(s => [
      "'" + s.nisn, 
      "'" + s.nis, 
      "'" + s.nomorUjian, 
      s.nama, 
      s.jenisKelamin,
      s.tempatLahir, 
      s.tanggalLahir, 
      s.alamat, 
      "'" + s.telepon,
      s.emailSiswa, 
      s.tahunMasuk, 
      s.tahunLulus, 
      s.kelas, 
      s.ruangUjian
    ]);

    if (rowsToWrite.length > 0) {
      sheet.getRange(2, 1, rowsToWrite.length, headers.length).setValues(rowsToWrite);
    }
    
    sheet.getRange("G:G").setNumberFormat("yyyy-mm-dd");
    sheet.autoResizeColumns(1, headers.length);

    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${tempSpreadsheet.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: `${exportFileName}.xlsx`,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

// =================================================================
// [BARU] FUNGSI KONTROL PENGIRIMAN NILAI
// =================================================================

function setNilaiSubmissionStatus(spreadsheetId, isEnabled) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
        sheet = ss.insertSheet(SHEET_PENGATURAN);
        sheet.appendRow(['Nama Pengaturan', 'Value']);
    }
    const settingName = "Izinkan Pengiriman Nilai";
    const data = sheet.getRange("A:A").getValues().flat();
    let rowIndex = data.indexOf(settingName);

    if (rowIndex === -1) {
        sheet.appendRow([settingName, isEnabled ? "YA" : "TIDAK"]);
    } else {
        sheet.getRange(rowIndex + 1, 2).setValue(isEnabled ? "YA" : "TIDAK");
    }
    
    const message = isEnabled ? "Pengiriman nilai oleh guru telah diaktifkan." : "Pengiriman nilai oleh guru telah dinonaktifkan.";
    return { status: 'success', message: message };
  } catch (e) {
    Logger.log(`setNilaiSubmissionStatus Error: ${e.message}`);
    return { status: 'error', message: 'Gagal mengubah pengaturan.' };
  }
}

function getNilaiSubmissionStatus(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
      return { isEnabled: true };
    }
    const data = sheet.getRange("A:B").getValues();
    const settingRow = data.find(row => row[0] === "Izinkan Pengiriman Nilai");
    
    const isEnabled = settingRow ? settingRow[1] !== "TIDAK" : true;
    return { isEnabled: isEnabled };
  } catch (e) {
    Logger.log(`getNilaiSubmissionStatus Error: ${e.message}`);
    return { isEnabled: true };
  }
}

/**
 * [MODIFIKASI] Menghasilkan template Excel untuk impor data guru, kini dengan kolom Kelas Diajar
 * dan sheet "Petunjuk & Referensi" yang lengkap.
 */
function generateGuruTemplate(spreadsheetId) { // spreadsheetId ditambahkan sebagai parameter
  let tempFile;
  try {
    const tempSpreadsheet = SpreadsheetApp.create("Template Data Guru");
    tempFile = DriveApp.getFileById(tempSpreadsheet.getId());
    
    // --- SHEET 1: DATA GURU (Untuk Diisi Pengguna) ---
    const mainSheet = tempSpreadsheet.getSheets()[0].setName("Data Guru");
    const headers = [
      "Nama Guru", "NIP (Opsional)", "Username", "Password", "Kode Mapel (pisahkan dengan koma)", "Kelas Diajar (Format: KODE:KELAS, pisahkan dengan koma)"
    ];
    mainSheet.getRange("A1:F1").setValues([headers]).setFontWeight("bold").setBackground("#d9ead3");
    mainSheet.getRange("B:D").setNumberFormat("@");
    mainSheet.setColumnWidths(1, headers.length, 250);

    // ==============================================================
    // === AWAL BLOK KODE BARU: MEMBUAT SHEET PETUNJUK & REFERENSI ==
    // ==============================================================
    
    // 1. Buat sheet baru untuk petunjuk
    const petunjukSheet = tempSpreadsheet.insertSheet("Petunjuk & Referensi");
    
    // 2. Ambil data referensi (Mapel dan Kelas)
    const mapelList = getMapel(spreadsheetId); // Menggunakan spreadsheetId
    const studentsList = getStudents(spreadsheetId); // Menggunakan spreadsheetId
    const uniqueKelas = [...new Set(studentsList.map(s => s.kelas).filter(Boolean))].sort();

    // 3. Tulis konten ke dalam sheet "Petunjuk & Referensi"
    let row = 1;

    petunjukSheet.getRange(row, 1).setValue("Panduan Pengisian Template Data Guru").setFontWeight("bold").setFontSize(14);
    petunjukSheet.getRange(row, 1, 1, 5).merge();
    row += 2;

    petunjukSheet.getRange(row, 1).setValue("Petunjuk Pengisian").setFontWeight("bold").setFontSize(12);
    row++;
    const petunjuk = [
      ["Kolom", "Keterangan"],
      ["Nama Guru", "Isi dengan nama lengkap guru beserta gelar (jika ada). Wajib diisi."],
      ["NIP (Opsional)", "Isi dengan Nomor Induk Pegawai. Boleh dikosongkan."],
      ["Username", "Username untuk login ke Portal Guru. Wajib diisi dan harus unik."],
      ["Password", "Password untuk login. Wajib diisi."],
      ["Kode Mapel", "Isi dengan Kode Mapel yang diajar. Jika lebih dari satu, pisahkan dengan koma (contoh: MTK,FIS). Lihat referensi di samping."],
      ["Kelas Diajar", "Format: KODEMAPEL:KELAS. Contoh: Jika guru mengajar MTK di kelas 7A dan 7B, isi 'MTK:7A,MTK:7B'. Lihat referensi di bawah."]
    ];
    petunjukSheet.getRange(row, 1, petunjuk.length, 2).setValues(petunjuk).setWrap(true);
    petunjukSheet.getRange(row, 1, 1, 2).setFontWeight("bold").setBackground("#e0e7ff");
    petunjukSheet.getRange(row + 1, 1, petunjuk.length - 1, 2).setVerticalAlignment("top");
    row += petunjuk.length + 2;

    petunjukSheet.getRange(row, 1).setValue("Referensi Mata Pelajaran").setFontWeight("bold").setFontSize(12);
    petunjukSheet.getRange(row, 4).setValue("Referensi Kelas").setFontWeight("bold").setFontSize(12);
    row++;
    petunjukSheet.getRange(row, 1, 1, 2).setValues([["Kode Mapel", "Nama Mata Pelajaran"]]).setFontWeight("bold").setBackground("#e0e7ff");
    petunjukSheet.getRange(row, 4, 1, 1).setValue("Nama Kelas").setFontWeight("bold").setBackground("#e0e7ff");
    row++;

    if (mapelList.length > 0) {
      const mapelFormatted = mapelList.map(m => [m.kode, m.nama]);
      petunjukSheet.getRange(row, 1, mapelFormatted.length, 2).setValues(mapelFormatted);
    } else {
      petunjukSheet.getRange(row, 1).setValue("Data mapel belum diisi.");
    }

    if (uniqueKelas.length > 0) {
      const kelasFormatted = uniqueKelas.map(k => [k]);
      petunjukSheet.getRange(row, 4, kelasFormatted.length, 1).setValues(kelasFormatted);
    } else {
      petunjukSheet.getRange(row, 4).setValue("Data kelas belum ada.");
    }
    
    petunjukSheet.setColumnWidths(1, 2, 250);
    petunjukSheet.setColumnWidth(3, 20);
    petunjukSheet.setColumnWidth(4, 250);

    mainSheet.activate();
    
    // ==============================================================
    // === AKHIR BLOK KODE BARU =====================================
    // ==============================================================
    
    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${tempSpreadsheet.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: 'Template_Import_Guru.xlsx',
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

/**
 * [DIPERBARUI] Mengekspor data guru ke dalam file Excel, kini dengan kolom Kelas Diajar.
 */
function exportGuruToExcel(spreadsheetId) {
  let tempFile;
  try {
    const guruList = getGuru(spreadsheetId);
    if (!guruList || guruList.length === 0) {
      return { error: "Tidak ada data guru untuk diekspor." };
    }

    const schoolData = getSchoolData(spreadsheetId);
    const schoolName = schoolData ? schoolData.namaSekolah.replace(/ /g, "_") : "Data_Guru";
    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd");
    const exportFileName = `Data_Guru_${schoolName}_${timestamp}`;
    
    const tempSpreadsheet = SpreadsheetApp.create(exportFileName);
    tempFile = DriveApp.getFileById(tempSpreadsheet.getId());
    
    const sheet = tempSpreadsheet.getSheets()[0];
    // ===== PERUBAHAN 1: Tambahkan header "Kelas Diajar" =====
    const headers = ["Nama Guru", "NIP", "Username", "Password", "Kode Mapel", "Kelas Diajar"];
    sheet.appendRow(headers);
    sheet.getRange("A1:F1").setFontWeight("bold").setBackground("#d9ead3");

    // ===== PERUBAHAN 2: Tambahkan g.kelas ke dalam data yang akan ditulis =====
    const rowsToWrite = guruList.map(g => {
        // Cek apakah akun sudah pernah diubah oleh guru
        const isModified = g.isModifiedByGuru === 'YA';
        
        // Jika sudah diubah, sembunyikan username dan password. Jika belum, tampilkan seperti biasa.
        const usernameToShow = isModified ? '******' : g.username;
        const passwordToShow = isModified ? '******' : g.password;

        return [
            g.nama,
            "'" + g.nip,
            "'" + usernameToShow,
            "'" + passwordToShow,
            g.mapel,
            g.kelas
        ];
    });

    if (rowsToWrite.length > 0) {
      sheet.getRange(2, 1, rowsToWrite.length, headers.length).setValues(rowsToWrite);
    }
    
    sheet.autoResizeColumns(1, headers.length);
    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${tempSpreadsheet.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: `${exportFileName}.xlsx`,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

/**
 * [DIPERBARUI & PERBAIKAN UPLOAD] Mengimpor data guru dari file Excel.
 */
function importGuruFromExcel(spreadsheetId, fileData) {
    let tempFileId = null; // Variabel untuk menyimpan ID file sementara
    try {
        const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
        const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
        const tempSpreadsheetFile = Drive.Files.insert({ title: `temp_import_guru_${new Date().getTime()}` }, blob, { convert: true });

        if (!tempSpreadsheetFile || !tempSpreadsheetFile.id) {
            throw new Error("Gagal membuat file sementara di Google Drive.");
        }
        
        tempFileId = tempSpreadsheetFile.id;
        const importSheet = SpreadsheetApp.openById(tempFileId).getSheets()[0];
        const data = importSheet.getDataRange().getValues();

        if (data.length <= 1) throw new Error("File kosong atau hanya berisi header.");
        data.shift(); // Hapus header

        const targetSpreadsheet = getSpreadsheet(spreadsheetId);
        let targetSheet = targetSpreadsheet.getSheetByName(SHEET_DATA_GURU);
        if (!targetSheet) {
            targetSheet = targetSpreadsheet.insertSheet(SHEET_DATA_GURU);
            targetSheet.appendRow(["Nama Guru", "Username", "Password", "Kode Mapel", "NIP", "Diubah Guru", "Kelas Diajar"]);
        }

        const existingUsernames = new Set(
            targetSheet.getLastRow() > 1 ?
            targetSheet.getRange(2, 2, targetSheet.getLastRow() - 1, 1).getValues().flat().map(u => u.toLowerCase()) : []
        );

        const newTeachers = [];
        let skippedCount = 0;
        const usernamesInFile = new Set();

        data.forEach(row => {
            const username = (row[2] || '').toString().trim();
            const password = (row[3] || '').toString().trim();
            if (!username || !password) { skippedCount++; return; }
            if (existingUsernames.has(username.toLowerCase()) || usernamesInFile.has(username.toLowerCase())) { skippedCount++; return; }
            
            newTeachers.push([
                row[0] || '', // Nama
                username,
                password,
                row[4] || '', // Mapel
                row[1] || '', // NIP
                'TIDAK',
                row[5] || ''  // Kelas
            ]);
            usernamesInFile.add(username.toLowerCase());
        });

        if (newTeachers.length > 0) {
            targetSheet.getRange(targetSheet.getLastRow() + 1, 1, newTeachers.length, 7).setValues(newTeachers);
        }

        return { 
            status: "success", 
            message: `${newTeachers.length} data guru berhasil diimpor. ${skippedCount} data dilewati karena tidak lengkap atau username duplikat.`
        };

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: `Gagal mengimpor data: ${e.toString()}` };
    } finally {
        if (tempFileId) {
            DriveApp.getFileById(tempFileId).setTrashed(true);
        }
    }
}

/**
 * [BARU] Mengambil data profil untuk guru yang sedang login.
 */
function getGuruProfile(spreadsheetId, username) {
  try {
    const allGuru = getGuru(spreadsheetId);
    const profile = allGuru.find(g => g.username === username);
    if (!profile) {
      throw new Error("Profil guru tidak ditemukan.");
    }
    return { status: 'success', profile: profile };
  } catch (e) {
    return { status: 'error', message: e.message };
  }
}

/**
 * [BARU] Guru memperbarui profilnya sendiri.
 */
function updateGuruProfile(spreadsheetId, oldUsername, newData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_GURU);
    const usernames = sheet.getRange(2, 2, sheet.getLastRow() - 1, 1).getDisplayValues().flat();
    const guruIndex = usernames.findIndex(u => u === oldUsername);

    if (guruIndex === -1) {
      throw new Error("Profil guru tidak dapat ditemukan untuk diperbarui.");
    }
    const rowToUpdate = guruIndex + 2;
    
    // Set status "Diubah Guru" menjadi YA
    const isCredentialChanged = (newData.username !== oldUsername) || (newData.password !== sheet.getRange(rowToUpdate, 3).getValue());
    
    sheet.getRange(rowToUpdate, 1, 1, 6).setValues([[
      newData.nama,
      newData.username,
      newData.password,
      newData.mapel,
      newData.nip ? "'" + newData.nip : '',
      isCredentialChanged ? 'YA' : sheet.getRange(rowToUpdate, 6).getValue() || 'TIDAK'
    ]]);
    
    return { status: 'success', message: 'Profil berhasil diperbarui.' };
  } catch (e) {
    return { status: 'error', message: e.message };
  }
}

/**
 * [FINAL & AMAN] Admin membuat ulang username dan password untuk guru.
 * Fungsi ini mengirimkan password baru (teks biasa) ke email admin,
 * LALU menyimpan versi hash yang aman ke spreadsheet.
 */
function regenerateGuruCredentials(spreadsheetId, rowNum) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_GURU);
    
    // Mengambil data untuk email (tidak ada perubahan di sini)
    const guruName = sheet.getRange(rowNum, 1).getValue();
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 6).getValues();
    const schoolAdminRow = usersData.find(row => row[5] === spreadsheetId);
    
    let adminEmail = null;
    let schoolName = 'Sekolah Anda';

    if (schoolAdminRow) {
      adminEmail = schoolAdminRow[1];
      schoolName = schoolAdminRow[3];
    } else {
      throw new Error("Data admin sekolah tidak ditemukan untuk mengirim email.");
    }

    // 1. Buat username & password acak dalam bentuk TEKS BIASA
    const newUsername = 'guru' + Math.floor(1000 + Math.random() * 9000);
    const newPasswordPlainText = Math.random().toString(36).slice(-8); // Ini password aslinya
    
    // 2. Kirim email berisi password TEKS BIASA ke admin
    const subject = `[Info Kredensial Baru] Akun Guru untuk ${guruName}`;
    const body = `
      <div style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2>Informasi Pembaruan Kredensial Guru</h2>
        <p>Halo Admin ${schoolName},</p>
        <p>Anda telah berhasil membuat ulang kredensial login untuk guru Anda. Berikut adalah detailnya:</p>
        <ul style="list-style-type: none; padding: 0;">
          <li><strong>Nama Guru:</strong> ${guruName}</li>
          <li style="margin-top: 10px;"><strong>Username Baru:</strong> <span style="font-family: monospace; background-color: #f0f0f0; padding: 2px 5px; border-radius: 3px;">${newUsername}</span></li>
          <li><strong>Password Baru:</strong> <span style="font-family: monospace; background-color: #f0f0f0; padding: 2px 5px; border-radius: 3px;">${newPasswordPlainText}</span></li>
        </ul>
        <p>Harap catat informasi ini dan berikan kepada guru yang bersangkutan. Email ini dikirim sebagai catatan untuk Anda.</p>
      </div>
    `;
    MailApp.sendEmail({
      to: adminEmail,
      subject: subject,
      htmlBody: body
    });

    // --- AWAL PERBAIKAN UTAMA ---
    
    // 3. Lakukan HASHING pada password teks biasa tadi
    const salt = generateSalt();
    const hashedPassword = hashPassword(newPasswordPlainText, salt);
    const newStoredPasswordString = `${salt}:${hashedPassword}`; // Ini adalah versi hash yang aman

    // 4. Update sheet dengan username baru dan password yang SUDAH DI-HASH
    sheet.getRange(rowNum, 2).setValue(newUsername);
    sheet.getRange(rowNum, 3).setValue(newStoredPasswordString); // Simpan versi hash!
    sheet.getRange(rowNum, 6).setValue('TIDAK'); // Kembalikan status 'Diubah Guru' menjadi TIDAK

    // --- AKHIR PERBAIKAN UTAMA ---
    
    SpreadsheetApp.flush();

    return {
      status: 'success',
      message: 'Kredensial baru telah dibuat dan dikirim ke email Anda.'
    };
  } catch (e) {
    Logger.log("regenerateGuruCredentials Error: " + e.message + " Stack: " + e.stack);
    return { status: 'error', message: e.message };
  }
}

/**
 * [MODIFIKASI - v5] Mengambil data lengkap untuk halaman nilai guru, termasuk status kunci pengiriman.
 */
function getNilaiPageData_Guru(spreadsheetId, username, mapelKode, tipeNilai, className = null) {
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    
    // Panggil data-data yang sudah ada
    const students = getStudentsForGuru(spreadsheetId, className);
    const schoolData = getSchoolData(spreadsheetId);
    const jenjang = schoolData ? schoolData.jenjang : null;
    const { savedValues, submittedValues, approvalStatus, submissionIds } = getGuruNilai(spreadsheetId, username, mapelKode);
    const kkmData = getKkm(spreadsheetId);

    // Dapatkan ID pengajuan spesifik untuk tipe nilai ini
    const specificSubmissionId = submissionIds[tipeNilai] || null;
    const batchStatus = { allApproved: isSubmissionFullyApproved(spreadsheetId, specificSubmissionId) };
    
    // ===== PERUBAHAN UTAMA ADA DI SINI =====
    // Periksa status kunci berdasarkan kelas dan tipe nilai
    const isLockedForGuru = isSubmissionLockedFor(spreadsheetId, className, tipeNilai);
    // =======================================

    return {
      status: "success",
      students: students,
      jenjang: jenjang,
      kkm: kkmData.kkm,
      savedValues: savedValues,
      submittedValues: submittedValues,
      approvalStatus: approvalStatus,
      submissionId: specificSubmissionId,
      batchStatus: batchStatus,
      isLockedForGuru: isLockedForGuru // <-- Properti baru dikirim ke frontend
    };

  } catch(e) {
    Logger.log("getNilaiPageData_Guru Error: " + e.message + " | Stack: " + e.stack);
    return { status: "error", message: "Gagal memuat data nilai secara teroptimasi: " + e.message };
  }
}

// TAMBAHKAN DUA FUNGSI BARU INI DI Kode.gs.html

/**
 * [BARU] Menangani pengiriman ulang nilai yang telah direvisi oleh guru.
 * Fungsi ini tidak membuat baris baru, tetapi memperbarui baris yang statusnya 'Ditolak'.
 * @param {object} payload Objek berisi { spreadsheetId, username, nama, submissionId, tipeNilai, nilaiRevisi }
 * @returns {object} Hasil operasi.
 */
function resubmitRevisedNilai(payload) {
  const { spreadsheetId, username, nama, submissionId, tipeNilai, nilaiRevisi } = payload; // Ambil mapelKode dari payload sebagai cadangan
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet) throw new Error("Sheet pengajuan tidak ditemukan.");

    const approvalDataRange = approvalSheet.getDataRange();
    const approvalFullData = approvalDataRange.getValues();

    // =========================================================================
    // === AWAL LOGIKA PERBAIKAN: Menemukan Kode Mapel yang Benar ===
    // =========================================================================
    let mapelKode = payload.mapelKode; // Gunakan dari payload sebagai prioritas
    if (!mapelKode) {
        // Jika tidak ada di payload, cari dari baris lain dengan ID Pengajuan yang sama
        for(let i = 1; i < approvalFullData.length; i++) {
            if (approvalFullData[i][0].toString() === submissionId) {
                mapelKode = approvalFullData[i][2]; // Kolom C adalah Kode Mapel
                break;
            }
        }
    }
    // Jika masih tidak ditemukan, lemparkan error
    if (!mapelKode) {
        throw new Error("Tidak dapat menemukan Kode Mapel yang terkait dengan pengajuan ini. Silakan hubungi admin.");
    }
    // =========================================================================
    // === AKHIR LOGIKA PERBAIKAN ================================================
    // =========================================================================

    // Memperbarui SHEET_NILAI_GURU_SUBMITTED agar nilai langsung muncul di portal guru
    let submittedSheet = ss.getSheetByName(SHEET_NILAI_GURU_SUBMITTED);
    if (!submittedSheet) {
      submittedSheet = ss.insertSheet(SHEET_NILAI_GURU_SUBMITTED).hideSheet();
      submittedSheet.appendRow(["Username", "MapelKode", "Tipe", "NilaiJSON", "Tanggal"]);
    }
    const submittedData = submittedSheet.getDataRange().getValues();
    let submittedRowIndex = -1;
    for (let i = 1; i < submittedData.length; i++) {
        if (submittedData[i][0] === username && submittedData[i][1] === mapelKode && submittedData[i][2] === tipeNilai) {
            submittedRowIndex = i + 1;
            break;
        }
    }
    if (submittedRowIndex !== -1) {
        const existingNilaiJSON = submittedSheet.getRange(submittedRowIndex, 4).getValue();
        const existingNilai = existingNilaiJSON ? JSON.parse(existingNilaiJSON) : {};
        const mergedNilai = { ...existingNilai, ...nilaiRevisi };
        submittedSheet.getRange(submittedRowIndex, 4).setValue(JSON.stringify(mergedNilai));
        submittedSheet.getRange(submittedRowIndex, 5).setValue(new Date());
    } else {
        submittedSheet.appendRow([username, mapelKode, tipeNilai, JSON.stringify(nilaiRevisi), new Date()]);
    }

    // Memperbarui SHEET_PENGAJUAN_NILAI untuk admin
    const headers = approvalFullData[0];
    const submissionIdCol = headers.indexOf("ID Pengajuan");
    const nisnCol = headers.indexOf("NISN");
    const tipeNilaiCol = headers.indexOf("Tipe Nilai");
    const statusCol = headers.indexOf("Status");
    const nilaiCol = headers.indexOf("Nilai");
    const tanggalCol = headers.indexOf("Tanggal Ajuan");
    let updatedCount = 0;
    const rowsToAdd = [];
    const students = getStudentsForGuru(spreadsheetId);
    const studentMap = new Map(students.map(s => [s.nisn.toString(), s.nama]));

    for (const [key, value] of Object.entries(nilaiRevisi)) {
      if (value === null || String(value).trim() === '') continue;
      const parts = key.split('_');
      const nisn = parts[0];
      const subTipe = parts[1];
      const tipeCari = tipeNilai === 'ujian' ? `ujian_${subTipe}` : `${tipeNilai}_${subTipe}`;
      let foundAndUpdated = false;
      for (let i = 1; i < approvalFullData.length; i++) {
        const row = approvalFullData[i];
        if (row[submissionIdCol].toString() === submissionId && row[nisnCol].toString() === nisn && row[tipeNilaiCol] === tipeCari && row[statusCol] === 'Ditolak') {
          approvalSheet.getRange(i + 1, nilaiCol + 1).setValue(value);
          approvalSheet.getRange(i + 1, tanggalCol + 1).setValue(new Date());
          approvalSheet.getRange(i + 1, statusCol + 1).setValue('Menunggu Persetujuan');
          updatedCount++;
          foundAndUpdated = true;
          break;
        }
      }
      if (!foundAndUpdated) {
        rowsToAdd.push([submissionId, username, mapelKode, tipeCari, "'" + nisn, studentMap.get(nisn) || 'Siswa tidak ditemukan', value, new Date(), 'Menunggu Persetujuan']);
        updatedCount++;
      }
    }
    if (rowsToAdd.length > 0) {
      approvalSheet.getRange(approvalSheet.getLastRow() + 1, 1, rowsToAdd.length, rowsToAdd[0].length).setValues(rowsToAdd);
    }
    if (updatedCount > 0) {
      return { status: 'success', message: `${updatedCount} nilai yang direvisi berhasil dikirim kembali.` };
    } else {
      return { status: 'info', message: 'Tidak ada nilai yang direvisi untuk dikirim ulang.' };
    }
  } catch(e) {
    Logger.log("resubmitRevisedNilai Error: " + e.message + " Stack: " + e.stack);
    return { status: "error", message: "Gagal mengirim ulang nilai revisi: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [MODIFIKASI] Membatalkan pengiriman nilai oleh guru.
 * Kini juga akan menghapus semua entri terkait dari sheet persetujuan.
 */
function cancelGuruSubmission(payload) {
    const { spreadsheetId, username, mapelKode, type } = payload;
    const ss = SpreadsheetApp.openById(spreadsheetId);
    
    // Hapus dari sheet nilai terkirim dan kembalikan ke draf
    let submittedSheet = ss.getSheetByName(SHEET_NILAI_GURU_SUBMITTED);
    let submissionIdToDelete = null;

    if (submittedSheet) {
        const data = submittedSheet.getDataRange().getValues();
        for (let i = data.length - 1; i >= 1; i--) {
            if (data[i][0] === username && data[i][1] === mapelKode && data[i][2] === type) {
                const nilaiJSON = data[i][3];
                // Cari submissionId dari sheet 'Pengajuan Nilai' berdasarkan data ini
                const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
                if(approvalSheet) {
                  const approvalData = approvalSheet.getDataRange().getValues();
                  const foundRow = approvalData.find(row => row[1] === username && row[2] === mapelKode && (row[3].startsWith(type)));
                  if(foundRow) submissionIdToDelete = foundRow[0];
                }

                saveGuruDraftNilai({ spreadsheetId, username, mapelKode, type: type, nilai: JSON.parse(nilaiJSON) });
                submittedSheet.deleteRow(i + 1);
                break; // Hanya batalkan pengiriman terakhir
            }
        }
    }

    // Hapus semua baris terkait di sheet pengajuan
    if (submissionIdToDelete) {
        const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
        if (approvalSheet) {
            const approvalData = approvalSheet.getRange("A:A").getValues().flat();
            for (let i = approvalData.length - 1; i >= 1; i--) {
                if (approvalData[i] === submissionIdToDelete) {
                    approvalSheet.deleteRow(i + 1);
                }
            }
        }
    }
    
    if(submissionIdToDelete) {
      return { status: 'success', message: 'Pengiriman dibatalkan. Nilai dikembalikan ke draf.' };
    } else {
      return { status: 'error', message: 'Data terkirim tidak ditemukan untuk dibatalkan.' };
    }
}

// GANTI FUNGSI LAMA getGuruEditorData DENGAN VERSI BARU INI

// GANTI FUNGSI LAMA DENGAN VERSI BARU INI
/**
 * [DIPERBARUI] Mengambil data untuk editor guru.
 * Daftar kelas sekarang diambil dari fungsi getKelas yang terpusat.
 */
function getGuruEditorData(spreadsheetId) {
  try {
    const allMapel = getMapel(spreadsheetId);
    // ===== PERUBAHAN DI SINI =====
    // Mengambil daftar kelas dari 'Pengaturan', bukan dari data siswa lagi.
    const kelasData = getKelas(spreadsheetId); 
    const allKelas = kelasData.status === 'success' ? kelasData.kelasList : [];
    // =============================

    return {
      allMapel: allMapel,
      allKelas: allKelas.sort() // Kembalikan sebagai array yang sudah diurutkan
    };
  } catch (e) {
    Logger.log("getGuruEditorData Error: " + e.message);
    return { allMapel: [], allKelas: [] };
  }
}

// TAMBAHKAN DUA FUNGSI BARU INI

/**
 * [BARU] Menyimpan daftar kelas ke dalam sheet 'Pengaturan'.
 * Daftar kelas disimpan sebagai string yang dipisahkan koma.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} kelasString String berisi daftar kelas, dipisahkan koma.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveKelas(spreadsheetId, kelasString) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
        sheet = ss.insertSheet(SHEET_PENGATURAN);
        sheet.getRange("A1:B1").setValues([['Nama Pengaturan', 'Value']]).setFontWeight('bold');
    }
    
    const row = findOrCreateSettingRow(sheet, "Daftar Kelas");
    // Bersihkan spasi berlebih dan simpan
    const cleanedString = kelasString.split(',').map(k => k.trim()).filter(Boolean).join(',');
    sheet.getRange(row, 2).setValue(cleanedString);

    return { status: "success", message: "Daftar kelas berhasil disimpan." };
  } catch (e) {
    Logger.log(`saveKelas Error: ${e.message}`);
    return { status: "error", message: `Gagal menyimpan daftar kelas: ${e.message}` };
  }
}

/**
 * [BARU] Mengambil daftar kelas dari sheet 'Pengaturan'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, kelasList: Array<string>}} Objek berisi daftar kelas.
 */
function getKelas(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
      return { status: 'success', kelasList: [] };
    }
    const data = sheet.getRange("A:B").getValues();
    const settingRow = data.find(row => row[0] === "Daftar Kelas");
    
    if (settingRow && settingRow[1]) {
      const kelasList = settingRow[1].toString().split(',');
      return { status: 'success', kelasList: kelasList };
    }
    
    return { status: 'success', kelasList: [] }; // Kembalikan array kosong jika belum diatur
  } catch (e) {
    Logger.log(`getKelas Error: ${e.message}`);
    return { status: 'error', message: e.message, kelasList: [] };
  }
}

// Tambahkan fungsi baru ini di Kode.gs.html
function getSiswaTanpaKelas(spreadsheetId) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
        if (!sheet || sheet.getLastRow() < 2) {
            return { status: 'success', data: [] };
        }
        
        // Baca data termasuk kolom Kelas (kolom N, indeks 13)
        const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 14).getValues();

        const siswaTanpaKelas = data
            .filter(row => !row[13] || row[13].toString().trim() === '') // Filter baris dimana kolom kelas kosong
            .map(row => ({
                nisn: row[0],
                nama: row[3],
                jenisKelamin: row[4],
                tempatLahir: row[5],
                tanggalLahir: row[6] instanceof Date ? row[6].toISOString() : null,
            }))
            .sort((a, b) => a.nama.localeCompare(b.nama)); // Urutkan berdasarkan nama
        
        return { status: 'success', data: siswaTanpaKelas };

    } catch (e) {
        Logger.log(`getSiswaTanpaKelas Error: ${e.message}`);
        return { status: 'error', message: `Gagal mengambil data: ${e.message}` };
    }
}

// File: Kode.gs.html
// TAMBAHKAN FUNGSI BARU INI

/**
 * [BARU] Mengambil daftar lengkap siswa untuk ditampilkan di Portal Guru.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @returns {object} Objek berisi status dan daftar lengkap siswa.
 */
function getStudentListForGuru(spreadsheetId) {
    try {
        // Menggunakan kembali fungsi getStudents() yang sudah ada dan lengkap
        const students = getStudents(spreadsheetId); 
        return { status: 'success', data: students };
    } catch (e) {
        Logger.log(`getStudentListForGuru Error: ${e.message}`);
        return { status: 'error', message: e.message, data: [] };
    }
}

// File: Kode.gs.html
// TAMBAHKAN DUA FUNGSI BARU INI

/**
 * [BARU] Guru memperbarui data pribadinya (Nama & NIP).
 * Aksi ini TIDAK akan mengubah status 'Diubah Guru'.
 */
function updateGuruData_Guru(spreadsheetId, username, data) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_GURU);
    const usernames = sheet.getRange(2, 2, sheet.getLastRow() - 1, 1).getDisplayValues().flat();
    const guruIndex = usernames.findIndex(u => u === username);

    if (guruIndex === -1) {
      throw new Error("Profil guru tidak ditemukan untuk diperbarui.");
    }
    const rowToUpdate = guruIndex + 2;
    
    // Update Nama (kolom A) dan NIP (kolom E)
    sheet.getRange(rowToUpdate, 1).setValue(data.nama);
    sheet.getRange(rowToUpdate, 5).setValue(data.nip ? "'" + data.nip : '');
    
    return { status: 'success', message: 'Data pribadi berhasil diperbarui.' };
  } catch(e) {
    Logger.log(`updateGuruData_Guru Error: ${e.message}`);
    return { status: 'error', message: 'Gagal memperbarui data pribadi: ' + e.message };
  }
}

/**
 * [BARU & DIPERBAIKI KEAMANANNYA] Guru memperbarui kredensial loginnya sendiri,
 * memastikan password baru selalu di-hash.
 */
function updateGuruCredentials_Guru(spreadsheetId, oldUsername, newData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_GURU);
    const usernames = sheet.getRange(2, 2, sheet.getLastRow() - 1, 1).getDisplayValues().flat();
    const guruIndex = usernames.findIndex(u => u === oldUsername);

    if (guruIndex === -1) {
      throw new Error("Profil guru tidak ditemukan.");
    }
    const rowToUpdate = guruIndex + 2;
    
    // Cek duplikasi username jika diubah
    if(newData.username.toLowerCase() !== oldUsername.toLowerCase()) {
        const isDuplicate = usernames.some((u, index) => index !== guruIndex && u.toLowerCase() === newData.username.toLowerCase());
        if(isDuplicate) {
            return { status: 'error', message: 'Username baru sudah digunakan oleh guru lain.' };
        }
    }

    // --- AWAL PERBAIKAN KEAMANAN ---

    // 1. Buat salt dan hash untuk password baru.
    const salt = generateSalt();
    const hashedPassword = hashPassword(newData.password, salt);
    const newStoredPasswordString = `${salt}:${hashedPassword}`;
    
    // 2. Update Username (B), Password (C) dengan HASH BARU, dan set 'Diubah Guru' (F) menjadi 'YA'
    sheet.getRange(rowToUpdate, 2).setValue(newData.username);
    sheet.getRange(rowToUpdate, 3).setValue(newStoredPasswordString); // <-- SIMPAN HASH
    sheet.getRange(rowToUpdate, 6).setValue('YA');

    // --- AKHIR PERBAIKAN KEAMANAN ---

    return { status: 'success', message: 'Kredensial login berhasil diperbarui.' };
  } catch(e) {
    Logger.log(`updateGuruCredentials_Guru Error: ${e.message}`);
    return { status: 'error', message: 'Gagal memperbarui akun login: ' + e.message };
  }
}

// File: Kode.gs.html
// TAMBAHKAN FUNGSI BARU INI

/**
 * [AKSI MASSAL BARU] Memperbarui kolom Kelas (N) dan Ruang Ujian (O) untuk beberapa siswa sekaligus.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<number>} rowNumbers Array berisi nomor baris siswa yang akan diupdate.
 * @param {string} newKelas Nama kelas baru.
 * @param {string} newRuang Nama ruang baru.
 * @returns {object} Status operasi.
 */
function bulkUpdateKelasAndRuang(spreadsheetId, rowNumbers, newKelas, newRuang) {
  try {
    if (!rowNumbers || rowNumbers.length === 0) {
      return { status: "info", message: "Tidak ada siswa yang dipilih." };
    }
    if (!newKelas && !newRuang) {
      return { status: "error", message: "Harap isi kolom Kelas atau Ruang." };
    }
      
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    const kelasColumn = 14;
    const ruangColumn = 15;
    
    rowNumbers.forEach(rowNum => {
      if (newKelas) {
        sheet.getRange(rowNum, kelasColumn).setValue(newKelas);
      }
      if (newRuang) {
        sheet.getRange(rowNum, ruangColumn).setValue(newRuang);
      }
    });

    // [MODIFIKASI] Panggil fungsi penyortiran setelah mengubah data kelas secara massal
    sortAndRewriteStudentSheet(spreadsheetId);

    SpreadsheetApp.flush();
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: `${rowNumbers.length} data siswa berhasil diupdate.`,
      updatedStudentList: updatedStudentList
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengupdate data kelas/ruang secara massal: " + e.message };
  }
}

/**
 * [VERSI FINAL 3.0] Mengurutkan siswa dengan mengelompokkan per kelas terlebih dahulu
 * untuk memastikan integritas urutan kelas secara global, sambil menerapkan
 * urutan manual baru pada kelas yang relevan.
 */
function saveSiswaOrder(spreadsheetId, orderedNisnList) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Menunggu hingga 30 detik jika ada proses lain

  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (sheet.getLastRow() < 2) {
      return { status: "error", message: "Tidak ada data siswa untuk diurutkan." };
    }

    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn());
    const allData = dataRange.getValues();

    // 1. Buat Peta (Map) dari urutan baru yang dikirim frontend untuk pencarian cepat.
    const newOrderMap = new Map(orderedNisnList.map((nisn, index) => [String(nisn), index]));

    // 2. Kelompokkan semua siswa berdasarkan kelas mereka.
    const studentsByClass = {};
    allData.forEach(row => {
      const className = row[13] || 'Tanpa Kelas'; // Kolom kelas adalah indeks ke-13
      if (!studentsByClass[className]) {
        studentsByClass[className] = [];
      }
      studentsByClass[className].push(row);
    });

    // 3. Urutkan siswa di dalam setiap grup kelas.
    for (const className in studentsByClass) {
      studentsByClass[className].sort((a, b) => {
        const nisnA = String(a[0]);
        const nisnB = String(b[0]);
        const aIsInNewOrder = newOrderMap.has(nisnA);
        const bIsInNewOrder = newOrderMap.has(nisnB);

        // Jika kedua siswa ada di dalam daftar yang baru diurutkan, gunakan urutan baru tersebut.
        if (aIsInNewOrder && bIsInNewOrder) {
          return newOrderMap.get(nisnA) - newOrderMap.get(nisnB);
        }
        // Jika tidak, biarkan posisi relatif mereka seperti semula (tidak mengubah urutan siswa di kelas lain).
        return 0;
      });
    }

    // 4. Dapatkan nama-nama kelas dan urutkan nama-nama tersebut menggunakan fungsi getSortableClassKey
    const sortedClassNames = Object.keys(studentsByClass).sort((a, b) => {
      const keyA = getSortableClassKey(a);
      const keyB = getSortableClassKey(b);
      // Logika perbandingan yang sama seperti di frontend
      if (keyA[0] < keyB[0]) return -1;
      if (keyA[0] > keyB[0]) return 1;
      if (keyA[1] < keyB[1]) return -1;
      if (keyA[1] > keyB[1]) return 1;
      return 0;
    });

    // 5. Gabungkan kembali semua grup siswa menjadi satu daftar akhir yang terurut sempurna.
    const finalSortedData = [];
    sortedClassNames.forEach(className => {
      finalSortedData.push(...studentsByClass[className]);
    });

    // 6. Tulis ulang seluruh data ke sheet.
    dataRange.clearContent();
    if (finalSortedData.length > 0) {
      sheet.getRange(2, 1, finalSortedData.length, finalSortedData[0].length).setValues(finalSortedData);
    }
    
    SpreadsheetApp.flush();
    
    // 7. Ambil kembali data yang sudah 100% benar dari sheet untuk dikirim ke frontend.
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: "Urutan siswa berhasil disimpan.",
      updatedStudentList: updatedStudentList
    };

  } catch (e) {
    Logger.log(e);
    return { status: "error", message: `Gagal menyimpan urutan: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

// File: Kode.gs.html

/**
 * [PERBAIKAN] Membuat template Excel untuk diisi nilai oleh guru.
 * Versi ini sudah di-upgrade untuk menyertakan nilai yang sudah ada (draf/terkirim) ke dalam template.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @param {string} className Nama kelas yang dipilih.
 * @param {string} mapelKode Kode mata pelajaran yang dipilih.
 * @param {string} tipeNilai Tipe nilai (misal: 'ujian' atau 'rapor_k4_ganjil').
 * @param {object} guruData Data guru yang sedang login.
 * @returns {object} Objek file Excel yang siap diunduh.
 */
function generateNilaiTemplateForGuru(spreadsheetId, className, mapelKode, tipeNilai, guruData) {
  let tempFile;
  try {
    const ss = SpreadsheetApp.create(`Template_Guru_${mapelKode}_${tipeNilai}_${new Date().getTime()}`);
    tempFile = DriveApp.getFileById(ss.getId());
    const sheet = ss.getSheets()[0];

    const students = getStudentsForGuru(spreadsheetId, className);
    const allMapel = getMapel(spreadsheetId);
    const mapelInfo = allMapel.find(m => m.kode === mapelKode);
    if (!mapelInfo) throw new Error("Mata pelajaran tidak ditemukan.");
    if (!guruData || !guruData.nama) throw new Error("Data guru tidak lengkap.");

    // ==========================================================
    // === AWAL BLOK KODE BARU: Mengambil Nilai yang Sudah Ada ===
    // ==========================================================
    const nilaiInfo = getGuruNilai(spreadsheetId, guruData.username, mapelKode);
    const isSubmitted = nilaiInfo.submittedValues && nilaiInfo.submittedValues[tipeNilai];
    const dataNilai = isSubmitted 
        ? (nilaiInfo.submittedValues[tipeNilai] || {}) 
        : (nilaiInfo.savedValues ? (nilaiInfo.savedValues[tipeNilai] || {}) : {});
    // ==========================================================
    // === AKHIR BLOK KODE BARU =================================
    // ==========================================================
    
    let headers = ["NISN", "Nama Siswa"];
    let keteranganSingkatan = [];
    let fileNameSuffix = '';
    const semesterNameMap = {
        k4_ganjil: 'Kelas_4_Ganjil', k4_genap: 'Kelas_4_Genap', k5_ganjil: 'Kelas_5_Ganjil', k5_genap: 'Kelas_5_Genap', k6_ganjil: 'Kelas_6_Ganjil',
        k7_ganjil: 'Kelas_7_Ganjil', k7_genap: 'Kelas_7_Genap', k8_ganjil: 'Kelas_8_Ganjil', k8_genap: 'Kelas_8_Genap', k9_ganjil: 'Kelas_9_Ganjil',
        k10_ganjil: 'Kelas_10_Ganjil', k10_genap: 'Kelas_10_Genap', k11_ganjil: 'Kelas_11_Ganjil', k11_genap: 'Kelas_11_Genap', k12_ganjil: 'Kelas_12_Ganjil'
    };

    if (tipeNilai === 'ujian') {
      fileNameSuffix = 'Ujian';
      if (mapelInfo.jenisUjian === 'Ujian Madrasah' || mapelInfo.jenisUjian === 'Keduanya') { headers.push("UM"); keteranganSingkatan.push("UM = Ujian Madrasah"); }
      if (mapelInfo.jenisUjian === 'Ujian Praktek' || mapelInfo.jenisUjian === 'Keduanya') { headers.push("UPr"); keteranganSingkatan.push("UPr = Ujian Praktek"); }
    } else if (tipeNilai.startsWith('rapor_')) {
      const semesterKey = tipeNilai.substring(6);
      fileNameSuffix = `Rapor_${semesterNameMap[semesterKey] || semesterKey}`;
      headers.push("Pengetahuan");
      headers.push("Keterampilan");
    }
    sheet.setName(tipeNilai);

    const keteranganHeader = [
      ["Mata Pelajaran", `: ${mapelInfo.nama}`], ["Kelas", `: ${className}`], ["Guru", `: ${guruData.nama}`],
      ["Petunjuk", ": Isi atau ubah nilai pada kolom yang sesuai. Kolom NISN dan Nama Siswa jangan diubah."],
      ["Keterangan", `: ${keteranganSingkatan.join('; ')}`]
    ];
    sheet.getRange("A1:B5").setValues(keteranganHeader).setFontStyle("italic");
    sheet.getRange("A1:A5").setFontWeight("bold");
    sheet.getRange(7, 1, 1, headers.length).setValues([headers]).setFontWeight("bold").setBackground("#d9ead3");

    if (students && students.length > 0) {
      const rowsToWrite = students.map(s => {
        const studentRow = ["'" + s.nisn, s.nama];
        // ===============================================================
        // === AWAL BLOK KODE BARU: Mengisi nilai yang sudah ada =========
        // ===============================================================
        if (tipeNilai === 'ujian') {
            if (headers.includes("UM")) { studentRow.push(dataNilai[`${s.nisn}_um`] || ''); }
            if (headers.includes("UPr")) { studentRow.push(dataNilai[`${s.nisn}_upr`] || ''); }
        } else if (tipeNilai.startsWith('rapor_')) {
            studentRow.push(dataNilai[`${s.nisn}_peng`] || '');
            studentRow.push(dataNilai[`${s.nisn}_ket`] || '');
        }
        // ===============================================================
        // === AKHIR BLOK KODE BARU =======================================
        // ===============================================================
        return studentRow;
      });
      sheet.getRange(8, 1, rowsToWrite.length, headers.length).setValues(rowsToWrite);
    }
    sheet.getRange("A:A").setNumberFormat('@');
    sheet.autoResizeColumns(1, headers.length);

    SpreadsheetApp.flush();
    const url = `https://www.googleapis.com/drive/v3/files/${ss.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, { headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` }, muteHttpExceptions: true });
    const blob = response.getBlob();
    const finalFileName = `Template_Nilai_${mapelKode}_${className}_${fileNameSuffix}.xlsx`;

    return {
      fileName: finalFileName,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

/**
 * Mengimpor nilai dari Excel dan menyimpannya sebagai draf untuk guru.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @param {object} fileData Data file yang diunggah.
 * @param {string} username Username guru yang mengimpor.
 * @param {string} mapelKode Kode mata pelajaran.
 * @param {string} tipeNilai Tipe nilai yang diimpor.
 * @returns {object} Hasil proses impor.
 */
function importNilaiFromExcelForGuru(spreadsheetId, fileData, username, mapelKode, tipeNilai) {
    let tempFile;
    try {
        const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
        const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
        const tempSpreadsheetFile = Drive.Files.insert({ title: `temp_import_guru_${new Date().getTime()}` }, blob, { convert: true });
        tempFile = DriveApp.getFileById(tempSpreadsheetFile.id);
        const importSheet = SpreadsheetApp.openById(tempFile.getId()).getSheets()[0];
        const allData = importSheet.getDataRange().getDisplayValues();

        if (allData.length < 2) throw new Error("File kosong atau tidak berisi data yang valid.");
        
        // [PERBAIKAN] Logika baru untuk menemukan baris header secara dinamis
        let headerRowIndex = -1;
        for (let i = 0; i < allData.length; i++) {
            if (allData[i][0] === 'NISN' && allData[i][1] === 'Nama Siswa') {
                headerRowIndex = i;
                break;
            }
        }

        if (headerRowIndex === -1) {
            throw new Error("Kolom 'NISN' dan 'Nama Siswa' tidak ditemukan di file Excel. Pastikan menggunakan template yang benar.");
        }

        const headers = allData[headerRowIndex];
        const dataRows = allData.slice(headerRowIndex + 1); // Ambil semua baris di bawah header
        
        const nisnIndex = headers.indexOf("NISN");
        
        const nilaiToSave = {};
        let importedCount = 0;

        dataRows.forEach(row => {
            const nisn = row[nisnIndex];
            if (!nisn || nisn.trim() === '') return;

            if (tipeNilai === 'ujian') {
                const umIndex = headers.indexOf("UM");
                const uprIndex = headers.indexOf("UPr");
                if (umIndex !== -1 && row[umIndex] !== '') {
                    nilaiToSave[`${nisn}_um`] = row[umIndex];
                    importedCount++;
                }
                if (uprIndex !== -1 && row[uprIndex] !== '') {
                    nilaiToSave[`${nisn}_upr`] = row[uprIndex];
                    importedCount++;
                }
            } else if (tipeNilai.startsWith('rapor_')) {
                const pengIndex = headers.indexOf("Pengetahuan");
                const ketIndex = headers.indexOf("Keterampilan");
                if (pengIndex !== -1 && row[pengIndex] !== '') {
                    nilaiToSave[`${nisn}_peng`] = row[pengIndex];
                    importedCount++;
                }
                if (ketIndex !== -1 && row[ketIndex] !== '') {
                    nilaiToSave[`${nisn}_ket`] = row[ketIndex];
                    importedCount++;
                }
            }
        });

        if (importedCount === 0) {
            return { status: "info", message: "Tidak ada data nilai baru yang ditemukan di dalam file." };
        }

        const payload = {
            spreadsheetId,
            username,
            mapelKode,
            type: tipeNilai,
            nilai: nilaiToSave
        };
        const saveResult = saveGuruDraftNilai(payload);

        if (saveResult.status === 'success') {
            return { status: "success", message: `${importedCount} nilai berhasil diimpor sebagai draf.` };
        } else {
            throw new Error(saveResult.message);
        }

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: `Gagal mengimpor data: ${e.toString()}` };
    } finally {
        if (tempFile) {
            tempFile.setTrashed(true);
        }
    }
}

/**
 * [BARU] Memproses satu "batch" pengajuan nilai. Dirancang untuk dipanggil berulang kali.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {Array<number>} rowNumbers - Array nomor baris dalam batch ini.
 * @param {string} status - Keputusan ("Disetujui" atau "Ditolak").
 * @returns {object} Hasil proses batch.
 */
function processApprovalChunk_Admin(spreadsheetId, rowNumbers, status) {
  try {
    let successCount = 0;
    
    rowNumbers.forEach(rowNum => {
      // Memanggil fungsi yang sudah ada untuk setiap item dalam batch
      const result = processNilaiSubmission(spreadsheetId, rowNum, status);
      if (result.status === 'success') {
        successCount++;
      }
    });

    return { status: "success", message: `${successCount} item dalam batch berhasil diproses.` };
  } catch(e) {
    Logger.log("processApprovalChunk_Admin Error: " + e.message);
    return { status: "error", message: e.message };
  }
}

/**
 * [BARU - DIPERBAIKI] Mengubah angka Romawi menjadi integer untuk keperluan sorting.
 * @param {string} s - String angka Romawi.
 * @returns {number} Angka integer.
 */
function romanToInt(s) {
    const map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50 };
    let result = 0;
    for (let i = 0; i < s.length; i++) {
        const current = map[s[i].toUpperCase()];
        if (!current) continue;
        const next = map[s[i + 1] ? s[i + 1].toUpperCase() : ''] ? map[s[i + 1].toUpperCase()] : 0;
        if (next > current) {
            result += next - current;
            i++;
        } else {
            result += current;
        }
    }
    return result;
}

/**
 * [BARU - DIPERBAIKI] Membuat kunci yang bisa diurutkan dari nama kelas.
 * Kini dapat menangani format seperti "VI.A", "10 IPA 1", dll.
 * @param {string} className - Nama kelas.
 * @returns {Array} Array berisi [angka_kelas, teks_kelas] untuk sorting.
 */
function getSortableClassKey(className) {
    if (!className || typeof className !== 'string') {
        return [Infinity, '']; // Menempatkan siswa tanpa kelas di akhir.
    }
    const trimmedClass = className.trim();
    
    // Coba deteksi angka Romawi (I-XII) di awal string
    const romanMatch = trimmedClass.match(/^(XII|XI|X|IX|IV|V?I{0,3})(.*)/i);
    if (romanMatch) {
        const numPart = romanToInt(romanMatch[1]);
        const textPart = (romanMatch[2] || '').toLowerCase().trim();
        return [numPart, textPart];
    }

    // Coba deteksi angka Arab di awal string
    const numericMatch = trimmedClass.match(/^(\d+)(.*)/);
    if (numericMatch) {
        const numPart = parseInt(numericMatch[1], 10);
        const textPart = (numericMatch[2] || '').toLowerCase().trim();
        return [numPart, textPart];
    }

    // Default untuk kelas yang tidak diawali angka (cth: "Bahasa")
    return [Infinity, trimmedClass.toLowerCase()];
}

/**
 * [BARU & INTI - DIPERBAIKI] Mengambil semua data siswa, mengurutkannya, dan menulis ulang ke sheet.
 * Fungsi ini menjaga urutan asli untuk siswa di kelas yang sama.
 * @param {string} spreadsheetId - ID dari spreadsheet yang akan diurutkan.
 */
function sortAndRewriteStudentSheet(spreadsheetId) {
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
        if (!sheet || sheet.getLastRow() < 2) {
            return;
        }

        const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn());
        const values = dataRange.getValues();

        // Buat objek sementara untuk diurutkan, dengan menyertakan data baris asli
        let studentsToSort = values.map((row) => ({
            originalRowData: row,
            kelas: row[13] || '' // Kolom Kelas adalah indeks 13 (kolom N)
        }));

        // Urutkan array siswa. Sort() di Apps Script bersifat stabil,
        // yang berarti urutan asli akan dipertahankan jika hasil perbandingan 0.
        studentsToSort.sort((a, b) => {
            const keyA = getSortableClassKey(a.kelas);
            const keyB = getSortableClassKey(b.kelas);

            // 1. Urutkan berdasarkan angka kelas
            if (keyA[0] < keyB[0]) return -1;
            if (keyA[0] > keyB[0]) return 1;

            // 2. Jika angka sama, urutkan berdasarkan sisa teksnya (cth: ".a" vs ".b")
            if (keyA[1] < keyB[1]) return -1;
            if (keyA[1] > keyB[1]) return 1;
            
            // 3. Jika kelas sama persis, kembalikan 0 untuk mempertahankan urutan input asli.
            return 0;
        });

        // Ambil kembali data baris yang sudah terurut
        const sortedValues = studentsToSort.map(item => item.originalRowData);

        // Hapus data lama dan tulis ulang data yang sudah terurut
        dataRange.clearContent();
        if (sortedValues.length > 0) {
            sheet.getRange(2, 1, sortedValues.length, sortedValues[0].length).setValues(sortedValues);
        }
        
    } catch (e) {
        Logger.log("Error during student sort: " + e.message);
    } finally {
        lock.releaseLock();
    }
}

/**
 * [VERSI FINAL 2.0] Mengambil status pengajuan yang sedang menunggu persetujuan.
 * Menghitung jumlah total yang menunggu, dan dari jumlah itu, berapa yang sudah disetujui/ditolak.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {string} username - Username guru yang sedang login.
 * @returns {object} Objek berisi rekapitulasi status pengajuan yang sedang aktif.
 */
function getPendingSubmissionStatus(spreadsheetId, username) {
  const result = {
    ujian: { pending: 0, approved: 0, rejected: 0 },
    rapor: { pending: 0, approved: 0, rejected: 0 },
    hasPending: false
  };

  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet || approvalSheet.getLastRow() < 2) {
      return result;
    }

    const data = approvalSheet.getDataRange().getValues();
    const activeSubmissions = {}; // Key: submissionId, Value: {tipe, statuses:[]}

    // Langkah 1: Kumpulkan semua status untuk setiap pengajuan dari guru yang sedang login
    for (let i = 1; i < data.length; i++) {
        const row = data[i];
        const guruPengirim = row[1];
        const status = row[8];
        const submissionId = row[0];

        if (guruPengirim === username) {
            if (!activeSubmissions[submissionId]) {
                 const tipeNilaiLengkap = row[3];
                 const kategori = tipeNilaiLengkap.startsWith('ujian') ? 'ujian' : 'rapor';
                 activeSubmissions[submissionId] = { tipe: kategori, statuses: [] };
            }
            activeSubmissions[submissionId].statuses.push(status);
        }
    }

    // Langkah 2: Proses hanya pengajuan yang memiliki item yang masih menunggu
    for (const subId in activeSubmissions) {
        const submission = activeSubmissions[subId];
        const hasPendingItems = submission.statuses.includes('Menunggu Persetujuan');

        if (hasPendingItems) {
            result.hasPending = true;
            const category = submission.tipe;
            
            // Hitung detail status untuk pengajuan aktif ini
            submission.statuses.forEach(status => {
                if (status === 'Menunggu Persetujuan') {
                    result[category].pending++;
                } else if (status === 'Disetujui') {
                    result[category].approved++;
                } else if (status === 'Ditolak') {
                    result[category].rejected++;
                }
            });
        }
    }
    
    return result;

  } catch (e) {
    Logger.log("getPendingSubmissionStatus Error: " + e.message);
    return result; 
  }
}

/**
 * [BARU - PENGGANTI] Fungsi helper untuk memeriksa apakah sebuah batch pengajuan
 * sudah disetujui sepenuhnya oleh admin.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {string} submissionId - ID unik dari batch pengajuan.
 * @returns {boolean} - True jika semua item disetujui, false jika tidak.
 */
function isSubmissionFullyApproved(spreadsheetId, submissionId) {
  if (!submissionId) return false;
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet || approvalSheet.getLastRow() < 2) {
      return false;
    }

    const data = approvalSheet.getRange(2, 1, approvalSheet.getLastRow() - 1, 9).getValues();
    const batchRows = data.filter(row => row[0].toString() === submissionId.toString());

    // Jika tidak ada baris yang cocok dengan ID, atau jika ada yang statusnya bukan 'Disetujui'
    if (batchRows.length === 0 || batchRows.some(row => row[8] !== 'Disetujui')) {
      return false;
    }
    
    // Jika semua baris ditemukan dan semuanya 'Disetujui'
    return true;

  } catch (e) {
    Logger.log(`isSubmissionFullyApproved Error: ${e.message}`);
    return false; // Anggap tidak disetujui jika terjadi error
  }
}

/**
 * [BARU] Mengambil konten untuk halaman Bantuan & Panduan dari sheet.
 * @returns {Array<object>} Array objek berisi data bantuan, diurutkan berdasarkan ID.
 */
function getHelpContent() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("KontenBantuan"); // Nama sheet yang baru dibuat
    if (!sheet || sheet.getLastRow() < 2) {
      return []; // Kembalikan array kosong jika sheet tidak ada atau kosong
    }

    // Ambil semua data dari baris ke-2 hingga baris terakhir
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 5).getValues();

    const helpItems = data
      .map(row => ({
        id: row[0],
        judul: row[1],
        deskripsi: row[2],
        konten: row[3],
        gambarUrl: row[4]
      }))
      .filter(item => item.id && item.judul); // Hanya ambil baris yang memiliki ID dan Judul

    // Urutkan berdasarkan kolom ID (kolom pertama)
    helpItems.sort((a, b) => a.id - b.id);

    return helpItems;
  } catch (e) {
    Logger.log("getHelpContent Error: " + e.message);
    return []; // Kembalikan array kosong jika terjadi error
  }
}

/**
 * [BARU] Mengambil konten untuk daftar Fitur Premium dari sheet.
 * @returns {Array<object>} Array objek berisi data fitur, diurutkan berdasarkan ID.
 */
function getPremiumFeaturesContent() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // Pastikan nama sheet ini sama persis dengan yang Anda buat
    const sheet = ss.getSheetByName("KontenFiturPremium"); 
    if (!sheet || sheet.getLastRow() < 2) {
      return [];
    }

    // Ambil semua data dari baris ke-2 hingga baris terakhir, dari kolom A hingga D
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4).getValues();

    const featureItems = data
      .map(row => ({
        id: row[0],
        judul: row[1],
        deskripsi: row[2],
        gambarUrl: row[3]
      }))
      .filter(item => item.id && item.judul); // Hanya ambil baris yang valid

    // Urutkan berdasarkan kolom ID
    featureItems.sort((a, b) => a.id - b.id);

    return featureItems;
  } catch (e) {
    Logger.log("getPremiumFeaturesContent Error: " + e.message);
    // Jika error, kembalikan array kosong agar aplikasi tidak rusak
    return []; 
  }
}

/**
 * [SUPERADMIN] Menyimpan atau memperbarui seluruh konten Bantuan & Panduan.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {Array<object>} allHelpData - Array berisi seluruh objek data bantuan dari frontend.
 * @returns {object} Status penyimpanan.
 */
function saveHelpContent(adminEmail, allHelpData) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("KontenBantuan");

    // Hapus semua data lama (dari baris 2 ke bawah)
    if (sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }

    if (allHelpData && allHelpData.length > 0) {
      const rowsToWrite = allHelpData.map(item => [
        item.id,
        item.judul,
        item.deskripsi,
        item.konten,
        item.gambarUrl
      ]);
      // Tulis semua data baru dalam satu operasi
      sheet.getRange(2, 1, rowsToWrite.length, rowsToWrite[0].length).setValues(rowsToWrite);
    }

    return { status: "success", message: "Konten Bantuan & Panduan berhasil diperbarui." };
  } catch (e) {
    Logger.log("saveHelpContent Error: " + e.message);
    return { status: "error", message: "Gagal menyimpan konten bantuan: " + e.message };
  }
}

/**
 * [SUPERADMIN] Menyimpan atau memperbarui seluruh konten Fitur Premium.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {Array<object>} allFeaturesData - Array berisi seluruh objek data fitur dari frontend.
 * @returns {object} Status penyimpanan.
 */
function savePremiumFeaturesContent(adminEmail, allFeaturesData) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("KontenFiturPremium");

    // Hapus data lama
    if (sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }

    if (allFeaturesData && allFeaturesData.length > 0) {
      const rowsToWrite = allFeaturesData.map(item => [
        item.id,
        item.judul,
        item.deskripsi,
        item.gambarUrl
      ]);
      // Tulis data baru
      sheet.getRange(2, 1, rowsToWrite.length, rowsToWrite[0].length).setValues(rowsToWrite);
    }

    return { status: "success", message: "Konten Fitur Premium berhasil diperbarui." };
  } catch (e) {
    Logger.log("savePremiumFeaturesContent Error: " + e.message);
    return { status: "error", message: "Gagal menyimpan konten fitur: " + e.message };
  }
}

/**
 * [BARU] Mengambil daftar unik nama kelas dari sheet Data Siswa.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {Array<string>} Array berisi nama-nama kelas yang unik dan sudah diurutkan.
 */
function getUniqueKelasList(spreadsheetId) {
  try {
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) {
      return [];
    }
    // Gunakan Set untuk mendapatkan nilai unik, filter string kosong, lalu urutkan
    const uniqueKelas = [...new Set(students.map(s => s.kelas).filter(Boolean))].sort();
    return uniqueKelas;
  } catch (e) {
    Logger.log(`getUniqueKelasList Error: ${e.message}`);
    return []; // Kembalikan array kosong jika terjadi error
  }
}

// ===== [BARU] FUNGSI UNTUK MANAJEMEN KUNCI PENGIRIMAN NILAI PER KELAS =====

/**
 * [ADMIN] Mengatur status kunci (Aktif/Terkunci) untuk jenis penilaian tertentu di kelas tertentu.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {string} kelas - Nama kelas yang akan diatur.
 * @param {string} tipe - Tipe penilaian (e.g., 'ujian', 'rapor_k7_ganjil').
 * @param {boolean} isAktif - true jika diaktifkan, false jika dikunci.
 * @returns {object} Hasil dari operasi.
 */
function setSubmissionLockStatus(spreadsheetId, kelas, tipe, isAktif) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName('PengaturanPersetujuan');
    if (!sheet) {
      sheet = ss.insertSheet('PengaturanPersetujuan');
      sheet.appendRow(['Kelas', 'TipePenilaian', 'Status']);
      sheet.getRange("A1:C1").setFontWeight('bold');
    }

    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;
    // Cari baris yang cocok dengan kelas dan tipe
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === kelas && data[i][1] === tipe) {
        rowIndex = i + 1;
        break;
      }
    }

    const status = isAktif ? 'AKTIF' : 'TERKUNCI';
    if (rowIndex !== -1) {
      // Jika sudah ada, update statusnya
      sheet.getRange(rowIndex, 3).setValue(status);
    } else {
      // Jika belum ada, tambahkan baris baru
      sheet.appendRow([kelas, tipe, status]);
    }

    return { status: 'success', message: `Pengaturan untuk ${kelas} - ${tipe} berhasil diperbarui.` };
  } catch (e) {
    Logger.log(`setSubmissionLockStatus Error: ${e.message}`);
    return { status: 'error', message: 'Gagal menyimpan pengaturan.' };
  }
}

/**
 * [ADMIN] Mengambil semua pengaturan kunci pengiriman nilai yang ada.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @returns {object} Objek berisi semua pengaturan yang tersimpan.
 */
function getSubmissionLockSettings(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName('PengaturanPersetujuan');
    if (!sheet || sheet.getLastRow() < 2) {
      return {}; // Kembalikan objek kosong jika sheet tidak ada atau kosong
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 3).getValues();
    const settings = {};

    data.forEach(row => {
      const kelas = row[0];
      const tipe = row[1];
      const status = row[2];
      if (!settings[kelas]) {
        settings[kelas] = {};
      }
      settings[kelas][tipe] = status;
    });

    return settings;
  } catch (e) {
    Logger.log(`getSubmissionLockSettings Error: ${e.message}`);
    return {};
  }
}

/**
 * [GURU] Memeriksa apakah suatu jenis penilaian untuk kelas tertentu sedang dikunci.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {string} kelas - Nama kelas yang akan diperiksa.
 * @param {string} tipeNilai - Tipe nilai (e.g., 'ujian', 'rapor_k7_ganjil').
 * @returns {boolean} True jika terkunci, false jika aktif.
 */
function isSubmissionLockedFor(spreadsheetId, kelas, tipeNilai) {
    const allSettings = getSubmissionLockSettings(spreadsheetId);
    const classSettings = allSettings[kelas];

    if (!classSettings) {
        // Jika tidak ada pengaturan spesifik untuk kelas ini, defaultnya adalah 'AKTIF' (tidak terkunci).
        return false;
    }

    // Tentukan tipe utama ('ujian' atau 'rapor_kX_semester')
    let mainType;
    if (tipeNilai.startsWith('rapor')) {
        const parts = tipeNilai.split('_');
        mainType = `rapor_${parts[1]}_${parts[2]}`; // e.g., 'rapor_k7_ganjil'
    } else {
        mainType = 'ujian'; // Untuk 'ujian_um' atau 'ujian_upr'
    }

    // Jika ada pengaturan spesifik untuk tipe ini, periksa nilainya.
    // Jika tidak ada pengaturan spesifik, defaultnya adalah 'AKTIF' (tidak terkunci).
    return classSettings[mainType] === 'TERKUNCI';
}

/**
 * [BARU] Mengambil status persetujuan secara real-time untuk submission tertentu yang akan digunakan oleh portal guru.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {string} submissionId - ID unik dari pengajuan nilai.
 * @returns {object} Objek berisi status setiap item nilai dan status persetujuan keseluruhan.
 */
function getLiveApprovalStatus_Guru(spreadsheetId, submissionId) {
  if (!submissionId) {
    return { status: "error", message: "Submission ID tidak valid." };
  }
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet || approvalSheet.getLastRow() < 2) {
      // Jika sheet tidak ada atau kosong, tidak ada yang perlu diperbarui.
      return { status: "success", approvalStatus: {}, allApproved: false, message: "No data" };
    }

    const data = approvalSheet.getDataRange().getValues();
    const headers = data[0];
    const submissionIdCol = headers.indexOf('ID Pengajuan');
    const tipeNilaiCol = headers.indexOf('Tipe Nilai');
    const nisnCol = headers.indexOf('NISN');
    const statusCol = headers.indexOf('Status');

    let totalInSubmission = 0;
    let approvedCount = 0;
    const approvalStatus = {};

    // Loop dari baris terakhir ke atas untuk efisiensi jika data banyak
    for (let i = data.length - 1; i > 0; i--) {
      // Pastikan semua kolom yang diperlukan ada
      if (submissionIdCol === -1 || tipeNilaiCol === -1 || nisnCol === -1 || statusCol === -1) {
          throw new Error("Satu atau lebih kolom penting tidak ditemukan di sheet Pengajuan Nilai.");
      }
        
      if (data[i][submissionIdCol] === submissionId) {
        totalInSubmission++;
        const key = `${data[i][tipeNilaiCol]}_${data[i][nisnCol]}`;
        const currentStatus = data[i][statusCol];
        approvalStatus[key] = currentStatus;
        if (currentStatus === 'Disetujui') {
          approvedCount++;
        }
      }
    }

    const allApproved = (totalInSubmission > 0 && totalInSubmission === approvedCount);

    return {
      status: "success",
      approvalStatus: approvalStatus,
      allApproved: allApproved
    };

  } catch (e) {
    Logger.log(`getLiveApprovalStatus_Guru Error: ${e.message}`);
    return { status: "error", message: "Gagal mengambil status live." };
  }
}

// ===== [BARU] FUNGSI-FUNGSI UNTUK REAL-TIME BADGE ADMIN =====

/**
 * [BARU - PENGGANTI] Menghitung jumlah pengajuan nilai yang masih menunggu persetujuan.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @returns {object} Hasil operasi berisi jumlah pengajuan yang pending.
 */
function getPendingApprovalCount(spreadsheetId) {
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!sheet || sheet.getLastRow() < 2) {
      return { status: "success", count: 0 };
    }
    // Kolom I (indeks 9) adalah 'Status'
    const statusColumn = sheet.getRange(2, 9, sheet.getLastRow() - 1, 1).getValues();
    const pendingCount = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
    return { status: "success", count: pendingCount };
  } catch (e) {
    Logger.log(`getPendingApprovalCount Error: ${e.message}`);
    // Jika error, lebih baik kembalikan 0 agar tidak menampilkan badge yang salah
    return { status: "success", count: 0 };
  }
}

// Fungsi baru di Kode.gs.html

/**
 * [BARU] Memperbarui nilai secara massal berdasarkan pilihan resolusi konflik dari admin.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {Array<object>} updatesToPerform - Array objek berisi detail nilai yang akan diupdate.
 * @returns {object} Hasil dari operasi pembaruan.
 */
function batchUpdateNilai(spreadsheetId, updatesToPerform) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let updatedCount = 0;

    updatesToPerform.forEach(update => {
      let targetSheet = ss.getSheetByName(update.sheetName);
      if (targetSheet) {
        // Logika untuk menemukan baris dan kolom yang benar dan memperbarui nilainya
        const data = targetSheet.getDataRange().getDisplayValues();
        const headers = data[0];
        const nisnColIndex = headers.indexOf("NISN");
        const mapelColIndex = headers.indexOf(update.mapelKode);
        
        if (nisnColIndex !== -1 && mapelColIndex !== -1) {
          for (let i = 1; i < data.length; i++) {
            if (data[i][nisnColIndex] === update.nisn) {
              targetSheet.getRange(i + 1, mapelColIndex + 1).setValue(update.newValue);
              updatedCount++;
              break;
            }
          }
        }
      }
    });

    return { status: "success", message: `${updatedCount} data nilai berhasil diperbarui.` };
  } catch (e) {
    Logger.log("batchUpdateNilai Error: " + e.message);
    return { status: "error", message: "Gagal memperbarui nilai: " + e.message };
  }
}

/**
 * [SUPERADMIN TOOL] Memperbarui header pada sheet "Data Siswa" di semua spreadsheet pengguna
 * agar sesuai dengan format 15 kolom yang baru.
 * Fungsi ini hanya boleh dijalankan oleh Superadmin dari editor script atau menu kustom.
 */
function updateAllStudentSheetHeaders_Superadmin() {
  // Verifikasi keamanan bahwa yang menjalankan adalah Superadmin
  const adminEmail = Session.getActiveUser().getEmail();
  if (!isSuperadmin(adminEmail)) {
    Browser.msgBox("Akses Ditolak", "Hanya Superadmin yang dapat menjalankan fungsi ini.", Browser.Buttons.OK);
    return;
  }
  
  // Tampilkan konfirmasi sebelum menjalankan proses yang berisiko
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert(
    'Konfirmasi Aksi',
    'Anda akan memperbarui header "Data Siswa" di SEMUA spreadsheet pengguna. Proses ini tidak dapat dibatalkan. Lanjutkan?',
    ui.ButtonSet.YES_NO
  );

  if (response != ui.Button.YES) {
    ui.alert('Proses dibatalkan.');
    return;
  }

  // Header yang benar (15 kolom)
  const correctHeader = [
    "NISN", "NIS", "Nomor Ujian", "Nama Lengkap", "Jenis Kelamin (L/P)", 
    "Tempat Lahir", "Tanggal Lahir", "Alamat Lengkap Siswa", "Nomor Telepon", 
    "Email", "Tahun Masuk", "Tahun Lulus", "Tampilkan Transkrip", "Kelas", "Ruang Ujian"
  ];

  const masterSs = SpreadsheetApp.getActiveSpreadsheet();
  const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
  if (!userSheet || userSheet.getLastRow() < 2) {
    ui.alert('Error', 'Sheet "Data Pengguna" tidak ditemukan atau kosong.', ui.ButtonSet.OK);
    return;
  }

  const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 6).getValues();
  let successCount = 0;
  let errorCount = 0;
  let errorLogs = [];

  usersData.forEach((userRow, index) => {
    const spreadsheetId = userRow[5];
    const userRole = userRow[4];
    const schoolName = userRow[3];

    // Lewati Superadmin atau pengguna tanpa Spreadsheet ID
    if (userRole === 'Superadmin' || !spreadsheetId) {
      return;
    }

    try {
      const ss = SpreadsheetApp.openById(spreadsheetId);
      const studentSheet = ss.getSheetByName(SHEET_DATA_SISWA);
      
      if (studentSheet) {
        // Hapus header lama dan tulis yang baru
        studentSheet.getRange("A1:O1").clearContent(); // Hapus 15 kolom pertama di baris 1
        studentSheet.getRange(1, 1, 1, correctHeader.length).setValues([correctHeader]).setFontWeight("bold");
        successCount++;
        Logger.log(`Sukses: Header diperbarui untuk ${schoolName} (ID: ${spreadsheetId})`);
      } else {
        throw new Error(`Sheet "Data Siswa" tidak ditemukan.`);
      }
    } catch (e) {
      errorCount++;
      const errorMessage = `Gagal memproses ${schoolName} (ID: ${spreadsheetId}): ${e.message}`;
      Logger.log(errorMessage);
      errorLogs.push(errorMessage);
    }
  });
  
  // Tampilkan laporan hasil
  let summaryMessage = `Proses selesai.\n\nBerhasil memperbarui: ${successCount} spreadsheet.\nGagal: ${errorCount} spreadsheet.`;
  if (errorCount > 0) {
    summaryMessage += '\n\nDetail kegagalan (lihat Log Eksekusi untuk info lengkap):\n' + errorLogs.slice(0, 5).join('\n');
  }
  ui.alert('Laporan Pembaruan Header', summaryMessage, ui.ButtonSet.OK);
}

/**
 * Membuat menu kustom di Spreadsheet saat file dibuka.
 */
function onOpen() {
  SpreadsheetApp.getUi()
      .createMenu(' Alat Superadmin')
      .addItem('Perbarui Semua Header Siswa', 'updateAllStudentSheetHeaders_Superadmin')
      .addToUi();
}
