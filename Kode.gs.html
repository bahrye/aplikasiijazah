// =================================================================
// KONFIGURASI GLOBAL
// =================================================================

// PENTING: Ganti dengan ID Spreadsheet Template yang sudah Anda buat.
// Anda bisa mendapatkan ID ini dari URL spreadsheet template Anda.
// Contoh URL: https://docs.google.com/spreadsheets/d/INI_ADALAH_ID_NYA/edit
const TEMPLATE_SPREADSHEET_ID = "14u86jJydOZu-nsTRTH_dOGIBhvLLIObLkbXsHrJ0xhM"; 

// Nama-nama Sheet yang digunakan di dalam spreadsheet data setiap sekolah.
const SHEET_PENGGUNA = "Data Pengguna"; // Ini ada di spreadsheet induk
const SHEET_DATA_SEKOLAH = "Data Sekolah";
const SHEET_DATA_SISWA = "Data Siswa";
const SHEET_MAPEL = "Data Mata Pelajaran";
const SHEET_BOBOT = "Data Bobot Nilai";
const SHEET_NILAI_UJIAN_MADRASAH = "Nilai Ujian Madrasah";
const SHEET_NILAI_UJIAN_PRAKTEK = "Nilai Ujian Praktek";
const SHEET_REKAP_UJIAN = "Rekap Nilai Ujian";
const SHEET_REKAP_RAPOR = "Rekap Nilai Rapor";
const SHEET_REKAP_IJAZAH = "Rekap Nilai Ijazah";
const SHEET_MAPEL_DEFAULT = "Mapel Default"; // Sheet di Spreadsheet Induk untuk mapel standar
const SHEET_LOG = 'Log Aktivitas';
const SHEET_VERSI = 'Versi Aplikasi'; // Sheet baru untuk info update
const SHEET_BACKUP_REGISTRY = "Data Backup Terdaftar";
const SHEET_PENGAJUAN = "Data Pengajuan"; // <-- TAMBAHAN DARI SEBELUMNYA
const SHEET_DASHBOARD_CACHE = "Cache Dashboard"; // <-- TAMBAHKAN BARIS INI
const SHEET_PENGATURAN = "Pengaturan"; // <-- TAMBAHKAN BARIS INI
// ===== AWAL KODE TAMBAHAN =====
const SHEET_BROADCAST = "Pesan Broadcast";
const SHEET_LAST_SEEN_BROADCAST = "Last Seen Broadcast ID"; // Nama kolom di 'Data Pengguna'
const SHEET_BROADCAST_READ_STATUS = "Status Baca Broadcast";
// ===== AKHIR KODE TAMBAHAN =====
const SHEET_CACHE_AKUN = "Cache Akun";
const SHEET_SARAN = "Saran & Masalah";
const SHEET_WILAYAH = "Data Wilayah";
const SHEET_DATA_GURU = "Data Guru";
const SHEET_NILAI_GURU_DRAFT = "Draf Nilai Guru";
const SHEET_NILAI_GURU_SUBMITTED = "Nilai Terkirim Guru";
const SHEET_PENGAJUAN_NILAI = "Pengajuan Nilai"; // [BARU]


/**
 * [MODIFIKASI FINAL] Fungsi utama yang menangani permintaan GET.
 * Sekarang mengenali halaman Portal Guru, Siswa, dan Validasi.
 */
function doGet(e) {
  const page = e.parameter.page;
  const webAppUrl = ScriptApp.getService().getUrl();

  if (page === 'siswa') {
    const template = HtmlService.createTemplateFromFile('Siswa.html');
    template.webAppUrl = webAppUrl;
    return template.evaluate()
      .setTitle('Portal Siswa')
      .setFaviconUrl("https://i.imgur.com/XX5e5Pe.png")
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
  } 
  // ===== BLOK BARU UNTUK HALAMAN GURU =====
  else if (page === 'guru') {
    const template = HtmlService.createTemplateFromFile('Guru.html');
    template.webAppUrl = webAppUrl;
    return template.evaluate()
      .setTitle('Portal Guru') // Judul halaman untuk guru
      .setFaviconUrl("https://i.imgur.com/PjdWlTG.png") // Contoh ikon baru
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
  }
  // ==========================================
  else if (page === 'validasi') {
    const token = e.parameter.token;
    return buildValidationPage(token);
  } 
  else {
    // Halaman default (Index.html) untuk admin/pengguna
    const template = HtmlService.createTemplateFromFile('Index');
    template.webAppUrl = webAppUrl;
    return template.evaluate()
      .setTitle('Aplikasi Pengolahan Nilai Ijazah by Syamsul Bahri')
      .setFaviconUrl("https://i.imgur.com/C0cZOT0.png")
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
  }
}

/**
 * [BARU] Mengambil informasi versi aplikasi terbaru dari Spreadsheet Induk.
 * @returns {object|null} Objek berisi detail versi terbaru atau null jika gagal.
 */
function getAppVersionInfo() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const versionSheet = ss.getSheetByName(SHEET_VERSI);

    // Jika sheet tidak ada atau hanya ada header
    if (!versionSheet || versionSheet.getLastRow() < 2) {
      return null;
    }

    // Ambil data dari baris teratas (baris ke-2)
    const latestVersionData = versionSheet.getRange(2, 1, 1, 3).getValues()[0];
    const version = latestVersionData[0];
    const releaseDate = latestVersionData[1];
    const changelog = latestVersionData[2];

    if (!version) {
      return null; // Jika kolom versi kosong, jangan kirim apa-apa
    }

    return {
      version: version.toString().trim(),
      releaseDate: releaseDate instanceof Date ? releaseDate.toISOString().split('T')[0] : releaseDate,
      // Ubah catatan perubahan yang dipisahkan baris baru menjadi array HTML (<li>)
      changelog: changelog.split('\n').map(line => line.trim()).filter(line => line)
    };

  } catch (e) {
    Logger.log("Error in getAppVersionInfo: " + e.message);
    return null; // Jangan hentikan aplikasi jika fitur ini gagal
  }
}
// =================================================================
// FUNGSI KEAMANAN (PASSWORD HASHING) - [BARU]
// =================================================================

/**
 * [BARU] Menghasilkan string acak untuk digunakan sebagai salt.
 * @returns {string} Salt yang dihasilkan.
 */
function generateSalt() {
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

/**
 * [BARU & DIPERBAIKI] Menghasilkan hash dari password dan salt menggunakan SHA-256.
 * @param {string} password Password teks biasa.
 * @param {string} salt Salt yang akan digunakan.
 * @returns {string} Hash dalam format heksadesimal.
 */
function hashPassword(password, salt) {
  const saltedPassword = password + salt;
  const digest = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, saltedPassword, Utilities.Charset.UTF_8);
  
  let hexString = '';
  for (let i = 0; i < digest.length; i++) {
    // --- PERBAIKAN ---
    // Ubah 'const' menjadi 'let' agar nilainya bisa dimodifikasi.
    let byte = digest[i]; 
    if (byte < 0) {
      byte += 256;
    }
    // --- AKHIR PERBAIKAN ---
    
    let hex = byte.toString(16); // 'hex' bisa tetap 'let' atau 'const'
    if (hex.length === 1) {
      hexString += '0';
    }
    hexString += hex;
  }
  return hexString;
}

/**
 * [BARU] Memverifikasi password teks biasa terhadap format 'salt:hash' yang tersimpan.
 * @param {string} plainPassword Password yang dimasukkan pengguna saat login.
 * @param {string} saltAndHash String yang tersimpan di database ('salt:hash').
 * @returns {boolean} True jika password cocok, false jika tidak.
 */
function verifyPassword(plainPassword, saltAndHash) {
  try {
    const parts = saltAndHash.split(':');
    if (parts.length !== 2) {
      // Ini bukan format hash yang kita harapkan, anggap saja tidak valid.
      return false;
    }
    const salt = parts[0];
    const storedHash = parts[1];
    const newHash = hashPassword(plainPassword, salt);
    return newHash === storedHash;
  } catch (e) {
    Logger.log("Error during password verification: " + e.message);
    return false;
  }
}

// =================================================================
// FUNGSI AUTENTIKASI DAN MANAJEMEN AKUN (DENGAN OTP)
// =================================================================

/**
 * [MODIFIKASI] Membuat dan menyimpan OTP sementara menggunakan kunci cache yang konsisten.
 * @param {string} email Email tujuan untuk OTP.
 * @returns {string} OTP yang dibuat.
 */
function generateAndStoreOtp(email) {
  const otp = Math.floor(100000 + Math.random() * 900000).toString();
  const cache = CacheService.getScriptCache();
  // [PERBAIKAN] Gunakan email lowercase sebagai kunci cache untuk konsistensi
  const cacheKey = email.toLowerCase();
  cache.put(cacheKey, otp, 600); // 600 detik = 10 menit
  return otp;
}

/**
 * [MODIFIKASI] Memvalidasi OTP yang dimasukkan pengguna dengan logging tambahan.
 * @param {string} email Email yang diverifikasi.
 * @param {string} otp Kode OTP dari pengguna.
 * @returns {boolean} True jika valid, false jika tidak.
 */
function verifyOtp(email, otp) {
  const cache = CacheService.getScriptCache();
  // [PERBAIKAN] Gunakan email lowercase untuk mengambil dari cache
  const cacheKey = email.toLowerCase();
  const storedOtp = cache.get(cacheKey);

  // [DEBUG] Tambahkan logging untuk membantu melacak masalah di masa depan
  Logger.log(`Verifikasi OTP untuk email: ${email} (key: ${cacheKey})`);
  Logger.log(`OTP dari pengguna: "${otp}" (tipe: ${typeof otp})`);
  Logger.log(`OTP dari cache: "${storedOtp}" (tipe: ${typeof storedOtp})`);
  
  // Perbandingan ketat antara OTP yang disimpan (string) dan yang dimasukkan (string)
  const isValid = storedOtp != null && storedOtp === otp.toString();
  Logger.log(`Hasil validasi: ${isValid}`);
  
  return isValid;
}

/**
 * [MODIFIKASI] Mengirim email verifikasi, menggunakan email yang sudah dinormalisasi.
 * @param {string} email Email calon pengguna.
 * @returns {{status: string, message: string}} Hasil proses pengiriman.
 */
function sendVerificationEmail(email) {
  try {
    if (!email) {
      return { status: "error", message: "Email tidak boleh kosong." };
    }
    const normalizedEmail = email.toLowerCase(); // [PERBAIKAN] Normalisasi email

    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);

    if (userSheet.getLastRow() > 1) {
        const dataRange = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1);
        const existingEmails = dataRange.getValues().flat();
        // [PERBAIKAN] Bandingkan dengan email yang sudah dinormalisasi
        if (existingEmails.some(existingEmail => existingEmail.toLowerCase() === normalizedEmail)) {
          lock.releaseLock();
          return { status: "error", message: "Email sudah terdaftar. Silakan gunakan email lain." };
        }
    }
    
    lock.releaseLock();

    // [PERBAIKAN] Gunakan email yang sudah dinormalisasi untuk generate OTP
    const otp = generateAndStoreOtp(normalizedEmail);
    const subject = "Kode Verifikasi Pendaftaran Akun";
    const body = `
      <div style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2>Verifikasi Akun Anda</h2>
        <p>Terima kasih telah mendaftar. Silakan gunakan kode verifikasi di bawah ini untuk menyelesaikan proses pendaftaran Anda:</p>
        <p style="font-size: 24px; font-weight: bold; letter-spacing: 5px; background-color: #f0f0f0; padding: 10px 20px; border-radius: 5px; display: inline-block;">${otp}</p>
        <p>Kode ini hanya berlaku selama 10 menit.</p>
        <p>Jika Anda tidak merasa mendaftar, abaikan email ini.</p>
        <br>
        <p>Terima kasih,</p>
        <p>Tim Aplikasi Pengolahan Nilai Ijazah</p>
      </div>
    `;

    MailApp.sendEmail({
      to: email, // Kirim ke email asli, bukan yang lowercase
      subject: subject,
      htmlBody: body
    });

    return { status: "success", message: "Kode OTP telah dikirim ke email Anda. Silakan periksa kotak masuk atau folder spam." };

  } catch (error) {
    Logger.log(`sendVerificationEmail Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengirim email verifikasi: " + error.message };
  }
}


/**
 * [MODIFIKASI FINAL v3] Mendaftarkan pengguna baru dengan KODE SEKOLAH unik.
 * @param {{email: string, password: string, namaSekolah: string, jenjang: string}} userData Objek berisi data pengguna baru.
 * @param {string} otp Kode OTP yang dimasukkan pengguna.
 * @returns {{status: string, message: string}} Objek status pendaftaran.
 */
function registerUser(userData, otp) {
  try {
    const { email, password, namaSekolah, jenjang } = userData;
    if (!verifyOtp(email, otp)) {
      return { status: "error", message: "Kode OTP salah atau telah kedaluwarsa." };
    }
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const configSheet = ss.getSheetByName('Konfigurasi Sistem');
    const defaultLimit = configSheet ? configSheet.getRange("B2").getValue() : 100;
    let userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);
    
    // --- AWAL LOGIKA BARU: Generate Kode Sekolah Unik ---
    let schoolCode;
    let isCodeUnique = false;
    const existingCodes = userSheet.getLastRow() > 1 ? userSheet.getRange(2, 13, userSheet.getLastRow() - 1, 1).getValues().flat() : [];
    
    while (!isCodeUnique) {
      schoolCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      if (!existingCodes.includes(schoolCode)) {
        isCodeUnique = true;
      }
    }
    // --- AKHIR LOGIKA BARU ---
    
    const latestVersionInfo = getAppVersionInfo();
    const latestVersion = latestVersionInfo ? latestVersionInfo.version : '';

    if (userSheet.getLastRow() > 1) {
      const existingEmails = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1).getValues().flat();
      if (existingEmails.some(e => e.toLowerCase() === email.toLowerCase())) {
        lock.releaseLock();
        return { status: "error", message: "Email sudah terdaftar." };
      }
    }

    const templateFile = DriveApp.getFileById(TEMPLATE_SPREADSHEET_ID);
    const newFile = templateFile.makeCopy(`Data Akademik - ${namaSekolah}`);
    const newSpreadsheetId = newFile.getId();
    const newSs = SpreadsheetApp.openById(newSpreadsheetId);
    const dataSekolahSheet = newSs.getSheetByName(SHEET_DATA_SEKOLAH);
    if (dataSekolahSheet) {
      dataSekolahSheet.getRange(2, 1).setValue(jenjang);
      dataSekolahSheet.getRange(2, 2).setValue(namaSekolah);
    }

    const userId = Utilities.getUuid();
    const salt = generateSalt();
    const hashedPassword = hashPassword(password, salt);
    const storedPasswordString = `${salt}:${hashedPassword}`;

    // ===== PERUBAHAN UTAMA DI SINI (13 KOLOM) =====
    userSheet.appendRow([
        userId, email, storedPasswordString, namaSekolah, jenjang, newSpreadsheetId,
        'Pengguna', 'Aktif', defaultLimit, latestVersion, '', '', schoolCode, '', 'YA'
    ]);
    
    CacheService.getScriptCache().remove(email.toLowerCase());
    lock.releaseLock();
    return { status: "success", message: "Pendaftaran berhasil! Akun dan database sekolah Anda telah dibuat." };

  } catch (error) {
    Logger.log(error);
    return { status: "error", message: "Gagal mendaftar: " + error.message + " Stack: " + error.stack };
  }
}

/**
 * [MODIFIKASI FINAL & BROADCAST v2] Memeriksa kredensial login.
 * Menangani kasus Superadmin, status akun, dan mengirimkan changelog & broadcast baru.
 * @param {string} email Email pengguna.
 * @param {string} password Password pengguna.
 * @returns {object} Objek status login, bisa berisi data changelog atau broadcast baru.
 */
function checkLogin(email, password) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet || userSheet.getLastRow() < 2) {
      return { status: "error", message: "Konfigurasi pengguna tidak ditemukan." };
    }

    const users = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 12).getValues(); 
    const userIndex = users.findIndex(userRow => userRow[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Email tidak terdaftar." };
    }

    const userRow = users[userIndex];
    const storedPassword = userRow[2].toString(); 
    let spreadsheetId = userRow[5];
    const role = userRow[6] || 'Pengguna';
    const status = userRow[7] || 'Aktif';
    const lastSeenChangelogVersion = (userRow[10] || '').toString().trim();

    if (status !== 'Aktif') {
        return { status: "error", message: "Akun Anda saat ini tidak aktif. Silahkan hubungi Admin." };
    }

    if (role === 'Superadmin') {
      spreadsheetId = null;  
    } else if (!spreadsheetId) {
      return { status: "error", message: "Akun pengguna ini tidak terkonfigurasi dengan benar (tidak ada Spreadsheet ID)." };
    }

    let passwordIsValid = false;
    if (storedPassword.includes(':')) {
      passwordIsValid = verifyPassword(password, storedPassword);
    } else {
      passwordIsValid = (storedPassword === password);
      if (passwordIsValid) {
        try {
          const salt = generateSalt();
          const newHashedPassword = hashPassword(password, salt);
          userSheet.getRange(userIndex + 2, 3).setValue(`${salt}:${newHashedPassword}`);
        } catch (e) {
          Logger.log(`Failed to upgrade password for ${email}. Error: ${e.message}`);
        }
      }
    }

    // Ganti bagian ini di dalam fungsi checkLogin
    if (passwordIsValid) {
      logLoginActivity(email, userRow[3], userRow[4], role);

      // --- AWAL MODIFIKASI ---
      const lockStatus = checkFiturLock(email);
      // --- AKHIR MODIFIKASI ---

      const loginResponse = {  
          status: "success",  
          message: "Login berhasil.",  
          spreadsheetId: spreadsheetId,  
          email: userRow[1],  
          role: role,  
          webAppUrl: ScriptApp.getService().getUrl(),
          // --- AWAL MODIFIKASI ---
          isLocked: lockStatus.isLocked // Kirim status lock ke frontend
          // --- AKHIR MODIFIKASI ---
      };

      if (role === 'Pengguna') {
        const latestVersionInfo = getAppVersionInfo();
        if (latestVersionInfo && latestVersionInfo.version !== lastSeenChangelogVersion) {
          loginResponse.newChangelog = latestVersionInfo;
        }

        // --- PERUBAHAN UTAMA LOGIKA BROADCAST ---
        const latestBroadcast = getLatestBroadcast();
        if (latestBroadcast) {
          // Cek apakah pengguna ini sudah membaca broadcast terbaru
          const hasRead = hasUserReadBroadcast(latestBroadcast.id, email);
          if (!hasRead) {
            loginResponse.newBroadcast = latestBroadcast;
          }
        }
        // --- AKHIR PERUBAHAN ---
      }
      
      return loginResponse;

    } else {
      return { status: "error", message: "Password salah." };
    }

  } catch (error) {
    Logger.log(error);
    return { status: "error", message: "Kesalahan Server: " + error.message };
  }
}

/**
 * [VERSI FINAL & DIPERBAIKI] Memperbarui 'Versi Changelog Terakhir Dilihat' untuk pengguna spesifik.
 * @param {string} userEmail - Email pengguna yang sesi-nya akan diperbarui, dikirim dari frontend.
 * @param {string} version - Versi changelog yang baru saja dilihat oleh pengguna.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function updateLastSeenChangelogVersion(userEmail, version) {
  try {
    // Gunakan userEmail yang dikirim dari frontend, yang didapat dari sessionStorage.
    if (!userEmail || !version) {
      throw new Error("Email pengguna atau versi tidak boleh kosong.");
    }
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) {
      throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);
    }

    // Cari baris berdasarkan email yang dikirim dari frontend
    const emailColumn = userSheet.getRange("B2:B").getValues().flat();
    const userIndex = emailColumn.findIndex(email => email && email.toLowerCase() === userEmail.toLowerCase());

    if (userIndex !== -1) {
      const rowToUpdate = userIndex + 2;
      const targetCell = userSheet.getRange(rowToUpdate, 11); // Kolom K
      
      targetCell.setNumberFormat('@');
      targetCell.setValue(version); 
      
      return { status: 'success', message: 'Status changelog berhasil diperbarui.' };
    } else {
      // Ini jarang terjadi jika pengguna sudah login, tapi sebagai pengaman.
      throw new Error(`Pengguna dengan email ${userEmail} tidak ditemukan untuk update status changelog.`);
    }

  } catch (e) {
    Logger.log(`updateLastSeenChangelogVersion Error: ${e.message}`);
    return { status: 'error', message: e.message };
  }
}

/**
 * [DIPERBARUI] Mengambil riwayat semua aktivitas login pengguna dari 'Log Aktivitas'.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek berisi data riwayat login.
 */
function getLoginHistory_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak. Hanya Superadmin yang dapat mengakses riwayat login.");
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const logSheet = ss.getSheetByName(SHEET_LOG);
    
    // Jika sheet log belum ada atau kosong, kembalikan array kosong.
    if (!logSheet || logSheet.getLastRow() < 2) {
        return [];
    }

    // Baca semua data dari sheet log kecuali baris header
    const dataRange = logSheet.getRange(2, 1, logSheet.getLastRow() - 1, 5);
    const values = dataRange.getValues();

    const loginHistory = values
      .map(row => ({
        timestamp: row[0],      // Kolom A: Timestamp
        namaSekolah: row[2],    // Kolom C: Nama Sekolah
        jenjang: row[3],        // Kolom D: Jenjang
        role: row[4]            // Kolom E: Role
      }))
      .filter(log => log.role === 'Pengguna') // Tetap filter hanya untuk 'Pengguna'
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime()) // Urutkan dari yang paling baru
      .slice(0, 50); // Ambil 50 aktivitas terbaru agar dashboard tidak lambat

    // Ubah format data agar sesuai dengan yang diharapkan frontend
    return loginHistory.map(item => ({
      namaSekolah: item.namaSekolah,
      jenjang: item.jenjang,
      loginTimestamp: item.timestamp.toISOString() // Gunakan key 'loginTimestamp'
    }));

  } catch (e) {
    Logger.log(`getLoginHistory_Superadmin Error: ${e.message}`);
    return []; // Kembalikan array kosong jika error
  }
}

/**
 * [BARU] Mengirimkan OTP untuk reset password.
 * @param {string} email Email pengguna yang terdaftar.
 * @returns {{status: string, message: string}} Hasil proses pengiriman.
 */
function sendPasswordResetOtp(email) {
  try {
    if (!email) {
      return { status: "error", message: "Email tidak boleh kosong." };
    }
    const normalizedEmail = email.toLowerCase();

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const users = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1).getValues().flat();

    // Cek apakah email terdaftar
    const emailExists = users.some(existingEmail => existingEmail.toLowerCase() === normalizedEmail);
    if (!emailExists) {
      return { status: "error", message: "Email tidak terdaftar di sistem kami." };
    }

    const otp = generateAndStoreOtp(normalizedEmail); // Menggunakan kembali fungsi OTP yang sudah ada
    const subject = "Kode Verifikasi Reset Password";
    const body = `
      <div style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2>Reset Password Anda</h2>
        <p>Kami menerima permintaan untuk mereset password akun Anda. Gunakan kode di bawah ini untuk melanjutkan:</p>
        <p style="font-size: 24px; font-weight: bold; letter-spacing: 5px; background-color: #f0f0f0; padding: 10px 20px; border-radius: 5px; display: inline-block;">${otp}</p>
        <p>Kode ini hanya berlaku selama 10 menit.</p>
        <p>Jika Anda tidak merasa meminta reset password, abaikan email ini.</p>
      </div>
    `;

    MailApp.sendEmail({
      to: email,
      subject: subject,
      htmlBody: body
    });

    return { status: "success", message: "Kode OTP telah dikirim ke email Anda." };

  } catch (error) {
    Logger.log(`sendPasswordResetOtp Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengirim email verifikasi: " + error.message };
  }
}


/**
 * [BARU] Memverifikasi OTP dan mereset password pengguna.
 * @param {string} email Email pengguna.
 * @param {string} otp Kode OTP yang dimasukkan.
 * @param {string} newPassword Password baru yang akan diatur.
 * @returns {{status: string, message: string}} Hasil proses reset.
 */
function resetPasswordWithOtp(email, otp, newPassword) {
  try {
    // 1. Verifikasi OTP
    if (!verifyOtp(email, otp)) {
      return { status: "error", message: "Kode OTP salah atau telah kedaluwarsa." };
    }

    // 2. Hash password baru
    const salt = generateSalt();
    const hashedPassword = hashPassword(newPassword, salt);
    const newStoredPasswordString = `${salt}:${hashedPassword}`;

    // 3. Temukan dan perbarui password di spreadsheet
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 3).getValues(); // Ambil ID, email, password

    const userIndex = data.findIndex(row => row[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Terjadi kesalahan: Pengguna tidak ditemukan." };
    }

    // Update password di baris yang benar (baris spreadsheet = index array + 2)
    const rowToUpdate = userIndex + 2;
    userSheet.getRange(rowToUpdate, 3).setValue(newStoredPasswordString); // Kolom password (C) adalah kolom ke-3

    // Hapus OTP dari cache setelah berhasil digunakan
    CacheService.getScriptCache().remove(email.toLowerCase());

    return { status: "success", message: "Password Anda telah berhasil direset." };

  } catch (error) {
    Logger.log(`resetPasswordWithOtp Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mereset password: " + error.message };
  }
}

/**
 * [BARU] Mengubah password pengguna yang sedang login.
 * @param {string} email Email pengguna yang terdaftar.
 * @param {string} currentPassword Password saat ini yang dimasukkan pengguna.
 * @param {string} newPassword Password baru yang akan diatur.
 * @returns {{status: string, message: string}} Hasil proses perubahan password.
 */
function changeUserPassword(email, currentPassword, newPassword) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) {
      throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);
    }

    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 3).getValues(); // Ambil ID, email, password
    const userIndex = data.findIndex(row => row[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Terjadi kesalahan: Pengguna tidak ditemukan." };
    }

    const storedPasswordString = data[userIndex][2].toString();

    // 1. Verifikasi password saat ini
    // ==== AWAL PERBAIKAN ====
    // Logika verifikasi ini sekarang dapat menangani password lama (plain text) dan baru (hash).
    let isCurrentPasswordValid = false;
    if (storedPasswordString.includes(':')) {
      // Jika formatnya 'salt:hash', gunakan verifikasi hash.
      isCurrentPasswordValid = verifyPassword(currentPassword, storedPasswordString);
    } else {
      // Jika tidak, ini adalah password lama, bandingkan sebagai teks biasa.
      isCurrentPasswordValid = (currentPassword === storedPasswordString);
    }
    // ==== AKHIR PERBAIKAN ====
    
    if (!isCurrentPasswordValid) {
      return { status: "error", message: "Password Anda saat ini salah. Silakan coba lagi." };
    }

    // 2. Hash password baru (bagian ini sudah benar)
    const salt = generateSalt();
    const hashedPassword = hashPassword(newPassword, salt);
    const newStoredPasswordString = `${salt}:${hashedPassword}`;

    // 3. Perbarui password di spreadsheet
    const rowToUpdate = userIndex + 2; // Baris spreadsheet = index array + 2
    userSheet.getRange(rowToUpdate, 3).setValue(newStoredPasswordString); // Kolom password (C) adalah kolom ke-3

    return { status: "success", message: "Password Anda telah berhasil diubah." };

  } catch (error) {
    Logger.log(`changeUserPassword Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengubah password: " + error.message };
  }
}

// =================================================================
// FUNGSI UTILITAS UMUM
// =================================================================

/**
 * Helper function untuk membuka spreadsheet berdasarkan ID.
 * @param {string} spreadsheetId ID dari Google Sheet yang akan dibuka.
 * @returns {SpreadsheetApp.Spreadsheet} Objek Spreadsheet.
 */
function getSpreadsheet(spreadsheetId) {
  if (!spreadsheetId) {
    throw new Error("Spreadsheet ID tidak valid atau tidak diberikan.");
  }
  return SpreadsheetApp.openById(spreadsheetId);
}

/**
 * [BARU] Helper function untuk mengubah string menjadi Proper Case.
 * @param {string} str String yang akan diubah.
 * @returns {string} String dalam format Proper Case.
 */
function toProperCase(str) {
  if (!str || typeof str !== 'string') return '';
  return str.replace(/\w\S*/g, function(txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}


// =================================================================
// FUNGSI MANAJEMEN DATA SEKOLAH, SISWA, MAPEL, DLL.
// =================================================================

/**
 * [MODIFIKASI] Menyimpan data sekolah ke dalam sheet 'Data Sekolah', termasuk NSM, tipe kabupaten, dan tipe kelurahan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} dataObj Objek berisi data sekolah.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveSchoolData(spreadsheetId, dataObj) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_DATA_SEKOLAH);
    
    sheet.getRange("C:D").setNumberFormat('@');
    sheet.getRange("J:K").setNumberFormat('@');
    sheet.getRange("O:O").setNumberFormat('@');
    
    // [MODIFIKASI] Tambahkan tipeKabupaten dan tipeKelurahan ke dalam array data
    const schoolDataRow = [
        dataObj.jenjang || "", dataObj.namaSekolah || "", dataObj.npsn || "", dataObj.nsm || "",
        dataObj.alamat || "", 
        dataObj.provinsi || "", 
        // Tambahkan field baru di sini
        dataObj.tipeKabupaten || "Kabupaten", // Default ke "Kabupaten" jika kosong
        dataObj.kabupaten || "", 
        dataObj.kecamatan || "", 
        // Tambahkan field baru di sini
        dataObj.tipeKelurahan || "Kelurahan", // Default ke "Kelurahan" jika kosong
        dataObj.kelurahan || "", 
        dataObj.kodePos || "", dataObj.telepon || "", dataObj.email || "", 
        dataObj.website || "", dataObj.namaKepsek || "", dataObj.nipKepsek || ""
    ];

    // [MODIFIKASI] Ubah jangkauan penulisan data untuk mencakup kolom baru
    // Asumsi kita menyisipkan kolom baru setelah Provinsi (I) dan Kecamatan (K)
    // Jika header belum ada, buat header baru
    if (sheet.getRange("G1").getValue() !== "Tipe Kabupaten/Kota") {
      sheet.insertColumnAfter(9); // Sisipkan setelah kolom I (Provinsi)
      sheet.getRange("J1").setValue("Tipe Kabupaten/Kota").setFontWeight("bold");
    }
    if (sheet.getRange("L1").getValue() !== "Tipe Kelurahan/Desa") {
      sheet.insertColumnAfter(11); // Sisipkan setelah kolom K (Kecamatan)
      sheet.getRange("M1").setValue("Tipe Kelurahan/Desa").setFontWeight("bold");
    }
    
    // Menulis data ke baris ke-2 dengan jangkauan yang sudah disesuaikan
    // Logika penulisan data di sini mungkin perlu penyesuaian tergantung struktur akhir sheet
    // Untuk penyederhanaan, kita akan menulis ulang seluruh baris data berdasarkan array yang baru.
    // Asumsi total kolom sekarang adalah 17 (O + 2)
    const valuesToWrite = [
        dataObj.jenjang||"", dataObj.namaSekolah||"", dataObj.npsn||"", dataObj.nsm||"",
        dataObj.alamat||"", dataObj.provinsi||"", dataObj.tipeKabupaten||"Kabupaten", dataObj.kabupaten||"",
        dataObj.kecamatan||"", dataObj.tipeKelurahan||"Kelurahan", dataObj.kelurahan||"", dataObj.kodePos||"",
        dataObj.telepon||"", dataObj.email||"", dataObj.website||"", dataObj.namaKepsek||"",
        dataObj.nipKepsek||""
    ];
    sheet.getRange(2, 1, 1, valuesToWrite.length).setValues([valuesToWrite]);


    return { status: "success", message: "Data sekolah berhasil diperbarui." };
  } catch (error) {
    Logger.log(error);
    // Untuk sementara, kita akan mengembalikan error yang lebih sederhana.
    // Penyesuaian kolom yang kompleks memerlukan penanganan error yang lebih baik.
    return { status: "error", message: "Gagal menyimpan data sekolah (mungkin karena perubahan struktur): " + error.message };
  }
}

/**
 * [MODIFIKASI] Mengambil data sekolah dari sheet 'Data Sekolah', termasuk tipe wilayah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object|null} Objek data sekolah atau null jika gagal.
 */
function getSchoolData(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SEKOLAH);
    if (!sheet || sheet.getLastRow() < 2) return null;

    sheet.getRange("C:D").setNumberFormat('@');
    sheet.getRange("K:L").setNumberFormat('@'); // Disesuaikan setelah penambahan kolom
    sheet.getRange("Q:Q").setNumberFormat('@'); // Disesuaikan setelah penambahan kolom

    // [MODIFIKASI] Ubah jangkauan pengambilan data menjadi A2:Q2 (17 kolom)
    const values = sheet.getRange("A2:Q2").getValues()[0];
    
    // [MODIFIKASI] Tambahkan field baru dan sesuaikan indeks
    return {
        jenjang: values[0], 
        namaSekolah: values[1], 
        npsn: values[2], 
        nsm: values[3],
        alamat: values[4], 
        provinsi: values[5],
        tipeKabupaten: values[6], // Kolom baru
        kabupaten: values[7],
        kecamatan: values[8],
        tipeKelurahan: values[9], // Kolom baru
        kelurahan: values[10],
        kodePos: values[11], 
        telepon: values[12], 
        email: values[13], 
        website: values[14], 
        namaKepsek: values[15], 
        nipKepsek: values[16]
    };
  } catch (error) {
    Logger.log(error);
    return null;
  }
}

/**
 * [DIPERBARUI] Mengambil daftar siswa dari sheet 'Data Siswa'.
 * Membaca 15 kolom untuk menyertakan Kelas, Ruang Ujian, dan Nomor Ujian.
 */
function getStudents(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (!sheet || sheet.getLastRow() < 2) return [];

    sheet.getRange("A:C").setNumberFormat('@'); // NISN, NIS, Nomor Ujian
    sheet.getRange("F:F").setNumberFormat('@'); // Tempat Lahir
    sheet.getRange("I:I").setNumberFormat('@'); // Telepon

    // Baca hingga kolom O (15 kolom)
    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 15); 
    const values = dataRange.getValues();

    return values.map((row, index) => {
      let tanggalLahirStr = '';
      if (row[6] && row[6] instanceof Date && !isNaN(row[6])) { // Indeks 6 untuk tanggal lahir
        tanggalLahirStr = Utilities.formatDate(row[6], Session.getScriptTimeZone(), "yyyy-MM-dd");
      }

      return {
        row: index + 2,
        nisn: String(row[0] || ''),
        nis: String(row[1] || ''),
        nomorUjian: String(row[2] || ''),
        nama: String(row[3] || ''),
        jenisKelamin: String(row[4] || ''),
        tempatLahir: String(row[5] || ''),
        tanggalLahir: tanggalLahirStr,
        alamat: String(row[7] || ''),
        telepon: String(row[8] || ''),
        emailSiswa: String(row[9] || ''),
        tahunMasuk: String(row[10] || ''),
        tahunLulus: String(row[11] || ''),
        tampilkanTranskrip: String(row[12] || 'TIDAK'),
        kelas: String(row[13] || ''),
        ruangUjian: String(row[14] || '')
      };
    });
  } catch (e) {
    Logger.log(`getStudents Error: ${e.stack}`);
    return [];
  }
}

/**
 * [MODIFIKASI & PERBAIKAN FINAL] Menambahkan siswa baru atau mendeteksi konflik jika NISN sudah ada.
 * Kini juga memeriksa batas siswa sebelum menambahkan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} studentData Objek data siswa baru.
 * @param {string} userEmail Email pengguna yang melakukan aksi (dikirim dari frontend).
 * @returns {{status: string, message: string, oldData?: object, newData?: object}} Status penambahan.
 */
function addStudent(spreadsheetId, studentData, userEmail) {
  try {
    const limitCheck = checkStudentLimit(spreadsheetId, userEmail); 
    if (limitCheck.limitReached) {
        return { status: "error", message: limitCheck.message };
    }

    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    
    if (sheet.getLastRow() > 1) {
      const allStudents = getStudents(spreadsheetId);
      const existingStudent = allStudents.find(s => s.nisn.toString() === studentData.nisn.toString());

      if (existingStudent) {
        const isIdentical = areStudentsIdentical(existingStudent, studentData);
        if (isIdentical) {
          return { status: "duplicate", message: "Data siswa dengan NISN ini sudah ada dan semua datanya identik." };
        } else {
          return {
            status: "conflict",
            message: "NISN ini sudah terdaftar dengan data yang berbeda.",
            oldData: existingStudent,
            newData: studentData
          };
        }
      }
    }

    const nextRow = sheet.getLastRow() + 1;
    const tanggalLahirObject = studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '';
    
    // [DIPERBARUI] Susunan data baru untuk ditulis ke sheet
    const newRowData = [
        studentData.nisn, studentData.nis, studentData.nomorUjian, studentData.nama, 
        studentData.jenisKelamin, toProperCase(studentData.tempatLahir), tanggalLahirObject, 
        studentData.alamat, studentData.telepon, studentData.emailSiswa, 
        studentData.tahunMasuk, studentData.tahunLulus, 'TIDAK', // Default tampilkanTranskrip
        studentData.kelas, studentData.ruangUjian
    ];
    sheet.getRange(nextRow, 1, 1, newRowData.length).setValues([newRowData]);
    
    SpreadsheetApp.flush();
    const updatedStudentList = getStudents(spreadsheetId);
    
    return { 
      status: "success", 
      message: `Siswa "${studentData.nama}" berhasil ditambahkan.`,
      updatedStudentList: updatedStudentList
    };

  } catch (e) { 
    Logger.log(e); 
    return { status: "error", message: "Gagal memproses data siswa: " + e.message }; 
  }
}

/**
 * [DIPERBARUI] Memperbarui data siswa dengan kolom-kolom baru.
 */
function updateStudent(spreadsheetId, studentData) {
  try {
    const allStudents = getStudents(spreadsheetId);
    const duplicateStudent = allStudents.find(s =>
      s.nisn.toString().trim() === studentData.nisn.toString().trim() &&
      s.row != studentData.studentRow
    );
    if (duplicateStudent) {
      return { status: "error", message: `Gagal: NISN "${studentData.nisn}" sudah digunakan oleh siswa lain (${duplicateStudent.nama}).` };
    }

    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    
    // [DIPERBARUI] Susunan data baru untuk diupdate
    const rowToUpdate = [
      studentData.nisn, studentData.nis, studentData.nomorUjian, studentData.nama,
      studentData.jenisKelamin, toProperCase(studentData.tempatLahir),
      studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '',
      studentData.alamat, studentData.telepon, studentData.emailSiswa,
      studentData.tahunMasuk, studentData.tahunLulus, studentData.tampilkanTranskrip,
      studentData.kelas, studentData.ruangUjian
    ];

    sheet.getRange(studentData.studentRow, 1, 1, rowToUpdate.length).setValues([rowToUpdate]);

    SpreadsheetApp.flush();
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: `Data siswa "${studentData.nama}" berhasil diperbarui.`,
      updatedStudentList: updatedStudentList
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data: " + e.message };
  }
}

/**
 * Menghapus data siswa dari sheet 'Data Siswa'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {number} rowNumber Nomor baris yang akan dihapus.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteStudent(spreadsheetId, rowNumber) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    sheet.deleteRow(rowNumber);
    // -- PERUBAHAN INTI --
    SpreadsheetApp.flush();
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: "Data siswa berhasil dihapus.",
      updatedStudentList: updatedStudentList
    };
  } catch (e) { Logger.log(e); return { status: "error", message: "Gagal menghapus data: " + e.message }; }
}

/**
 * Menghapus semua data siswa dari sheet 'Data Siswa'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllStudents(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (sheet && sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }
    return { status: "success", message: "Semua data siswa telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data siswa: " + e.message };
  }
}

/**
 * [DIPERBARUI] Menghasilkan template Excel dengan kolom-kolom baru.
 */
function generateSiswaTemplate() {
  let tempFile;
  try {
    const templateName = `Template_Import_Siswa_${new Date().getTime()}`;
    const ss = SpreadsheetApp.create(templateName);
    tempFile = DriveApp.getFileById(ss.getId());
    
    const sheet = ss.getSheets()[0];
    const headers = [
      "NISN", "NIS", "Nomor Ujian", "Nama Lengkap", "Jenis Kelamin (L/P)", 
      "Tempat Lahir", "Tanggal Lahir (Format: YYYY-MM-DD)",
      "Alamat Lengkap Siswa", "Nomor Telepon", "Email", 
      "Tahun Masuk", "Tahun Lulus", "Kelas", "Ruang Ujian"
    ];
    sheet.appendRow(headers);
    sheet.getRange("A1:N1").setFontWeight("bold").setBackground("#d9ead3");
    
    sheet.getRange("A:C").setNumberFormat("@");
    sheet.getRange("I:I").setNumberFormat("@");
    sheet.getRange("G:G").setNumberFormat("yyyy-mm-dd");
    
    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${ss.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: 'Template_Import_Siswa.xlsx',
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

// [PERUBAHAN] Ganti seluruh fungsi importFromExcel dengan ini
function importFromExcel(spreadsheetId, fileData, sheetName, userEmail) {
    let tempFile;
    try {
        const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
        const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
        const tempSpreadsheetFile = Drive.Files.insert({
            title: `temp_import_${new Date().getTime()}`
        }, blob, {
            convert: true
        });
        tempFile = DriveApp.getFileById(tempSpreadsheetFile.id);
        const importSheet = SpreadsheetApp.openById(tempFile.getId()).getSheets()[0];
        const data = importSheet.getDataRange().getValues();

        if (data.length <= 1) throw new Error("File kosong atau hanya berisi header.");
        data.shift();

        const targetSpreadsheet = getSpreadsheet(spreadsheetId);
        let targetSheet = targetSpreadsheet.getSheetByName(sheetName);

        if (sheetName === SHEET_DATA_SISWA) {
            const quotaInfo = getStudentQuotaInfo(userEmail);
            if (quotaInfo.status === 'error') {
                return { status: "error", message: quotaInfo.message };
            }
            let remainingSlots = quotaInfo.remaining;
            if (isNaN(remainingSlots) || remainingSlots < 0) {
                 remainingSlots = 1000000;
            }
            if (remainingSlots <= 0) {
                return { status: "error", message: `Impor dibatalkan. Kuota siswa Anda sudah penuh (${quotaInfo.usedCount}/${quotaInfo.totalLimit}).` };
            }

            targetSheet.getRange("A:C").setNumberFormat("@");
            const existingStudents = getStudents(spreadsheetId);
            const existingNisnMap = new Map();
            existingStudents.forEach(s => {
                if (s.nisn) existingNisnMap.set(s.nisn.toString().trim(), s);
            });

            const newStudents = [];
            const enrichedStudents = [];
            const conflicts = [];
            const skippedDuplicates = [];
            const skippedDueToLimit = [];
            const processedNisns = new Set();

            data.forEach((row) => {
                const nisn = (row[0] || '').toString().trim();
                const namaFromFile = (row[3] || '').toString().trim();
                if (!nisn || !namaFromFile) return;
                if (processedNisns.has(nisn)) {
                    skippedDuplicates.push({ nisn, nama: namaFromFile, reason: 'Duplikat di dalam file import.' });
                    return;
                }
                processedNisns.add(nisn);

                const newData = {
                    nisn: nisn, 
                    nis: row[1] || '', 
                    nomorUjian: row[2] || '',
                    nama: namaFromFile, 
                    jenisKelamin: row[4] || '',
                    tempatLahir: toProperCase(row[5] || ''),
                    tanggalLahir: row[6] ? Utilities.formatDate(new Date(row[6]), Session.getScriptTimeZone(), "yyyy-MM-dd") : '',
                    alamat: row[7] || '', 
                    telepon: row[8] || '', 
                    emailSiswa: row[9] || '',
                    tahunMasuk: row[10] || '', 
                    tahunLulus: row[11] || '',
                    kelas: row[12] || '',
                    ruangUjian: row[13] || ''
                };

                if (existingNisnMap.has(nisn)) {
                    const existingStudent = existingNisnMap.get(nisn);
                    const isIdentical = areStudentsIdentical(existingStudent, newData);
                    if (!isIdentical) {
                        conflicts.push({ nisn: nisn, rowToUpdate: existingStudent.row, oldData: existingStudent, newData: newData });
                    } else {
                        let isEnriched = false;
                        const finalData = { ...existingStudent };
                        Object.keys(newData).forEach(key => {
                            if (!finalData[key] && newData[key]) {
                                finalData[key] = newData[key];
                                isEnriched = true;
                            }
                        });
                        if (isEnriched) {
                            enrichedStudents.push({ ...finalData, studentRow: existingStudent.row });
                        } else {
                            skippedDuplicates.push({ nisn, nama: namaFromFile, reason: 'Data sudah ada dan identik.' });
                        }
                    }
                } else {
                    if (remainingSlots > 0) {
                        const newRowForSheet = [
                            newData.nisn, newData.nis, newData.nomorUjian, newData.nama, newData.jenisKelamin,
                            newData.tempatLahir, newData.tanggalLahir ? new Date(newData.tanggalLahir) : '', newData.alamat, newData.telepon,
                            newData.emailSiswa, newData.tahunMasuk, newData.tahunLulus, 'TIDAK', newData.kelas, newData.ruangUjian
                        ];
                        newStudents.push(newRowForSheet);
                        remainingSlots--;
                    } else {
                        skippedDueToLimit.push({ nisn: nisn, nama: namaFromFile, reason: 'Batas kuota siswa tercapai.' });
                    }
                }
            });

            if (newStudents.length > 0) {
                targetSheet.getRange(targetSheet.getLastRow() + 1, 1, newStudents.length, newStudents[0].length).setValues(newStudents);
            }
            if (enrichedStudents.length > 0) {
                batchUpdateStudents(spreadsheetId, enrichedStudents);
            }

            return {
                status: "partial",
                message: "Proses impor siswa selesai.",
                newCount: newStudents.length,
                enrichedCount: enrichedStudents.length,
                skippedCount: skippedDuplicates.length,
                conflictCount: conflicts.length,
                conflicts: conflicts,
                skippedLimitCount: skippedDueToLimit.length,
                skippedLimitData: skippedDueToLimit
            };
        } else {
            const rowsToAppend = data.filter(row => row.some(cell => cell.toString().trim() !== ""));
            if (rowsToAppend.length > 0) {
                targetSheet.getRange(targetSheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
            }
            return { status: "success", message: `${rowsToAppend.length} data berhasil diimpor ke sheet ${sheetName}.` };
        }

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: `Gagal mengimpor data: ${e.toString()}` };
    } finally {
        if (tempFile) {
            tempFile.setTrashed(true);
        }
    }
}

/**
 * Mengambil daftar mata pelajaran dari sheet 'Data Mata Pelajaran'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {Array<object>} Array objek data mata pelajaran.
 */
function getMapel(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    if (!sheet || sheet.getLastRow() < 2) return [];
    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4);
    const values = dataRange.getValues();
    return values.map((row, index) => ({ row: index + 2, kode: row[0], nama: row[1], kelompok: row[2], jenisUjian: row[3] || '' }));
  } catch (e) { Logger.log(e); return []; }
}

/**
 * [PERBAIKAN] Menambahkan beberapa mata pelajaran sekaligus (input massal)
 * dan mengembalikan daftar mapel terbaru setelah selesai.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} mapelArray Array objek data mata pelajaran baru.
 * @returns {object} Status penambahan DAN daftar mapel yang sudah diupdate.
 */
function addMultipleMapel(spreadsheetId, mapelArray) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_MAPEL);

        const existingMapel = getMapel(spreadsheetId);
        const existingCodes = new Set(existingMapel.map(m => m.kode.toString().trim().toLowerCase()));
        
        const rowsToAppend = [];
        const codesInThisBatch = new Set();
        let skippedCount = 0;

        for (const mapelData of mapelArray) {
            const newCode = (mapelData.kode || '').toString().trim().toLowerCase();
            const newName = (mapelData.nama || '').toString().trim();

            if (!newCode || !newName) {
                skippedCount++;
                continue;
            }

            if (existingCodes.has(newCode) || codesInThisBatch.has(newCode)) {
                skippedCount++;
                continue;
            }

            const jenisUjian = mapelData.jenisUjian || 'Ujian Madrasah';
            
            rowsToAppend.push([mapelData.kode, newName, mapelData.kelompok, jenisUjian]);
            codesInThisBatch.add(newCode);
        }
        
        if (rowsToAppend.length > 0) {
            sheet.getRange(sheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
        }

        let message = `${rowsToAppend.length} mata pelajaran berhasil ditambahkan.`;
        if (skippedCount > 0) {
            message += ` ${skippedCount} mapel dilewati karena tidak lengkap atau kode duplikat.`;
        }

        // ======================================================
        // === PERUBAHAN INTI ADA DI BAWAH INI ===
        // ======================================================

        SpreadsheetApp.flush();
        const updatedMapelList = getMapel(spreadsheetId);

        return { 
            status: "success", 
            message: message,
            updatedMapelList: updatedMapelList // <-- Data baru disertakan di sini
        };

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: "Gagal menambah mapel secara massal: " + e.message };
    }
}

/**
 * [PERBAIKAN] Memperbarui data mata pelajaran DAN mengembalikan daftar mapel terbaru.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} mapelData Data mata pelajaran yang akan diupdate, termasuk nomor baris.
 * @returns {object} Status pembaruan DAN daftar mapel yang sudah diupdate.
 */
function updateMapel(spreadsheetId, mapelData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    
    // Data yang akan ditulis ke baris yang diupdate
    const rowToUpdate = [mapelData.kode, mapelData.nama, mapelData.kelompok, mapelData.jenisUjian];
    sheet.getRange(mapelData.mapelRow, 1, 1, rowToUpdate.length).setValues([rowToUpdate]);
    
    // Paksa Google Sheet untuk menyelesaikan proses update
    SpreadsheetApp.flush();
    
    // Baca kembali data yang sudah terupdate
    const updatedMapelList = getMapel(spreadsheetId);

    // Kembalikan data baru bersama pesan sukses
    return { 
      status: "success", 
      message: `Mata Pelajaran "${mapelData.nama}" berhasil diperbarui.`,
      updatedMapelList: updatedMapelList 
    };
  } catch (e) { 
    Logger.log(e); 
    return { status: "error", message: "Gagal memperbarui data mapel: " + e.message }; 
  }
}

/**
 * [PERBAIKAN] Menghapus mata pelajaran DAN mengembalikan daftar mapel terbaru.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {number} rowNumber Nomor baris yang akan dihapus.
 * @returns {object} Status penghapusan DAN daftar mapel yang sudah diupdate.
 */
function deleteMapel(spreadsheetId, rowNumber) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    sheet.deleteRow(rowNumber);
    
    // Paksa Google Sheet untuk menyelesaikan proses hapus
    SpreadsheetApp.flush();
    
    // Baca kembali data yang sudah terupdate
    const updatedMapelList = getMapel(spreadsheetId);

    // Kembalikan data baru bersama pesan sukses
    return { 
      status: "success", 
      message: "Mata pelajaran berhasil dihapus.",
      updatedMapelList: updatedMapelList 
    };
  } catch (e) { 
    Logger.log(e); 
    return { status: "error", message: "Gagal menghapus mapel: " + e.message }; 
  }
}

/**
 * Menghapus semua mata pelajaran.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllMapel(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    if (sheet && sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }
    return { status: "success", message: "Semua data mata pelajaran telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data mata pelajaran: " + e.message };
  }
}

/**
 * Menyimpan data bobot nilai.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} bobotData Objek berisi bobot nilai.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveBobot(spreadsheetId, bobotData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_BOBOT);
    const bobotRow = [bobotData.bobotUjian, bobotData.bobotRapor];
    if (sheet.getLastRow() >= 2) sheet.getRange("A2:B2").clearContent();
    sheet.getRange(2, 1, 1, bobotRow.length).setValues([bobotRow]);
    return { status: "success", message: "Bobot nilai berhasil disimpan." };
  } catch (e) { Logger.log(e); return { status: "error", message: "Gagal menyimpan bobot nilai: " + e.message }; }
}

/**
 * Mengambil data bobot nilai, atau mengaturnya ke default jika belum ada.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi bobot nilai.
 */
function getBobot(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_BOBOT);
    if (!sheet) {
      return { bobotUjian: 40, bobotRapor: 60 };
    }

    if (sheet.getLastRow() >= 2) {
        const values = sheet.getRange("A2:B2").getValues()[0];
        if (values[0] !== '' && values[1] !== '' && !isNaN(values[0]) && !isNaN(values[1])) {
            return { bobotUjian: values[0], bobotRapor: values[1] };
        }
    }
    
    const defaultBobot = { bobotUjian: 40, bobotRapor: 60 };
    sheet.getRange(2, 1, 1, 2).setValues([[defaultBobot.bobotUjian, defaultBobot.bobotRapor]]);
    
    return defaultBobot;
  } catch (e) { 
    Logger.log('Error di getBobot: ' + e.message); 
    return { bobotUjian: 40, bobotRapor: 60 }; 
  }
}

/**
 * [BARU] Menyimpan nilai KKM sekolah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {number} kkm Nilai KKM yang akan disimpan.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveKkm(spreadsheetId, kkm) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);

    // Jika sheet belum ada, buat baru dan siapkan header & label
    if (!sheet) {
      sheet = ss.insertSheet(SHEET_PENGATURAN);
      sheet.getRange("A1:B1").setValues([['Nama Pengaturan', 'Value']]).setFontWeight('bold');
      sheet.getRange("A2").setValue("KKM Sekolah");
      sheet.setFrozenRows(1);
    }

    // Pastikan label ada jika sheet sudah ada tapi kosong
    if (sheet.getRange("A2").getValue() === "") {
        sheet.getRange("A2").setValue("KKM Sekolah");
    }
    
    // Simpan nilai KKM di sel B2
    sheet.getRange("B2").setValue(kkm);

    return { status: "success", message: "Nilai KKM berhasil disimpan." };
  } catch (e) {
    Logger.log(`saveKkm Error: ${e.message}`);
    return { status: "error", message: `Gagal menyimpan KKM: ${e.message}` };
  }
}

/**
 * [BARU] Mengambil nilai KKM sekolah, atau mengembalikan default jika belum ada.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, kkm: number}} Objek berisi KKM.
 */
function getKkm(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    const defaultValue = 75; // Nilai default KKM jika belum diatur

    if (!sheet || sheet.getLastRow() < 2) {
      return { status: 'success', kkm: defaultValue };
    }

    const kkmValue = sheet.getRange("B2").getValue();
    
    // Jika sel B2 kosong atau tidak valid, kembalikan nilai default
    if (kkmValue === '' || isNaN(kkmValue)) {
        return { status: 'success', kkm: defaultValue };
    }
    
    return { status: 'success', kkm: kkmValue };
  } catch (e) {
    Logger.log(`getKkm Error: ${e.message}`);
    // Jika error, kembalikan nilai default agar aplikasi tidak macet
    return { status: 'success', kkm: 75 }; 
  }
}

/**
 * Mengambil daftar mapel berdasarkan jenis ujian.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} jenis Jenis ujian ('madrasah' atau 'praktek').
 * @returns {Array<object>} Array objek data mata pelajaran.
 */
function getMapelByJenis(spreadsheetId, jenis) {
  const allMapel = getMapel(spreadsheetId);
  if (jenis === 'madrasah') return allMapel.filter(m => m.jenisUjian === 'Ujian Madrasah' || m.jenisUjian === 'Keduanya');
  if (jenis === 'praktek') return allMapel.filter(m => m.jenisUjian === 'Ujian Praktek' || m.jenisUjian === 'Keduanya');
  return [];
}

// File: Kode.gs.html

/**
 * [DIPERBARUI] Menyimpan data nilai ujian.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} data Objek berisi jenis dan data nilai.
 * @returns {object} Status penyimpanan.
 */
function saveNilai(spreadsheetId, data) {
  const { jenis, nilai } = data; //
  const sheetName = jenis === 'madrasah' ? SHEET_NILAI_UJIAN_MADRASAH : SHEET_NILAI_UJIAN_PRAKTEK; //
  const mapelList = getMapelByJenis(spreadsheetId, jenis); //
  
  // Panggil fungsi inti yang baru dan andal
  return saveScoresToSheet(spreadsheetId, sheetName, mapelList, nilai); 
}

// File: Kode.gs.html

/**
 * [DIPERBARUI] Menyimpan data nilai rapor.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} data Objek berisi semester, jenis, dan data nilai.
 * @returns {object} Status penyimpanan.
 */
function saveNilaiRapor(spreadsheetId, data) {
  const { semesterKey, jenisNilai, nilai } = data; //
  const sheetName = `Rapor_${jenisNilai}_${semesterKey}`; //
  const mapelList = getMapel(spreadsheetId); //
  
  // Panggil fungsi inti yang baru dan andal
  return saveScoresToSheet(spreadsheetId, sheetName, mapelList, nilai);
}

/**
 * Mengambil data nilai yang sudah ada dari sebuah sheet.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet nilai.
 * @returns {object} Objek berisi nilai yang sudah ada, dengan NISN sebagai key.
 */
function getExistingNilai(spreadsheetId, sheetName) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() < 2) return {};
    sheet.getRange("A:A").setNumberFormat('@');
    const data = sheet.getDataRange().getValues();
    const headers = data.shift();
    const nisnIndex = headers.indexOf("NISN");
    const existingScores = {};
    data.forEach(row => {
      const nisn = row[nisnIndex];
      if (nisn) {
          existingScores[nisn] = {};
          headers.forEach((header, index) => {
              if (index > 1) existingScores[nisn][header] = row[index];
          });
      }
    });
    return existingScores;
  } catch(e) { Logger.log(e); return {}; }
}

// File: Kode.gs.html

/**
 * [FINAL v2 & DENGAN VALIDASI] Memproses dan menyimpan nilai dari file Excel.
 * Logika ini membangun kembali seluruh sheet nilai, namun HANYA menimpa nilai
 * jika sel di file Excel yang diunggah berisi data (tidak kosong).
 * @param {SpreadsheetApp.Spreadsheet} targetSs - Objek spreadsheet tujuan.
 * @param {string} targetSheetName - Nama sheet yang akan diisi (mis. 'Nilai Ujian Madrasah').
 * @param {SpreadsheetApp.Sheet} importSheet - Objek sheet dari file Excel yang diimpor.
 * @param {Array<object>} mapelForSheet - Daftar mata pelajaran yang relevan untuk sheet ini.
 * @returns {number} Jumlah nilai yang berhasil diupdate atau ditambahkan.
 */
function processSheetImport(targetSs, targetSheetName, importSheet, mapelForSheet) {
    if (importSheet.getLastRow() <= 1) return 0; // File impor kosong

    // 1. Dapatkan daftar siswa utama sebagai sumber kebenaran
    const students = getStudents(targetSs.getId());
    if (!students || students.length === 0) {
        throw new Error("Tidak ada data siswa di sheet 'Data Siswa'. Harap isi terlebih dahulu.");
    }
    
    // 2. Baca data dari file Excel dan simpan ke dalam Map untuk pencarian cepat
    const dataFromExcel = importSheet.getDataRange().getValues();
    const headersFromExcel = dataFromExcel.shift();
    const nisnIndexExcel = headersFromExcel.indexOf("NISN");
    if (nisnIndexExcel === -1) throw new Error(`Kolom 'NISN' tidak ditemukan di sheet "${importSheet.getName()}".`);

    const uploadedDataMap = new Map();
    dataFromExcel.forEach(row => {
        const nisn = row[nisnIndexExcel].toString().trim();
        if (nisn) {
            const scores = new Map();
            headersFromExcel.forEach((header, index) => {
                if (index > 1) scores.set(header.toString().trim(), row[index]);
            });
            uploadedDataMap.set(nisn, scores);
        }
    });

    // 3. Siapkan sheet tujuan
    let targetSheet = targetSs.getSheetByName(targetSheetName);
    if (!targetSheet) {
        targetSheet = targetSs.insertSheet(targetSheetName);
    }
    
    // 4. [BARU] Baca data yang sudah ada di sheet tujuan untuk perbandingan
    const existingScoresMap = getSheetDataAsObject(targetSs.getId(), targetSheetName);

    // 5. Bangun kembali seluruh data yang akan ditulis
    let updatedCount = 0;
    const finalDataToWrite = [];

    students.forEach(student => {
        const nisn = student.nisn;
        const newRow = [nisn, student.nama.toUpperCase()];
        const uploadedScores = uploadedDataMap.get(nisn);
        const existingScores = existingScoresMap[nisn] || {};

        mapelForSheet.forEach(mapel => {
            const mapelKode = mapel.kode;
            let finalScore = existingScores[mapelKode] !== undefined ? existingScores[mapelKode] : ''; // Default ke nilai lama

            // =====================================================================
            // ▼▼▼ AWAL DARI LOGIKA VALIDASI INTI YANG BARU ▼▼▼
            // =====================================================================
            if (uploadedScores && uploadedScores.has(mapelKode)) {
                const uploadedScore = uploadedScores.get(mapelKode);

                // Periksa apakah nilai yang diupload TIDAK kosong.
                // Ini akan melewatkan sel yang kosong (null, undefined, atau string spasi).
                if (uploadedScore !== undefined && uploadedScore !== null && String(uploadedScore).trim() !== '') {
                    // Hanya jika ada nilai baru, timpa nilai lama.
                    finalScore = uploadedScore;

                    // Hitung sebagai "update" hanya jika nilai baru berbeda dari nilai lama.
                    if (String(existingScores[mapelKode] || '') != String(finalScore)) {
                        updatedCount++;
                    }
                }
                // Jika nilai yang diupload kosong, `finalScore` akan tetap berisi `existingScores`,
                // sehingga data lama tidak akan terhapus.
            }
            // =====================================================================
            // ▲▲▲ AKHIR DARI LOGIKA VALIDASI INTI ▲▲▲
            // =====================================================================
            
            newRow.push(finalScore);
        });
        finalDataToWrite.push(newRow);
    });
    
    // 6. Tulis ulang seluruh sheet dengan data yang sudah bersih dan lengkap
    targetSheet.clear(); 
    
    const newHeaders = ["NISN", "Nama Lengkap", ...mapelForSheet.map(m => m.kode)];
    targetSheet.getRange(1, 1, 1, newHeaders.length).setValues([newHeaders]).setFontWeight("bold");
    targetSheet.getRange("A:A").setNumberFormat('@');
    
    if (finalDataToWrite.length > 0) {
        targetSheet.getRange(2, 1, finalDataToWrite.length, newHeaders.length).setValues(finalDataToWrite);
    }
    
    SpreadsheetApp.flush();
    return updatedCount;
}

// =================================================================
// FUNGSI REKAPITULASI NILAI
// =================================================================

/**
 * Mengambil data dari sebuah sheet dan mengubahnya menjadi objek dengan NISN sebagai key.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet.
 * @returns {object} Data sheet dalam bentuk objek.
 */
function getSheetDataAsObject(spreadsheetId, sheetName) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(sheetName);
        if (!sheet || sheet.getLastRow() < 2) return {};
        sheet.getRange("A:A").setNumberFormat('@');
        const data = sheet.getDataRange().getValues();
        const headers = data.shift();
        const nisnIndex = headers.indexOf("NISN");
        if (nisnIndex === -1) return {};

        const dataObj = {};
        data.forEach(row => {
            const nisn = row[nisnIndex].toString().trim();
            if (nisn) {
                dataObj[nisn] = {};
                headers.forEach((header, index) => {
                    // Mulai dari kolom ke-3 (setelah NISN dan Nama)
                    if (index > 1) dataObj[nisn][header] = row[index];
                });
            }
        });
        return dataObj;
    } catch (e) {
        Logger.log(`Error getting data from ${sheetName}: ${e}`);
        return {};
    }
}

/**
 * Memperbarui semua data di sheet rekapitulasi.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status pembaruan.
 */
function updateRekapitulasi(spreadsheetId) {
  try {
    const students = getStudents(spreadsheetId); //
    if (!students || students.length === 0) {
      return {status: 'error', message: 'Tidak ada data siswa untuk direkap.'};
    }
    const mapel = getMapel(spreadsheetId); //
    if (!mapel || mapel.length === 0) {
      return {status: 'error', message: 'Tidak ada data mata pelajaran untuk direkap.'};
    }
    const bobot = getBobot(spreadsheetId) || { bobotUjian: 0, bobotRapor: 0 }; //
    const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang; //

    if (!jenjang) {
      return {status: 'error', message: 'Jenjang sekolah belum diatur di menu Data Sekolah.'};
    }

    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    const semestersForJenjang = semesterKeys[jenjang] || [];

    const sheetsToRead = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK]; //
    semestersForJenjang.forEach(smKey => {
        sheetsToRead.push(`Rapor_Pengetahuan_${smKey}`);
        sheetsToRead.push(`Rapor_Keterampilan_${smKey}`);
    });
    
    const allData = {};
    sheetsToRead.forEach(sheetName => {
        allData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName); //
    });

    const nilaiUjianMadrasah = allData[SHEET_NILAI_UJIAN_MADRASAH] || {}; //
    const nilaiUjianPraktek = allData[SHEET_NILAI_UJIAN_PRAKTEK] || {}; //
    
    const rekapUjian = {};
    const rekapRapor = {};
    const rekapIjazah = {};

    students.forEach(student => {
        const nisn = student.nisn.toString().trim();
        rekapUjian[nisn] = {};
        rekapRapor[nisn] = {};
        rekapIjazah[nisn] = {};

        mapel.forEach(m => {
            const kode = m.kode;
            const nilaiUM = parseFloat( (nilaiUjianMadrasah[nisn] || {})[kode] );
            const nilaiUP = parseFloat( (nilaiUjianPraktek[nisn] || {})[kode] );

            let rataUjian = null; // Default ke null
            const hasUM = !isNaN(nilaiUM);
            const hasUP = !isNaN(nilaiUP);

            if (hasUM && hasUP) rataUjian = (nilaiUM + nilaiUP) / 2;
            else if (hasUM) rataUjian = nilaiUM;
            else if (hasUP) rataUjian = nilaiUP;
            
            if(rataUjian !== null) rekapUjian[nisn][kode] = rataUjian;

            let totalNilaiRapor = 0;
            let semesterCount = 0;
            
            semestersForJenjang.forEach(smKey => {
                const sheetNameP = `Rapor_Pengetahuan_${smKey}`;
                const sheetNameK = `Rapor_Keterampilan_${smKey}`;
                
                const nilaiP = parseFloat( ((allData[sheetNameP] || {})[nisn] || {})[kode] );
                const nilaiK = parseFloat( ((allData[sheetNameK] || {})[nisn] || {})[kode] );

                if (!isNaN(nilaiP) && !isNaN(nilaiK)) {
                    totalNilaiRapor += (nilaiP + nilaiK) / 2;
                    semesterCount++;
                } else if (!isNaN(nilaiP)) {
                    totalNilaiRapor += nilaiP;
                    semesterCount++;
                } else if (!isNaN(nilaiK)) {
                    totalNilaiRapor += nilaiK;
                    semesterCount++;
                }
            });

            const rataRapor = semesterCount > 0 ? totalNilaiRapor / semesterCount : 0;
            if (semesterCount > 0) rekapRapor[nisn][kode] = rataRapor;

            const bobotUjianVal = parseFloat(bobot.bobotUjian) || 0;
            const bobotRaporVal = parseFloat(bobot.bobotRapor) || 0;

            const finalRataUjian = rataUjian !== null ? rataUjian : 0;
            const finalRataRapor = semesterCount > 0 ? rataRapor : 0;

            if (rataUjian !== null || semesterCount > 0) {
              const nilaiAkhir = (finalRataUjian * (bobotUjianVal / 100)) + (finalRataRapor * (bobotRaporVal / 100));
              rekapIjazah[nisn][kode] = nilaiAkhir;
            }
        });
    });

    saveRekapSheet(spreadsheetId, SHEET_REKAP_UJIAN, students, mapel, rekapUjian); //
    saveRekapSheet(spreadsheetId, SHEET_REKAP_RAPOR, students, mapel, rekapRapor); //
    saveRekapSheet(spreadsheetId, SHEET_REKAP_IJAZAH, students, mapel, rekapIjazah); //
    
    return {status: "success", message: "Data rekapitulasi berhasil diperbarui."};
  } catch(e) {
    Logger.log(e);
    return {status: "error", message: "Gagal memperbarui rekapitulasi: " + e.message};
  }
}

/**
 * [PERBAIKAN RATA-RATA v2] Menyimpan data rekapitulasi ke sheet yang ditentukan.
 * Rata-rata kini DIHITUNG DARI TOTAL NILAI DIBAGI JUMLAH TOTAL MAPEL.
 * Nilai kosong dianggap 0.
 */
function saveRekapSheet(spreadsheetId, sheetName, students, mapel, data) {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
        sheet = ss.insertSheet(sheetName);
    }
    sheet.clear();

    // [PERUBAHAN DIMULAI] - Menambahkan header baru secara dinamis
    const headers = ["NISN", "Nama Lengkap", ...mapel.map(m => m.kode), "Jumlah", "Rata-rata"];
    if (sheetName === SHEET_REKAP_IJAZAH) {
        headers.push("Status");
    } else if (sheetName === SHEET_REKAP_UJIAN) {
        // Tambahkan header baru untuk rekap ujian
        headers.push("Rata-Rata AM (PDUM)");
    }
    // [PERUBAHAN SELESAI]

    sheet.appendRow(headers);
    sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold");
    sheet.getRange("A:A").setNumberFormat("@");

    const isIjazahSheet = sheetName === SHEET_REKAP_IJAZAH;
    const isUjianSheet = sheetName === SHEET_REKAP_UJIAN; // Tambahkan flag ini
    const kkm = isIjazahSheet ? (getKkm(spreadsheetId).kkm || 75) : 0;

    const rows = students.map(student => {
        const nisn = student.nisn.toString().trim();
        const rowData = [nisn, student.nama];
        
        let roundedTotal = 0;
        const mapelCount = mapel.length; 

        mapel.forEach(m => {
            const rawScore = (data[nisn] || {})[m.kode];
            let numericScore = parseFloat(rawScore);

            if (isNaN(numericScore)) {
                numericScore = 0;
            }
            
            const roundedScore = Math.round(numericScore);
            roundedTotal += roundedScore;
            rowData.push(roundedScore);
        });

        const average = mapelCount > 0 ? (roundedTotal / mapelCount) : 0;
        
        rowData.push(roundedTotal);
        rowData.push(average);

        if (isIjazahSheet) {
            let status = '-';
            if (mapelCount > 0) {
                 status = (average >= kkm) ? 'LULUS' : 'TIDAK LULUS';
            }
            rowData.push(status);
        }

        // [PERUBAHAN DIMULAI] - Menambahkan data untuk kolom baru
        if (isUjianSheet) {
            // Hitung dan tambahkan nilai pembulatan
            rowData.push(Math.round(average));
        }
        // [PERUBAHAN SELESAI]

        return rowData;
    });

    if (rows.length > 0) {
        sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
    }
}

/**
 * Mengambil semua data rekapitulasi untuk ditampilkan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi semua data rekapitulasi.
 */
function getRekapitulasiData(spreadsheetId) {
  const students = getStudents(spreadsheetId);
  const mapel = getMapel(spreadsheetId);
  const bobot = getBobot(spreadsheetId); // Tambahkan baris ini
  return {
    students,
    mapel,
    bobot, // Tambahkan properti ini
    rekapUjian: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_UJIAN),
    rekapRapor: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_RAPOR),
    rekapIjazah: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_IJAZAH),
  };
}

/**
 * [BARU & OPTIMIZED] Mengambil semua data untuk halaman rekapitulasi dalam satu operasi.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi semua data rekapitulasi.
 */
function getRekapitulasiData_Optimized(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId); // Membuka spreadsheet HANYA SEKALI

    // Helper function untuk memproses data dari sheet menjadi objek
    const processSheetData = (sheet) => {
      if (!sheet || sheet.getLastRow() < 2) return {};
      sheet.getRange("A:A").setNumberFormat('@');
      const data = sheet.getDataRange().getValues();
      const headers = data.shift();
      const nisnIndex = headers.indexOf("NISN");
      if (nisnIndex === -1) return {};

      const dataObj = {};
      data.forEach(row => {
        const nisn = row[nisnIndex].toString().trim();
        if (nisn) {
          dataObj[nisn] = {};
          headers.forEach((header, index) => {
            if (header !== "NISN" && header !== "Nama Lengkap") {
              dataObj[nisn][header] = row[index];
            }
          });
        }
      });
      return dataObj;
    };

    // 1. Mengambil Data Siswa
    const studentSheet = ss.getSheetByName(SHEET_DATA_SISWA);
    let students = [];
    if (studentSheet && studentSheet.getLastRow() >= 2) {
      studentSheet.getRange("A:B").setNumberFormat('@');
      const studentValues = studentSheet.getRange(2, 1, studentSheet.getLastRow() - 1, 5).getValues();
      students = studentValues.map((row, index) => {
        let tanggalLahirStr = '';
        if (row[4] && row[4] instanceof Date) {
          tanggalLahirStr = Utilities.formatDate(row[4], Session.getScriptTimeZone(), "yyyy-MM-dd");
        }
        return { row: index + 2, nisn: row[0], nis: row[1], nama: row[2], tempatLahir: row[3], tanggalLahir: tanggalLahirStr };
      });
    }

    // 2. Mengambil Data Mapel
    const mapelSheet = ss.getSheetByName(SHEET_MAPEL);
    let mapel = [];
    if (mapelSheet && mapelSheet.getLastRow() >= 2) {
      const mapelValues = mapelSheet.getRange(2, 1, mapelSheet.getLastRow() - 1, 4).getValues();
      mapel = mapelValues.map((row, index) => ({ row: index + 2, kode: row[0], nama: row[1], kelompok: row[2], jenisUjian: row[3] || '' }));
    }

    // 3. Mengambil Data Bobot
    const bobotSheet = ss.getSheetByName(SHEET_BOBOT);
    let bobot = { bobotUjian: 40, bobotRapor: 60 };
    if (bobotSheet && bobotSheet.getLastRow() >= 2) {
      const bobotValues = bobotSheet.getRange("A2:B2").getValues()[0];
      if (bobotValues[0] !== '' && bobotValues[1] !== '' && !isNaN(bobotValues[0]) && !isNaN(bobotValues[1])) {
        bobot = { bobotUjian: bobotValues[0], bobotRapor: bobotValues[1] };
      }
    }
    
    // =======================================================
    // ▼▼▼ PERUBAHAN UTAMA ADA DI SINI ▼▼▼
    // =======================================================
    // 4. Mengambil Data KKM
    const kkmData = getKkm(spreadsheetId); // Panggil fungsi yang sudah kita buat
    const kkm = kkmData.kkm; // Ambil nilainya
    // =======================================================
    // ▲▲▲ AKHIR DARI PERUBAHAN ▲▲▲
    // =======================================================

    // 5. Mengambil Semua Data Rekapitulasi
    const rekapUjian = processSheetData(ss.getSheetByName(SHEET_REKAP_UJIAN));
    const rekapRapor = processSheetData(ss.getSheetByName(SHEET_REKAP_RAPOR));
    const rekapIjazah = processSheetData(ss.getSheetByName(SHEET_REKAP_IJAZAH));

    // Kirim semua data, termasuk KKM, ke frontend
    return { status: "success", data: { students, mapel, bobot, kkm, rekapUjian, rekapRapor, rekapIjazah } };

  } catch (e) {
    Logger.log(`Error di getRekapitulasiData_Optimized: ${e}`);
    return { status: "error", message: "Gagal mengambil data rekapitulasi: " + e.message };
  }
}

/**
 * [VERSI FINAL] Mengambil semua data yang diperlukan untuk membuat transkrip siswa,
 * termasuk data siswa, sekolah, mata pelajaran, bobot nilai, dan pengaturan cetak yang tersimpan.
 *
 * @param {string} spreadsheetId - ID spreadsheet sekolah target.
 * @param {string} nisn - NISN siswa yang akan diambil datanya.
 * @returns {object} Objek berisi status dan payload data transkrip yang lengkap.
 */
function getTranscriptData(spreadsheetId, nisn) {
    try {
        // 1. Validasi Input Awal
        if (!spreadsheetId || !nisn) {
            throw new Error("ID Spreadsheet atau NISN tidak boleh kosong.");
        }

        // 2. Mengambil Data Utama
        const allStudents = getStudents(spreadsheetId);
        const student = allStudents.find(s => String(s.nisn).trim() === String(nisn).trim());

        if (!student) {
            throw new Error(`Siswa dengan NISN ${nisn} tidak dapat ditemukan.`);
        }

        const schoolData = getSchoolData(spreadsheetId);
        const mapelList = getMapel(spreadsheetId);
        const bobot = getBobot(spreadsheetId);
        const printSettings = getPrintSettings(spreadsheetId).settings || {}; // Mengambil pengaturan cetak

        if (!schoolData || !schoolData.jenjang) {
            throw new Error("Jenjang sekolah belum diatur. Silakan lengkapi di menu Data Sekolah.");
        }

        // 3. Menyiapkan Daftar Sheet Nilai yang Akan Dibaca
        const jenjang = schoolData.jenjang;
        const semesterKeys = {
            MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
            MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
            MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
        };
        const semestersForJenjang = semesterKeys[jenjang] || [];
        const sheetsToRead = [
            SHEET_NILAI_UJIAN_MADRASAH,
            SHEET_NILAI_UJIAN_PRAKTEK,
            ...semestersForJenjang.flatMap(smKey => [`Rapor_Pengetahuan_${smKey}`, `Rapor_Keterampilan_${smKey}`])
        ];

        // 4. Membaca Semua Data Nilai dalam Satu Operasi
        const allScoreData = {};
        sheetsToRead.forEach(sheetName => {
            allScoreData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName);
        });

        // 5. Melakukan Kalkulasi untuk Setiap Mata Pelajaran
        const transcriptSubjects = mapelList.map(mapel => {
            const kode = mapel.kode;
            const studentScoresUM = (allScoreData[SHEET_NILAI_UJIAN_MADRASAH] || {})[nisn] || {};
            const studentScoresUP = (allScoreData[SHEET_NILAI_UJIAN_PRAKTEK] || {})[nisn] || {};
            
            // Hitung Rata-rata Nilai Ujian
            const nilaiUM = parseFloat(studentScoresUM[kode]);
            const nilaiUP = parseFloat(studentScoresUP[kode]);
            let rataUjian = null;
            if (!isNaN(nilaiUM) && !isNaN(nilaiUP)) rataUjian = (nilaiUM + nilaiUP) / 2;
            else if (!isNaN(nilaiUM)) rataUjian = nilaiUM;
            else if (!isNaN(nilaiUP)) rataUjian = nilaiUP;

            // Hitung Rata-rata Nilai Rapor
            let totalNilaiRapor = 0;
            let semesterCount = 0;
            semestersForJenjang.forEach(smKey => {
                const nilaiP = parseFloat(((allScoreData[`Rapor_Pengetahuan_${smKey}`] || {})[nisn] || {})[kode]);
                const nilaiK = parseFloat(((allScoreData[`Rapor_Keterampilan_${smKey}`] || {})[nisn] || {})[kode]);
                if (!isNaN(nilaiP) && !isNaN(nilaiK)) { totalNilaiRapor += (nilaiP + nilaiK) / 2; semesterCount++; }
                else if (!isNaN(nilaiP)) { totalNilaiRapor += nilaiP; semesterCount++; }
                else if (!isNaN(nilaiK)) { totalNilaiRapor += nilaiK; semesterCount++; }
            });
            const rataRapor = semesterCount > 0 ? totalNilaiRapor / semesterCount : null;

            // Hitung Nilai Akhir Ijazah
            let nilaiIjazah = null;
            if (rataUjian !== null || rataRapor !== null) {
                const finalRataUjian = rataUjian !== null ? rataUjian : 0;
                const finalRataRapor = rataRapor !== null ? rataRapor : 0;
                nilaiIjazah = (finalRataUjian * (bobot.bobotUjian / 100)) + (finalRataRapor * (bobot.bobotRapor / 100));
            }

            return {
                kode: kode,
                nama: mapel.nama,
                kelompok: mapel.kelompok,
                nilaiRapor: rataRapor,
                nilaiUjian: rataUjian,
                nilaiIjazah: nilaiIjazah
            };
        });

        // 6. Menyusun Paket Data Final untuk Dikirim
        const finalTranscriptData = {
            student: student,
            school: schoolData,
            subjects: transcriptSubjects,
            bobot: bobot,
            printSettings: printSettings // Menyertakan pengaturan cetak
        };

        return { status: 'success', data: finalTranscriptData };

    } catch (e) {
        Logger.log('Error di getTranscriptData: ' + e.message + ' | Stack: ' + e.stack);
        return { status: 'error', message: 'Gagal mengambil data transkrip: ' + e.message };
    }
}

/**
 * Memeriksa apakah sheet rekapitulasi sudah ada.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {boolean} True jika semua sheet ada.
 */
function checkRekapSheetsExist(spreadsheetId) {
  const ss = getSpreadsheet(spreadsheetId);
  const sheetUjian = ss.getSheetByName(SHEET_REKAP_UJIAN);
  const sheetRapor = ss.getSheetByName(SHEET_REKAP_RAPOR);
  const sheetIjazah = ss.getSheetByName(SHEET_REKAP_IJAZAH);
  return !!(sheetUjian && sheetRapor && sheetIjazah);
}

/**
 * [DIPERBARUI] Mengekspor data rekapitulasi ke format PDF atau Excel.
 * Kini menyertakan kolom Status LULUS/TIDAK LULUS untuk rekap ijazah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} type Jenis rekap ('ujian', 'rapor', 'ijazah').
 * @param {string} format Format ekspor ('pdf' atau 'excel').
 * @param {object} exportOptions Objek berisi data dari form modal.
 * @returns {object} Objek berisi data file yang telah di-encode base64.
 */
function exportRekapData(spreadsheetId, type, format, exportOptions) {
    let tempSpreadsheetFileId = null;
    try {
        // 1. Tentukan Judul Laporan
        let reportTitle;
        switch (type) {
            case 'ijazah': reportTitle = "REKAPITULASI NILAI IJAZAH"; break;
            case 'rapor': reportTitle = "REKAPITULASI NILAI RAPOR"; break;
            case 'ujian': reportTitle = "REKAPITULASI NILAI UJIAN"; break;
            default: throw new Error("Jenis rekap tidak valid.");
        }

        // 2. Ambil data yang diperlukan
        const { students, mapel } = getRekapitulasiData(spreadsheetId);
        if (!students || students.length === 0) throw new Error("Tidak ada data siswa untuk diekspor.");
        
        // [BARU] Ambil data KKM jika yang diekspor adalah rekap ijazah
        const kkm = (type === 'ijazah') ? (getKkm(spreadsheetId).kkm || 75) : 75;

        const sheetName = `Rekap Nilai ${type.charAt(0).toUpperCase() + type.slice(1)}`;
        const dataToProcess = getSheetDataAsObject(spreadsheetId, sheetName);

        // 3. Bangun data tabel
        const tableBodyData = [];
        students.forEach((student, index) => {
            const nisn = student.nisn;
            const studentScores = dataToProcess[nisn] || {};
            const rowData = [index + 1, `'${nisn}`, student.nama.toUpperCase()];
            
            let total = 0;
            // [PERBAIKAN 1] Kembalikan deklarasi validScoresCount untuk pengecekan status.
            let validScoresCount = 0; 

            mapel.forEach(m => {
                const score = parseFloat(studentScores[m.kode]);
                let displayValue = 0; // Default ke 0

                if (!isNaN(score)) {
                    const roundedScore = Math.round(score);
                    displayValue = roundedScore;
                    total += roundedScore;
                    // [PERBAIKAN 2] Kembalikan increment (penambahan) validScoresCount.
                    validScoresCount++; 
                }
                
                // Selalu push angka 0 atau nilai yang ada
                rowData.push(displayValue);
            });

            // [TETAP] Rata-rata TETAP menggunakan logika baru (dibagi jumlah total mapel).
            const mapelCount = mapel.length;
            const average = mapelCount > 0 ? (total / mapelCount) : 0;
            
            rowData.push(total);
            rowData.push(average.toFixed(2).replace('.', ','));

            if (type === 'ujian') {
                rowData.push(Math.round(average));
            } else if (type === 'ijazah') {
                // [TETAP] Status LULUS/TIDAK LULUS sekarang berfungsi kembali karena validScoresCount sudah ada.
                const status = (validScoresCount > 0 && average >= kkm) ? 'LULUS' : 'TIDAK LULUS';
                rowData.push(status);
            }
            
            tableBodyData.push(rowData);
        });
        
        // 4. Buat spreadsheet sementara
        const tempSpreadsheetName = `Cetak_${reportTitle.replace(/ /g, "_")}_${new Date().getTime()}`;
        const tempSpreadsheet = SpreadsheetApp.create(tempSpreadsheetName);
        tempSpreadsheetFileId = tempSpreadsheet.getId();
        const tempSheet = tempSpreadsheet.getSheets()[0];
        tempSheet.setName("Rekapitulasi");

        // --- PEMFORMATAN KUSTOM ---
        const schoolData = getSchoolData(spreadsheetId);
        let currentRow = 1;
        const numMapel = mapel.length;

        // [MODIFIKASI] Sesuaikan jumlah total kolom jika tipenya 'ujian' atau 'ijazah'
        let numColumns = numMapel + 5; // No, NISN, Nama, Jumlah, Rata-Rata
        if (type === 'ujian' || type === 'ijazah') {
            numColumns++; // Tambah 1 untuk kolom Pembulatan atau Status
        }

        // Header Laporan (tidak berubah)
        tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue(reportTitle).setFontSize(16);
        currentRow++;
        tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue((schoolData.namaSekolah || "NAMA SEKOLAH").toUpperCase()).setFontSize(16);
        currentRow++;
        tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue(`Tahun Ajaran ${exportOptions.tahunAjaran || ""}`).setFontSize(14);
        currentRow += 2;

        // --- HEADER TABEL (STRUKTUR 2 BARIS) ---
        const tableStartRow = currentRow;
        tempSheet.getRange(tableStartRow, 4, 1, numMapel).merge().setValue("MATA PELAJARAN");
        const mapelHeaders = mapel.map(m => m.kode);
        tempSheet.getRange(tableStartRow + 1, 4, 1, numMapel).setValues([mapelHeaders]);
        
        // Header Tetap
        tempSheet.getRange(tableStartRow, 1).setValue("No.");
        tempSheet.getRange(tableStartRow, 2).setValue("NISN");
        tempSheet.getRange(tableStartRow, 3).setValue("Nama Siswa");
        const jumlahCol = 4 + numMapel;
        const rataRataCol = 5 + numMapel;
        tempSheet.getRange(tableStartRow, jumlahCol).setValue("Jumlah");
        tempSheet.getRange(tableStartRow, rataRataCol).setValue("Rata-Rata");

        // Merge Vertikal
        tempSheet.getRange(tableStartRow, 1, 2, 1).merge();
        tempSheet.getRange(tableStartRow, 2, 2, 1).merge();
        tempSheet.getRange(tableStartRow, 3, 2, 1).merge();
        tempSheet.getRange(tableStartRow, jumlahCol, 2, 1).merge();
        tempSheet.getRange(tableStartRow, rataRataCol, 2, 1).merge();
        
        // [MODIFIKASI] Tambahkan header "Pembulatan" atau "Status"
        if (type === 'ujian') {
            const pembulatanCol = 6 + numMapel;
            tempSheet.getRange(tableStartRow, pembulatanCol).setValue("Pembulatan");
            tempSheet.getRange(tableStartRow, pembulatanCol, 2, 1).merge();
        } else if (type === 'ijazah') {
            const statusCol = 6 + numMapel;
            tempSheet.getRange(tableStartRow, statusCol).setValue("Status");
            tempSheet.getRange(tableStartRow, statusCol, 2, 1).merge();
        }
        
        // Tulis Body Tabel
        if (tableBodyData.length > 0) {
            tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, numColumns).setValues(tableBodyData);
        }

        // --- APLIKASI FORMAT ---
        const fullRange = tempSheet.getRange(1, 1, tempSheet.getLastRow() + 5, numColumns);
        fullRange.setFontFamily("Arial").setVerticalAlignment("middle");
        tempSheet.getRange(1, 1, 3, 1).setFontWeight("bold").setHorizontalAlignment("center");
        const tableHeaderRange = tempSheet.getRange(tableStartRow, 1, 2, numColumns);
        tableHeaderRange.setFontWeight("bold").setFontSize(12).setHorizontalAlignment("center").setBackground("#ffff00");
        if (tableBodyData.length > 0) {
            tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, numColumns).setFontSize(12);
            tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, 1).setHorizontalAlignment("center");
            tempSheet.getRange(tableStartRow + 2, 2, tableBodyData.length, 1).setNumberFormat("@").setHorizontalAlignment("center");
            tempSheet.getRange(tableStartRow + 2, 3, tableBodyData.length, 1).setHorizontalAlignment("left");
            tempSheet.getRange(tableStartRow + 2, 4, tableBodyData.length, numColumns - 3).setHorizontalAlignment("center");
        }
        tempSheet.getRange(tableStartRow, 1, tableBodyData.length + 2, numColumns).setBorder(true, true, true, true, true, true);
        
        // --- [BARU] PEWARNAAN KONDISIONAL UNTUK STATUS ---
        if (type === 'ijazah' && tableBodyData.length > 0) {
            const statusColumnIndex = numColumns; // Status adalah kolom terakhir
            const statusRange = tempSheet.getRange(tableStartRow + 2, statusColumnIndex, tableBodyData.length, 1);

            const ruleLulus = SpreadsheetApp.newConditionalFormatRule()
                .whenTextEqualTo("LULUS")
                .setBackground("#dcfce7") // Tailwind green-100
                .setFontColor("#166534")  // Tailwind green-800
                .setBold(true)
                .setRanges([statusRange])
                .build();

            const ruleTidakLulus = SpreadsheetApp.newConditionalFormatRule()
                .whenTextEqualTo("TIDAK LULUS")
                .setBackground("#fee2e2") // Tailwind red-100
                .setFontColor("#991b1b")  // Tailwind red-800
                .setBold(true)
                .setRanges([statusRange])
                .build();
            
            const rules = tempSheet.getConditionalFormatRules();
            rules.push(ruleLulus, ruleTidakLulus);
            tempSheet.setConditionalFormatRules(rules);

            // [BARU] Atur format spesifik untuk kolom Status agar tidak terpotong
            statusRange.setWrap(false).setHorizontalAlignment('center');
        }
        
        // --- Atur Lebar Kolom ---
        tempSheet.setColumnWidth(1, 40);
        tempSheet.setColumnWidth(2, 100);
        tempSheet.setColumnWidth(3, 220);
        for (let i = 4; i <= 3 + numMapel; i++) {
            tempSheet.setColumnWidth(i, 60);
        }
        tempSheet.setColumnWidth(jumlahCol, 80);
        tempSheet.setColumnWidth(rataRataCol, 80);
        // [MODIFIKASI] Atur lebar kolom "Pembulatan" atau "Status"
        if (type === 'ujian') {
            tempSheet.setColumnWidth(6 + numMapel, 90);
        } else if (type === 'ijazah') {
            tempSheet.setColumnWidth(6 + numMapel, 120);
        }

        // Blok Tanda Tangan
        const signatureBlockStartRow = tableStartRow + tableBodyData.length + 3;
        const signatureColumnStart = numColumns - 3;
        const formatDateToIndonesian = (dateString) => {
          if (!dateString) return "";
          const date = new Date(dateString);
          return new Intl.DateTimeFormat('id-ID', { day: '2-digit', month: 'long', year: 'numeric' }).format(date);
        };
        
        let ttdRow = signatureBlockStartRow;
        const ttdDate = formatDateToIndonesian(exportOptions.tanggalTTD);
        
        tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(`${exportOptions.tempatTTD || "Tempat"}, ${ttdDate}`);
        ttdRow++;
        tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(exportOptions.tipeKamad || "Kepala Madrasah");
        ttdRow += 3;
        tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(schoolData.namaKepsek || "Nama Kepala").setFontWeight("bold").setFontLine('underline');
        ttdRow++;
        const nipRange = tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge();
        nipRange.setNumberFormat("@");
        nipRange.setValue(schoolData.nipKepsek ? `NIP. ${schoolData.nipKepsek}` : "NIP. -");
        
        // Samakan ukuran font seluruh blok ttd
        tempSheet.getRange(signatureBlockStartRow, signatureColumnStart, 5, 4).setFontSize(12).setHorizontalAlignment("left");
        
        SpreadsheetApp.flush(); 

        // 5. Ekspor file
        const exportUrl = `https://docs.google.com/spreadsheets/d/${tempSpreadsheetFileId}/export`;
        const token = ScriptApp.getOAuthToken();
        const fetchOptions = { headers: { Authorization: `Bearer ${token}` }, muteHttpExceptions: true };
        let blob, fileName, mimeType;

        if (format === 'excel') {
          fileName = `${reportTitle.replace(/ /g, "_")}.xlsx`;
          mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
          const url = `${exportUrl}?format=xlsx`;
          blob = UrlFetchApp.fetch(url, fetchOptions).getBlob().setName(fileName);
        } else { // PDF
          fileName = `${reportTitle.replace(/ /g, "_")}.pdf`;
          mimeType = 'application/pdf';
          const pdfOptions = `?exportFormat=pdf&format=pdf&size=A4&portrait=false&fitw=true&sheetnames=false&printtitle=false&gridlines=false&gid=${tempSheet.getSheetId()}`;
          const url = `${exportUrl}${pdfOptions}`;
          blob = UrlFetchApp.fetch(url, fetchOptions).getBlob().setName(fileName);
        }
        
        if (!blob || blob.getBytes().length === 0) throw new Error("Gagal membuat file ekspor. Blob kosong.");
        
        // 6. Kembalikan data file
        return {
          fileName: fileName,
          mimeType: mimeType,
          base64Data: Utilities.base64Encode(blob.getBytes())
        };

    } catch (e) {
        Logger.log(`Export Error: ${e.toString()}\nStack: ${e.stack}`);
        return { error: e.toString() };
    } finally {
        if (tempSpreadsheetFileId) {
            DriveApp.getFileById(tempSpreadsheetFileId).setTrashed(true);
        }
    }
}

/**
 * [BARU] Menghitung rata-rata skor untuk setiap mata pelajaran dari sheet rekap.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi data rata-rata untuk setiap jenis rekap.
 */
function getSubjectAverageScores(spreadsheetId) {
  try {
    const mapel = getMapel(spreadsheetId);
    if (!mapel || mapel.length === 0) return {};

    const ss = getSpreadsheet(spreadsheetId);
    const labels = mapel.map(m => m.kode);

    // Helper function untuk memproses satu sheet
    const calculateAveragesForSheet = (sheetName) => {
      const sheet = ss.getSheetByName(sheetName);
      const averages = {};
      labels.forEach(l => averages[l] = 0); // Inisialisasi semua rata-rata ke 0

      if (!sheet || sheet.getLastRow() < 2) {
        return labels.map(() => 0); // Kembalikan array nol jika sheet kosong
      }

      const data = sheet.getDataRange().getValues();
      const headers = data.shift();
      const studentCount = data.length;
      if (studentCount === 0) return labels.map(() => 0);

      // Hitung total untuk setiap kolom
      const totals = new Array(headers.length).fill(0);
      data.forEach(row => {
        for (let i = 2; i < headers.length; i++) { // Mulai dari kolom ke-3 (setelah NISN dan Nama)
          const value = parseFloat(row[i]);
          if (!isNaN(value)) {
            totals[i] += value;
          }
        }
      });

      // Hitung rata-rata
      headers.forEach((header, i) => {
        if (averages.hasOwnProperty(header)) {
          averages[header] = totals[i] / studentCount;
        }
      });
      
      return labels.map(label => Math.round(averages[label] || 0));
    };

    return {
      ujian: { labels, data: calculateAveragesForSheet(SHEET_REKAP_UJIAN) },
      rapor: { labels, data: calculateAveragesForSheet(SHEET_REKAP_RAPOR) },
      ijazah: { labels, data: calculateAveragesForSheet(SHEET_REKAP_IJAZAH) }
    };

  } catch (e) {
    Logger.log("Error in getSubjectAverageScores: " + e.message);
    return {};
  }
}


/**
 * [DIUBAH & DIPERBAIKI] Mengambil data nilai rata-rata ujian untuk setiap siswa.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {Array<Object>} Array objek berisi nama dan skor rata-rata ujian setiap siswa.
 */
function getExamScoreShare(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const rekapUjianSheet = ss.getSheetByName(SHEET_REKAP_UJIAN);

    if (!rekapUjianSheet || rekapUjianSheet.getLastRow() < 2) {
      return [{ nama: 'Belum Ada Data', skor: 1 }];
    }

    const dataRange = rekapUjianSheet.getRange(2, 1, rekapUjianSheet.getLastRow() - 1, rekapUjianSheet.getLastColumn()).getValues();
    const headers = rekapUjianSheet.getRange(1, 1, 1, rekapUjianSheet.getLastColumn()).getValues()[0];

    // [PERBAIKAN] Mencari header "Nama Lengkap" dan "Rata-rata"
    const namaIndex = headers.indexOf("Nama Lengkap");
    const skorIndex = headers.indexOf("Rata-rata");

    if (namaIndex === -1 || skorIndex === -1) {
       return [{ nama: 'Kolom Tidak Ditemukan', skor: 1 }];
    }

    const studentScores = dataRange.map(row => {
      return {
        nama: row[namaIndex],
        skor: parseFloat(row[skorIndex]) || 0
      };
    });

    return studentScores;

  } catch (e) {
    Logger.log("Error in getExamScoreShare: " + e.message);
    return [{ nama: 'Gagal Memuat', skor: 1 }];
  }
}

/**
 * [DIPERBAIKI] Mendapatkan peringkat siswa berdasarkan nilai rata-rata ijazah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {array} Array objek berisi nama siswa dan rata-rata nilai ijazah, diurutkan berdasarkan peringkat.
 */
function getIjazahRanking(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const rekapIjazahSheet = ss.getSheetByName(SHEET_REKAP_IJAZAH);

    if (!rekapIjazahSheet || rekapIjazahSheet.getLastRow() < 2) {
      return [];
    }

    const dataRange = rekapIjazahSheet.getDataRange().getValues();
    const headers = dataRange.shift();
    
    // [PERBAIKAN] Mencari header "Nama Lengkap" dan "Rata-rata"
    const namaKolomIndex = headers.indexOf('Nama Lengkap');
    const nilaiKolomIndex = headers.indexOf('Rata-rata');

    if (namaKolomIndex === -1 || nilaiKolomIndex === -1) {
      return [];
    }

    const studentRanks = dataRange.map(row => ({
      nama: row[namaKolomIndex],
      nilai: parseFloat(row[nilaiKolomIndex]) || 0
    }));

    studentRanks.sort((a, b) => b.nilai - a.nilai);
    return studentRanks;

  } catch (e) {
    Logger.log("Error in getIjazahRanking: " + e.message);
    return [];
  }
}

/**
 * [MODIFIKASI] Mengambil data agregat untuk halaman dashboard.
 * Kini juga menyertakan jumlah siswa dengan nilai yang belum lengkap.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi data untuk dashboard.
 */
function getDashboardData(spreadsheetId) {
  try {
    // --- AWAL LOGIKA BARU UNTUK MENGAMBIL KODE SEKOLAH ---
    let schoolCode = 'TIDAK ADA';
    try {
      const masterSs = SpreadsheetApp.getActiveSpreadsheet();
      const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
      if (userSheet.getLastRow() > 1) {
        const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
        const userRow = data.find(row => row[5] === spreadsheetId); 
        if (userRow && userRow[12]) { 
          schoolCode = userRow[12];
        }
      }
    } catch (e) {
      Logger.log(`Tidak bisa mengambil Kode Sekolah untuk SS ID ${spreadsheetId}: ${e.message}`);
    }
    // --- AKHIR LOGIKA BARU ---

    const students = getStudents(spreadsheetId);
    const mapel = getMapel(spreadsheetId);
    const guru = getGuru(spreadsheetId); // <-- [PERUBAHAN] Tambahkan baris ini
    const schoolData = getSchoolData(spreadsheetId);
    const subjectAverages = getSubjectAverageScores(spreadsheetId);
    const examScoreShare = getExamScoreShare(spreadsheetId);
    const ijazahRanking = getIjazahRanking(spreadsheetId);

    let incompleteStudentsCount = 0;
    try {
        const validationResponse = validateAllScores(spreadsheetId);
        if (validationResponse.status === 'success' && validationResponse.data) {
            incompleteStudentsCount = validationResponse.data.filter(student => student.missingCount > 0).length;
        }
    } catch (e) {
        Logger.log(`Validasi di dashboard gagal: ${e.message}`);
    }

    return {
      status: "success",
      studentCount: students.length,
      mapelCount: mapel.length,
      guruCount: guru.length, // <-- [PERUBAHAN] Tambahkan baris ini
      schoolData: schoolData,
      mapelList: mapel,
      subjectAverages: subjectAverages,
      examScoreShare: examScoreShare,
      ijazahRanking: ijazahRanking,
      schoolCode: schoolCode,
      incompleteCount: incompleteStudentsCount
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengambil data dashboard: " + e.message };
  }
}

// [PERUBAHAN] Tambahkan fungsi baru ini
/**
 * Memperbarui data beberapa siswa sekaligus berdasarkan data dari file impor.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} studentsToUpdate Array objek siswa yang akan diupdate.
 * @returns {{status: string, message: string}} Status pembaruan.
 */
function batchUpdateStudents(spreadsheetId, studentsToUpdate) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    let updatedCount = 0;

    studentsToUpdate.forEach(studentData => {
      const rowToUpdate = [
        studentData.nisn, studentData.nis, studentData.nomorUjian, studentData.nama,
        studentData.jenisKelamin, toProperCase(studentData.tempatLahir),
        studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '',
        studentData.alamat, studentData.telepon, studentData.emailSiswa,
        studentData.tahunMasuk, studentData.tahunLulus, studentData.tampilkanTranskrip,
        studentData.kelas, studentData.ruangUjian
      ];

      const targetRange = sheet.getRange(studentData.studentRow, 1, 1, rowToUpdate.length);
      
      sheet.getRange(studentData.studentRow, 1, 1, 2).setNumberFormat('@'); // NISN, NIS
      sheet.getRange(studentData.studentRow, 8, 1, 1).setNumberFormat('@'); // Telepon di kolom H

      targetRange.setValues([rowToUpdate]);
      updatedCount++;
    });

    return { status: "success", message: `${updatedCount} data siswa berhasil diperbarui.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data siswa secara massal: " + e.message };
  }
}

// ===== [BARU] FUNGSI UNTUK MENGHAPUS SEMUA NILAI UJIAN =====
/**
 * Menghapus semua konten dari sheet Nilai Ujian Madrasah dan Praktek.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllUjianScores(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheetNames = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK];
    let clearedCount = 0;

    sheetNames.forEach(name => {
      const sheet = ss.getSheetByName(name);
      if (sheet && sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
        clearedCount++;
      }
    });

    if (clearedCount === 0) {
      return { status: "info", message: "Tidak ada data nilai ujian untuk dihapus." };
    }
    
    return { status: "success", message: "Semua data nilai Ujian Madrasah & Praktek telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data nilai ujian: " + e.message };
  }
}


// ===== [BARU] FUNGSI UNTUK MENGHAPUS SEMUA NILAI RAPOR PER SEMESTER =====
/**
 * Menghapus semua konten nilai rapor (Pengetahuan & Keterampilan) untuk semester tertentu.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} semesterKey Kunci semester, cth: 'k10_ganjil'.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllRaporScoresBySemester(spreadsheetId, semesterKey) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheetNames = [
      `Rapor_Pengetahuan_${semesterKey}`,
      `Rapor_Keterampilan_${semesterKey}`
    ];
    let clearedCount = 0;

    sheetNames.forEach(name => {
      const sheet = ss.getSheetByName(name);
      if (sheet && sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
        clearedCount++;
      }
    });
    
    if (clearedCount === 0) {
      return { status: "info", message: "Tidak ada data nilai rapor untuk semester ini yang bisa dihapus." };
    }

    return { status: "success", message: `Semua data nilai rapor untuk semester ini telah berhasil dihapus.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data rapor semester: " + e.message };
  }
}

/**
 * [BARU] Membandingkan dua objek data siswa untuk melihat apakah identik di semua kolom.
 * @param {object} studentA Objek data siswa pertama.
 * @param {object} studentB Objek data siswa kedua.
 * @returns {boolean} True jika identik, false jika ada perbedaan.
 */
function areStudentsIdentical(studentA, studentB) {
  // Daftar semua kunci yang ingin dibandingkan
  const keysToCompare = [
    'nisn', 'nis', 'nama', 'jenisKelamin', 'tempatLahir', 'tanggalLahir',
    'alamat', 'telepon', 'emailSiswa', 'tahunMasuk', 'tahunLulus'
  ];

  for (const key of keysToCompare) {
    // Menggunakan (objek[key] || '') untuk menangani nilai null/undefined sebagai string kosong
    // Ini memastikan perbandingan yang konsisten.
    const valueA = (studentA[key] || '').toString().trim();
    const valueB = (studentB[key] || '').toString().trim();

    // Khusus untuk tempat lahir, kita bandingkan dalam format Proper Case
    if (key === 'tempatLahir') {
      if (toProperCase(valueA) !== toProperCase(valueB)) {
        return false; // Jika berbeda, langsung kembalikan false
      }
    } else {
      if (valueA !== valueB) {
        return false; // Jika ada satu saja perbedaan, mereka tidak identik
      }
    }
  }

  // Jika loop selesai tanpa menemukan perbedaan, berarti mereka identik
  return true;
}

// =================================================================
// FUNGSI KHUSUS SUPERADMIN
// =================================================================

// File: Kode.gs

/**
 * [STANDAR KEAMANAN] Memverifikasi apakah email yang diberikan memiliki peran Superadmin.
 * @param {string} email Email pengguna yang akan diperiksa.
 * @returns {boolean} True jika Superadmin, false jika bukan.
 */
function isSuperadmin(email) {
  if (!email) { 
    return false;
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // Gunakan konstanta yang sudah ada
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA); 
    if (!userSheet || userSheet.getLastRow() < 2) return false;

    // Ambil data dari kolom B (email) dan kolom G (role)
    const emailColumn = userSheet.getRange("B2:B").getValues().flat();
    const roleColumn = userSheet.getRange("G2:G").getValues().flat();
    
    // Cari indeks baris berdasarkan email
    const userIndex = emailColumn.findIndex(sheetEmail => sheetEmail && sheetEmail.toLowerCase() === email.toLowerCase());
    
    // Jika email ditemukan, cek perannya di indeks yang sama
    if (userIndex !== -1) {
      return roleColumn[userIndex] === 'Superadmin';
    }
    
    return false; // Jika email tidak ditemukan
  } catch (e) {
    Logger.log("Error in isSuperadmin: " + e.message);
    return false;
  }
}

/**
 * [SUPERADMIN - VERSI SUPER CEPAT] Mengambil data pengguna dari PropertiesService, 
 * dengan fallback ke sheet cache jika perlu.
 */
function getAllUsers_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }

  const scriptProperties = PropertiesService.getScriptProperties();
  const cachedJson = scriptProperties.getProperty('userManagementCache');

  let dataToMap;

  if (cachedJson) {
    dataToMap = JSON.parse(cachedJson);
  } else {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_CACHE_AKUN);
    if (!sheet || sheet.getLastRow() < 2) {
        return [];
    }
    // --- PERBAIKAN: BACA HINGGA KOLOM KE-10 ---
    const sheetData = sheet.getRange(2, 1, sheet.getLastRow() - 1, 10).getValues();
    dataToMap = sheetData.filter(row => row[0] && row[0] !== 'last_updated');
  }

  return dataToMap.map((row) => {
    return {
      email: row[0],
      namaSekolah: row[1],
      jenjang: row[2],
      schoolCode: row[3],
      status: row[4],
      studentLimit: row[5],
      currentStudentCount: row[6],
      row: row[7],
      role: row[8],
      // --- PERBAIKAN: Baca dari indeks 9 (kolom ke-10) ---
      fiturTerkunci: row[9] || 'TIDAK' 
    };
  });
}

/**
 * [SUPERADMIN] Memperbarui data pengguna (Nama Sekolah & Jenjang) oleh Superadmin.
 * @param {string} adminEmail Email superadmin yang melakukan aksi.
 * @param {object} userData Objek berisi data yang akan diupdate {row, namaSekolah, jenjang}.
 * @returns {{status: string, message: string}} Hasil proses.
 */
function updateUserBySuperadmin(adminEmail, userData) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    
    // Update Nama Sekolah (Kolom D) dan Jenjang (Kolom E) di sheet Data Pengguna
    userSheet.getRange(userData.row, 4).setValue(userData.namaSekolah);
    userSheet.getRange(userData.row, 5).setValue(userData.jenjang);

    // Update juga di dalam spreadsheet sekolah yang bersangkutan
    const schoolSsId = userSheet.getRange(userData.row, 6).getValue();
    const schoolSs = SpreadsheetApp.openById(schoolSsId);
    const dataSekolahSheet = schoolSs.getSheetByName(SHEET_DATA_SEKOLAH);
    if (dataSekolahSheet) {
      dataSekolahSheet.getRange(2, 1).setValue(userData.jenjang); // Jenjang di A2
      dataSekolahSheet.getRange(2, 2).setValue(userData.namaSekolah); // Nama Sekolah di B2
    }

    return { status: "success", message: `Data untuk akun ${userData.email} berhasil diperbarui.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data: " + e.message };
  }
}

/**
 * [SUPERADMIN] Mengubah status akun pengguna (Aktif/Nonaktif).
 * @param {string} adminEmail Email superadmin yang melakukan aksi.
 * @param {number} rowNomor Nomor baris pengguna yang akan diubah.
 * @param {string} newStatus Status baru ('Aktif' atau 'Nonaktif').
 * @returns {{status: string, message: string}} Hasil proses.
 */
function setUserStatus_Superadmin(adminEmail, rowNumber, newStatus) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    // Kolom Status adalah kolom ke-8 (H)
    userSheet.getRange(rowNumber, 8).setValue(newStatus); 
    return { status: "success", message: `Status akun berhasil diubah menjadi ${newStatus}.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengubah status: " + e.message };
  }
}

/**
 * [SUPERADMIN - VERSI CEPAT DENGAN PROPERTIES SERVICE] Mengambil data statistik dari cache.
 * @param {string} adminEmail - Email superadmin untuk verifikasi.
 * @returns {object} Objek berisi data statistik.
 */
function getSuperadminDashboardData(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }

  try {
    const scriptProperties = PropertiesService.getScriptProperties();
    const cachedJson = scriptProperties.getProperty('superadminDashboardCache');

    if (cachedJson) {
      // JALUR CEPAT: Data ditemukan di PropertiesService, langsung kirim
      const cachedStats = JSON.parse(cachedJson);
      return { status: 'success', ...cachedStats };
    } else {
      // JALUR LAMBAT (HANYA UNTUK PERTAMA KALI): Jika cache belum ada, beri pesan
      // Trigger otomatis atau klik manual pertama akan membuat cache ini.
      return {
        status: "success",
        totalAccounts: 0, activeAccounts: 0, inactiveAccounts: 0,
        totalStudents: 0, totalRequests: 0, pendingRequests: 0,
        approvedRequests: 0, rejectedRequests: 0,
        lastUpdated: "Belum pernah"
      };
    }
  } catch (e) {
    Logger.log("Error saat membaca cache dashboard dari PropertiesService: " + e.message);
    return { status: "error", message: "Gagal membaca cache: " + e.message };
  }
}

/**
 * [SUPERADMIN] Memicu pembaruan cache akun pengguna secara manual.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {object} Hasil operasi.
 */
function updateUserCache_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    runUserCacheUpdateTrigger(); // Panggil fungsi inti
    return { status: 'success', message: 'Pembaruan cache akun telah dimulai dan akan segera selesai.' };
  } catch(e) {
    Logger.log("updateUserCache_Superadmin (manual) Error: " + e.message);
    return { status: 'error', message: 'Gagal memulai pembaruan cache: ' + e.message };
  }
}

// ===== TAMBAHKAN FUNGSI BARU INI DI Kode.gs =====

/**
 * [SUPERADMIN] Mengambil waktu terakhir cache akun diperbarui.
 * @returns {object} Objek berisi status dan timestamp dalam format ISO string.
 */
function getUserCacheLastUpdated_Superadmin() {
  try {
    const cacheSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_CACHE_AKUN);
    if (!cacheSheet || cacheSheet.getLastRow() < 2) {
      return { status: 'success', lastUpdated: null };
    }

    const data = cacheSheet.getDataRange().getValues();
    // Cari dari bawah ke atas untuk efisiensi
    for (let i = data.length - 1; i >= 1; i--) {
      if (data[i][0] === 'last_updated') {
        return { status: 'success', lastUpdated: data[i][1] };
      }
    }

    return { status: 'success', lastUpdated: null }; // Tidak ditemukan
  } catch(e) {
    return { status: 'error', message: e.message };
  }
}
// ===== AKHIR KODE BARU (Fungsi Update Cache) =====

/**
 * [BARU] Menjalankan pembaruan cache, lalu langsung memanggil getSuperadminDashboardData
 * untuk mengembalikan data yang paling fresh ke UI.
 * @param {string} adminEmail - Email superadmin untuk verifikasi.
 */
function forceDashboardCacheUpdate_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    // 1. Jalankan proses update yang lambat
    updateSuperadminDashboardCache();
    
    // 2. Setelah selesai, panggil fungsi pembaca data yang cepat untuk mendapatkan hasil terbaru
    const freshData = getSuperadminDashboardData(adminEmail);
    
    // 3. Kembalikan data terbaru ini ke frontend
    return { 
      status: 'success', 
      message: 'Data dashboard berhasil diperbarui!',
      dashboardData: freshData // <-- Kita sertakan data baru di sini
    };

  } catch (e) {
    Logger.log('Gagal force update cache: ' + e.message);
    return { status: "error", message: 'Gagal memperbarui data: ' + e.message };
  }
}

/**
 * Helper function untuk memeriksa apakah pengguna telah mencapai batas siswa.
 * @param {string} spreadsheetId ID spreadsheet pengguna.
 * @param {string} userEmail Email pengguna yang akan diperiksa.
 * @returns {{limitReached: boolean, message: string}} Objek berisi status batas.
 */
function checkStudentLimit(spreadsheetId, userEmail) {
  try {
    // Dapatkan batas siswa dari sheet Data Pengguna
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    const userRow = usersData.find(row => row[1].toLowerCase() === userEmail.toLowerCase());
    
    if (!userRow) {
      return { limitReached: true, message: "Data pengguna tidak ditemukan." };
    }
    const studentLimit = parseInt(userRow[8]); // Kolom I adalah student limit

    if (isNaN(studentLimit)) {
      // Jika batas tidak diatur, anggap tidak ada batas (untuk keamanan)
      return { limitReached: false, message: "" };
    }

    // Dapatkan jumlah siswa saat ini
    const studentSs = SpreadsheetApp.openById(spreadsheetId);
    const studentSheet = studentSs.getSheetByName(SHEET_DATA_SISWA);
    const currentStudentCount = studentSheet ? studentSheet.getLastRow() - 1 : 0;

    if (currentStudentCount >= studentLimit) {
      return { limitReached: true, message: `Batas jumlah siswa tercapai (${currentStudentCount}/${studentLimit}). Anda tidak dapat menambahkan siswa baru. Hubungi admin untuk menaikkan batas.` };
    }

    return { limitReached: false, message: "" };

  } catch (e) {
    Logger.log(`Error di checkStudentLimit: ${e.message}`);
    return { limitReached: true, message: "Terjadi kesalahan saat memeriksa batas siswa." };
  }
}

/**
 * [SUPERADMIN] Mengatur batas jumlah siswa untuk akun tertentu.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {number} rowNumber Nomor baris pengguna yang akan diubah.
 * @param {number} newLimit Batas baru yang akan ditetapkan.
 * @returns {object} Hasil proses.
 */
function setStudentLimit_Superadmin(adminEmail, rowNumber, newLimit) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const limit = parseInt(newLimit);
    if (isNaN(limit) || limit < 0) {
      return { status: "error", message: "Batas siswa harus berupa angka positif." };
    }
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    userSheet.getRange(rowNumber, 9).setValue(limit); // Kolom I adalah Student Limit
    return { status: "success", message: "Batas siswa berhasil diperbarui." };
  } catch (e) {
    return { status: "error", message: "Gagal memperbarui batas: " + e.message };
  }
}

/**
 * [SUPERADMIN] Mengatur dan mengambil batas default siswa untuk pendaftaran baru.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {number} [newLimit] Batas default baru (opsional). Jika tidak diberikan, fungsi hanya akan mengambil nilai saat ini.
 * @returns {object} Hasil proses atau nilai saat ini.
 */
function manageDefaultStudentLimit_Superadmin(adminEmail, newLimit) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const configSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Konfigurasi Sistem');
    if (!configSheet) {
      return { status: "error", message: "Sheet 'Konfigurasi Sistem' tidak ditemukan." };
    }
    const limitCell = configSheet.getRange("B2");

    if (newLimit !== undefined && newLimit !== null) {
      // Mode: Mengatur nilai baru
      const limit = parseInt(newLimit);
      if (isNaN(limit) || limit < 0) {
        return { status: "error", message: "Batas default harus berupa angka positif." };
      }
      limitCell.setValue(limit);
      return { status: "success", message: `Batas default siswa berhasil diubah menjadi ${limit}.`, currentLimit: limit };
    } else {
      // Mode: Mengambil nilai saat ini
      const currentLimit = limitCell.getValue();
      return { status: "success", currentLimit: currentLimit };
    }
  } catch (e) {
    return { status: "error", message: "Gagal mengelola batas default: " + e.message };
  }
}

/**
 * [BARU] Mengambil informasi kuota siswa untuk pengguna yang sedang login.
 * @param {string} userEmail Email pengguna.
 * @returns {object} Objek berisi info kuota: {status, totalLimit, usedCount, remaining}.
 */
function getStudentQuotaInfo(userEmail) {
  if (!userEmail) {
    return { status: "error", message: "Email pengguna tidak diberikan." };
  }

  try {
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    const userRow = usersData.find(row => row[1] && row[1].toLowerCase() === userEmail.toLowerCase());

    if (!userRow) {
      return { status: "error", message: "Data pengguna tidak ditemukan." };
    }

    const role = userRow[6];
    if (role === 'Superadmin') {
        // Superadmin tidak memiliki kuota siswa
        return { status: "success", totalLimit: 'Tak Terbatas', usedCount: '-', remaining: '-' };
    }

    const spreadsheetId = userRow[5];
    const studentLimit = parseInt(userRow[8]);

    if (!spreadsheetId) {
        return { status: "error", message: "Spreadsheet ID tidak ditemukan untuk pengguna ini." };
    }

    // Jika batas tidak diatur atau bukan angka, anggap tak terbatas
    if (isNaN(studentLimit)) {
      const studentSheet = SpreadsheetApp.openById(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
      const usedCount = studentSheet ? Math.max(0, studentSheet.getLastRow() - 1) : 0;
      return { status: "success", totalLimit: 'Tak Terbatas', usedCount: usedCount, remaining: '-' };
    }

    const studentSs = SpreadsheetApp.openById(spreadsheetId);
    const studentSheet = studentSs.getSheetByName(SHEET_DATA_SISWA);
    const usedCount = studentSheet ? Math.max(0, studentSheet.getLastRow() - 1) : 0;
    
    const remaining = studentLimit - usedCount;

    return {
      status: "success",
      totalLimit: studentLimit,
      usedCount: usedCount,
      remaining: remaining
    };

  } catch (e) {
    Logger.log(`Error di getStudentQuotaInfo untuk ${userEmail}: ${e.message}`);
    return { status: "error", message: "Gagal mengambil informasi kuota." };
  }
}

// =================================================================
// [BARU] FUNGSI PENGAJUAN PERUBAHAN DATA
// =================================================================

/**
 * [BARU & DIPERBAIKI] Mengajukan permintaan perubahan data sekolah oleh pengguna.
 * @param {string} userEmail Email pengguna yang mengajukan.
 * @param {object} newData Objek berisi data baru { jenjang, namaSekolah }.
 * @returns {{status: string, message: string}} Hasil dari pengajuan.
 */
function submitChangeRequest(userEmail, newData) {
  try {
    const { newJenjang, newNamaSekolah } = newData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);

    // Jika sheet belum ada, buat baru dengan header.
    if (!pengajuanSheet) {
      pengajuanSheet = ss.insertSheet(SHEET_PENGAJUAN);
      pengajuanSheet.appendRow([
        "Request ID", "User Email", "Jenjang Lama", "Nama Sekolah Lama", 
        "Jenjang Baru", "Nama Sekolah Baru", "Tanggal Ajuan", "Status", 
        "Catatan Admin", "Tanggal Diproses"
      ]);
    }

    // Cek apakah ada pengajuan yang masih menunggu dari pengguna yang sama.
    if (pengajuanSheet.getLastRow() > 1) {
        const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
        const pendingRequest = data.find(row => row[1] === userEmail && row[7] === 'Menunggu Persetujuan');
        if (pendingRequest) {
            return { status: "error", message: "Anda sudah memiliki pengajuan yang sedang diproses. Harap tunggu hingga admin meninjaunya." };
        }
    }
    
    // Dapatkan data sekolah saat ini untuk disimpan sebagai 'data lama'.
    const userRow = findUserRowByEmail(userEmail);
    if (!userRow) {
        return { status: "error", message: "Data pengguna tidak ditemukan." };
    }
    const oldJenjang = userRow[4]; // Kolom E
    const oldNamaSekolah = userRow[3]; // Kolom D

    if (!newJenjang && !newNamaSekolah) {
       return { status: "error", message: "Tidak ada data baru yang diajukan untuk diubah." };
    }

    const requestId = Utilities.getUuid();
    const requestDate = new Date();
    
    pengajuanSheet.appendRow([
      requestId,
      userEmail,
      oldJenjang,
      oldNamaSekolah,
      newJenjang || oldJenjang, // Jika tidak diubah, pakai data lama
      newNamaSekolah || oldNamaSekolah, // Jika tidak diubah, pakai data lama
      requestDate,
      'Menunggu Persetujuan', // Status awal
      '', // Catatan Admin kosong
      '',  // Tanggal diproses kosong
      'Proses' // <-- [TAMBAHAN BARU] Kolom K: Status Dibaca
    ]);

    // --- AWAL KODE NOTIFIKASI EMAIL SUPERADMIN ---
    try {
      const superadminEmail = "syamsulbahri.agro27b@gmail.com"; // GANTI DENGAN EMAIL SUPERADMIN ANDA
      const subject = "[Aplikasi Ijazah] Pengajuan Perubahan Data Baru";
      const body = `
        <p>Halo Superadmin,</p>
        <p>Ada pengajuan perubahan data baru yang masuk dari pengguna:</p>
        <ul>
          <li><b>Email Pengguna:</b> ${userEmail}</li>
          <li><b>Nama Sekolah:</b> ${oldNamaSekolah}</li>
          <li><b>Tanggal Ajuan:</b> ${requestDate.toLocaleString('id-ID')}</li>
        </ul>
        <p>Data yang diajukan untuk diubah:</p>
        <ul>
          <li><b>Jenjang Baru:</b> ${newJenjang || '(tidak diubah)'}</li>
          <li><b>Nama Sekolah Baru:</b> ${newNamaSekolah || '(tidak diubah)'}</li>
        </ul>
        <p>Silakan masuk ke panel Superadmin untuk meninjau dan memproses pengajuan ini.</p>
        <br>
        <p>Terima kasih.</p>
      `;
      MailApp.sendEmail(superadminEmail, subject, "", { htmlBody: body });
    } catch (e) {
      Logger.log("Gagal mengirim notifikasi email pengajuan ke Superadmin: " + e.message);
    }
    // --- AKHIR KODE NOTIFIKASI EMAIL SUPERADMIN ---

    // !! PENTING: TAMBAHKAN BARIS INI !!
    // Memaksa Google untuk menyelesaikan semua operasi penulisan sebelum melanjutkan.
    SpreadsheetApp.flush(); 

    return { status: "success", message: "Pengajuan perubahan data berhasil dikirim dan sedang menunggu persetujuan admin." };

  } catch (e) {
    Logger.log(`submitChangeRequest Error: ${e.toString()}`);
    return { status: "error", message: "Gagal mengirim pengajuan: " + e.message };
  }
}

/**
 * [BARU] Mengambil status pengajuan terakhir dari seorang pengguna.
 * @param {string} userEmail Email pengguna.
 * @returns {object|null} Objek berisi detail pengajuan terakhir atau null jika tidak ada.
 */
function getChangeRequestStatus(userEmail) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!pengajuanSheet || pengajuanSheet.getLastRow() < 2) {
      return null;
    }

    const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
    // Cari dari bawah ke atas untuk mendapatkan data terbaru
    for (let i = data.length - 1; i >= 0; i--) {
      if (data[i][1] === userEmail) {
        // Ditemukan ajuan terakhir dari pengguna ini
        return {
          requestId: data[i][0],
          userEmail: data[i][1],
          oldJenjang: data[i][2],
          oldNamaSekolah: data[i][3],
          newJenjang: data[i][4],
          newNamaSekolah: data[i][5],
          requestDate: data[i][6],
          status: data[i][7],
          adminNotes: data[i][8],
          resolvedDate: data[i][9]
        };
      }
    }
    return null; // Tidak ada ajuan dari pengguna ini
  } catch (e) {
    Logger.log(`getChangeRequestStatus Error: ${e.toString()}`);
    return null;
  }
}

/**
 * [BARU] Helper function untuk mencari baris pengguna berdasarkan email.
 * @param {string} email Email pengguna.
 * @returns {Array|null} Array data baris pengguna atau null.
 */
function findUserRowByEmail(email) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet || userSheet.getLastRow() < 2) return null;
    const users = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    return users.find(userRow => userRow[1].toLowerCase() === email.toLowerCase());
}

/**
 * [SUPERADMIN] Mengambil semua data pengajuan perubahan data.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek data pengajuan.
 */
function getChangeRequests_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!sheet || sheet.getLastRow() < 2) {
      return [];
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    
    const requests = data.map(row => ({
      requestId: row[0],
      userEmail: row[1],
      oldJenjang: row[2],
      oldNamaSekolah: row[3],
      newJenjang: row[4],
      newNamaSekolah: row[5],
      requestDate: row[6] instanceof Date ? row[6].toISOString() : new Date().toISOString(),
      status: row[7],
      adminNotes: row[8] || '' // <-- [PERBAIKAN] Ambil juga data catatan admin
    })).filter(req => req.requestId);

    requests.sort((a, b) => {
        if (a.status === 'Menunggu Persetujuan' && b.status !== 'Menunggu Persetujuan') return -1;
        if (a.status !== 'Menunggu Persetujuan' && b.status === 'Menunggu Persetujuan') return 1;
        return new Date(b.requestDate).getTime() - new Date(a.requestDate).getTime();
    });

    return requests;

  } catch (e) {
    Logger.log("getChangeRequests_Superadmin Error: " + e.message);
    return [];
  }
}


/**
 * [SUPERADMIN] Memproses (menyetujui/menolak) pengajuan perubahan data.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {string} requestId ID dari pengajuan yang akan diproses.
 * @param {string} resolution Keputusan ('Disetujui' atau 'Ditolak').
 * @param {string} adminNotes Catatan dari admin (khusus jika ditolak).
 * @returns {{status: string, message: string}} Hasil proses.
 */
function resolveChangeRequest_Superadmin(adminEmail, requestId, resolution, adminNotes) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Kunci proses untuk menghindari double-processing

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    const dataRange = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn());
    const data = dataRange.getValues();

    const requestIndex = data.findIndex(row => row[0] === requestId);

    if (requestIndex === -1) {
      return { status: "error", message: "Pengajuan tidak ditemukan." };
    }
    
    const requestRow = data[requestIndex];
    if (requestRow[7] !== 'Menunggu Persetujuan') {
      return { status: "error", message: "Pengajuan ini sudah pernah diproses." };
    }

    const userEmail = requestRow[1];
    const newJenjang = requestRow[4];
    const newNamaSekolah = requestRow[5];

    // Jika disetujui, lakukan perubahan data.
    if (resolution === 'Disetujui') {
      const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
      const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
      const userIndex = usersData.findIndex(row => row[1] === userEmail);
      
      if (userIndex !== -1) {
        const userRowNumber = userIndex + 2;
        
        // 1. Update di sheet Data Pengguna
        userSheet.getRange(userRowNumber, 4).setValue(newNamaSekolah); // Kolom D
        userSheet.getRange(userRowNumber, 5).setValue(newJenjang);    // Kolom E
        
        // 2. Update di spreadsheet sekolah yang bersangkutan
        const schoolSsId = usersData[userIndex][5]; // Kolom F
        if (schoolSsId) {
            const schoolSs = SpreadsheetApp.openById(schoolSsId);
            const dataSekolahSheet = schoolSs.getSheetByName(SHEET_DATA_SEKOLAH);
            if (dataSekolahSheet) {
              dataSekolahSheet.getRange("A2").setValue(newJenjang);
              dataSekolahSheet.getRange("B2").setValue(newNamaSekolah);
            }
        }
      } else {
         throw new Error(`Pengguna dengan email ${userEmail} tidak ditemukan di Data Pengguna.`);
      }
    }

    // Update status di sheet Data Pengajuan
    const targetRowInSheet = requestIndex + 2;
    pengajuanSheet.getRange(targetRowInSheet, 8).setValue(resolution); // Status
    pengajuanSheet.getRange(targetRowInSheet, 9).setValue(adminNotes); // Catatan Admin
    pengajuanSheet.getRange(targetRowInSheet, 10).setValue(new Date()); // Tanggal Diproses
    pengajuanSheet.getRange(targetRowInSheet, 11).setValue('Belum Dibaca'); // Set Status Dibaca

    // --- AWAL KODE NOTIFIKASI EMAIL PENGGUNA ---
    try {
      const subject = `[Aplikasi Ijazah] Status Pengajuan Anda Telah Diperbarui: ${resolution}`;
      let body = `
        <p>Halo,</p>
        <p>Pengajuan perubahan data yang Anda kirim pada tanggal ${requestRow[6].toLocaleString('id-ID')} telah diproses oleh admin.</p>
        <p><b>Status baru: ${resolution}</b></p>
      `;
      if (resolution === 'Disetujui') {
        body += "<p>Perubahan data pada akun Anda telah berhasil diterapkan. Silakan periksa kembali data sekolah Anda di aplikasi.</p>";
      } else if (resolution === 'Ditolak' && adminNotes) {
        body += `<p><b>Alasan Penolakan:</b> ${adminNotes}</p><p>Anda dapat mengajukan perubahan data kembali melalui aplikasi jika diperlukan.</p>`;
      }
      body += "<br><p>Terima kasih.</p>";
      
      MailApp.sendEmail(userEmail, subject, "", { htmlBody: body });
    } catch (e) {
      Logger.log(`Gagal mengirim notifikasi email status pengajuan ke pengguna ${userEmail}: ${e.message}`);
    }
    // --- AKHIR KODE NOTIFIKASI EMAIL PENGGUNA ---

    return { status: 'success', message: `Pengajuan berhasil ${resolution.toLowerCase()}.` };

  } catch (e) {
    Logger.log("resolveChangeRequest_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memproses pengajuan: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN] Menghitung jumlah pengajuan yang berstatus "Menunggu Persetujuan".
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @returns {{status: string, count: number}} Objek berisi status dan jumlah hitungan.
 */
function getPendingRequestCount_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    // Sebaiknya tidak melempar error agar tidak mengganggu UI jika terjadi masalah sesi
    return { status: "error", count: 0 }; 
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!sheet || sheet.getLastRow() < 2) {
      return { status: "success", count: 0 };
    }

    // Ambil hanya kolom status (kolom H, indeks 7) untuk efisiensi
    const statusColumn = sheet.getRange(2, 8, sheet.getLastRow() - 1, 1).getValues();
    
    // Hitung yang statusnya "Menunggu Persetujuan"
    const pendingCount = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
    
    return { status: "success", count: pendingCount };

  } catch (e) {
    Logger.log("getPendingRequestCount_Superadmin Error: " + e.message);
    return { status: "error", count: 0 };
  }
}

/**
 * [BARU] Mengambil SEMUA riwayat pengajuan perubahan data untuk seorang pengguna.
 * @param {string} userEmail Email pengguna.
 * @returns {Array<object>} Array berisi semua objek pengajuan, diurutkan dari terbaru.
 */
function getChangeRequestHistory_User(userEmail) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!pengajuanSheet || pengajuanSheet.getLastRow() < 2) {
      return []; // Kembalikan array kosong jika tidak ada data
    }

    const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
    
    // 1. Filter untuk mendapatkan semua baris milik pengguna ini
    const userRequests = data.filter(row => row[1] === userEmail);

    // 2. Ubah menjadi objek dan urutkan dari yang terbaru
    const history = userRequests.map(row => ({
        requestId: row[0],
        requestDate: row[6] instanceof Date ? row[6].toISOString() : new Date().toISOString(),
        oldJenjang: row[2],
        oldNamaSekolah: row[3],
        newJenjang: row[4],
        newNamaSekolah: row[5],
        status: row[7],
        adminNotes: row[8],
        statusBaca: row[10] || 'Proses' // <-- [TAMBAHAN BARU] Ambil data dari kolom K (indeks 10)
    })).sort((a, b) => new Date(b.requestDate).getTime() - new Date(a.requestDate).getTime());

    return history;

  } catch (e) {
    Logger.log(`getChangeRequestHistory_User Error: ${e.toString()}`);
    return []; // Kembalikan array kosong jika terjadi error
  }
}

/**
 * [VERSI FINAL - DIPERBAIKI] Menandai pengajuan sebagai "Sudah Dibaca" oleh pengguna.
 * @param {string} requestId - ID dari pengajuan yang akan ditandai.
 * @param {string} userEmailFromClient - Email pengguna yang sedang login, dikirim dari frontend.
 * @returns {object} Hasil operasi.
 */
function markRequestAsRead_User(requestId, userEmailFromClient) {
  try {
    // Validasi: Pastikan email dari frontend tidak kosong
    if (!userEmailFromClient) {
      throw new Error("Email pengguna tidak disertakan dalam permintaan.");
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!sheet || sheet.getLastRow() < 2) {
      return { status: 'error', message: 'Sheet pengajuan tidak ditemukan.' };
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 11).getValues();
    
    // Logika pencarian yang diperbaiki: Membandingkan dengan email yang dikirim dari klien
    const requestIndex = data.findIndex(row => 
      row[0] === requestId && row[1].toLowerCase() === userEmailFromClient.toLowerCase()
    );

    if (requestIndex !== -1) {
      const rowToUpdate = requestIndex + 2;
      // Kolom K adalah kolom ke-11
      sheet.getRange(rowToUpdate, 11).setValue('Sudah Dibaca');
      return { status: 'success', message: 'Berhasil ditandai sebagai sudah dibaca.' };
    }
    
    // Jika tidak ditemukan, log untuk debugging
    Logger.log(`Gagal menandai dibaca. RequestId: ${requestId}. Email dari Klien: ${userEmailFromClient}. Tidak ada baris yang cocok.`);
    return { status: 'error', message: 'Pengajuan tidak ditemukan atau bukan milik Anda.' };

  } catch (e) {
    Logger.log(`markRequestAsRead_User Error: ${e.stack}`);
    return { status: 'error', message: `Gagal menandai pengajuan: ${e.message}` };
  }
}

// =================================================================
// FUNGSI BACKUP & RESTORE (SISTEM KODE UNIK)
// =================================================================

/**
 * [BARU] Mencari atau membuat folder backup yang spesifik untuk pengguna di dalam folder induk spreadsheet mereka.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @returns {DriveApp.Folder} Objek folder backup.
 */
function getOrCreateUserBackupFolder(spreadsheetId) {
  try {
    const userSpreadsheetFile = DriveApp.getFileById(spreadsheetId);
    // Asumsi spreadsheet pengguna berada di dalam satu folder induk
    const parentFolder = userSpreadsheetFile.getParents().next(); 
    
    // Nama folder backup yang lebih rapi
    const backupFolderName = `_Backup Aplikasi Ijazah`; 
    let backupFolderIterator = parentFolder.getFoldersByName(backupFolderName);

    if (backupFolderIterator.hasNext()) {
      return backupFolderIterator.next();
    } else {
      return parentFolder.createFolder(backupFolderName);
    }
  } catch (e) {
    // Jika gagal mendapatkan folder induk, buat di root Drive pengguna sebagai fallback
    Logger.log(`Tidak dapat menemukan folder induk untuk SS ID: ${spreadsheetId}. Membuat folder backup di Root Drive. Error: ${e.message}`);
    const rootFolder = DriveApp.getRootFolder();
    const fallbackFolderName = `BACKUP APLIKASI IJAZAH (ID: ${spreadsheetId.slice(0,8)})`;
    let fallbackFolderIterator = rootFolder.getFoldersByName(fallbackFolderName);
     if (fallbackFolderIterator.hasNext()) {
      return fallbackFolderIterator.next();
    } else {
      return rootFolder.createFolder(fallbackFolderName);
    }
  }
}

/**
 * [BARU] Membuat backup, menghasilkan kode unik, dan mencatatnya di registry.
 * @param {string} spreadsheetId ID spreadsheet pengguna yang akan dibackup.
 * @param {string} userEmail Email pengguna yang membuat backup.
 * @returns {object} Hasil operasi berisi status, pesan, dan kode unik.
 */
function createBackupWithCode(spreadsheetId, userEmail) {
  try {
    const liveFile = DriveApp.getFileById(spreadsheetId);
    const backupFolder = getOrCreateUserBackupFolder(spreadsheetId);
    
    const now = new Date();
    const timestamp = Utilities.formatDate(now, Session.getScriptTimeZone(), "yyyy-MM-dd_HH-mm");
    const schoolData = getSchoolData(spreadsheetId); // Menggunakan fungsi yang ada untuk mendapatkan nama sekolah
    const schoolName = schoolData ? schoolData.namaSekolah : "Unknown_School";

    // 1. Buat file backup
    const backupFileName = `[${timestamp}] Backup - ${schoolName}`;
    const backupFile = liveFile.makeCopy(backupFileName, backupFolder);
    const backupFileId = backupFile.getId();

    // 2. Buat kode restore yang unik dan mudah dibaca
    const uniqueCode = Utilities.getUuid().substring(0, 4).toUpperCase() + '-' + Utilities.getUuid().substring(9, 13).toUpperCase();

    // 3. Simpan catatan di Spreadsheet Induk
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    let registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);

    // Buat sheet jika belum ada
    if (!registrySheet) {
      registrySheet = masterSs.insertSheet(SHEET_BACKUP_REGISTRY);
      const headers = ['Kode Restore', 'ID File Backup', 'Dibuat Oleh (Email)', 'Tanggal Dibuat', 'Nama Sekolah', 'Nama File'];
      registrySheet.appendRow(headers);
      registrySheet.getRange("A1:F1").setFontWeight("bold");
      registrySheet.setFrozenRows(1);
    }

    // Tambahkan data backup baru
    registrySheet.appendRow([uniqueCode, backupFileId, userEmail, now, schoolName, backupFileName]);
    
    return { 
      status: "success", 
      message: `Backup berhasil dibuat. Kode restore Anda adalah: ${uniqueCode}`,
      code: uniqueCode,
      backupName: backupFileName
    };

  } catch (e) {
    Logger.log(`createBackupWithCode Error: ${e.stack}`);
    return { status: "error", message: `Gagal membuat backup: ${e.message}` };
  }
}

/**
 * [VERSI FINAL - DIPERBAIKI] Mengambil daftar semua backup yang dibuat oleh pengguna tertentu.
 * Memastikan data tanggal diubah menjadi string sebelum dikirim ke frontend.
 * @param {string} userEmail Email pengguna yang sedang login.
 * @returns {object} Hasil operasi berisi daftar file backup.
 */
function getBackupListForUser(userEmail) {
  try {
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);

    if (!registrySheet || registrySheet.getLastRow() < 2) {
      return { status: "success", backups: [] };
    }

    const data = registrySheet.getDataRange().getValues();
    const headers = data.shift();
    const emailIndex = headers.indexOf('Dibuat Oleh (Email)');

    // Pengecekan header untuk menghindari error
    if (emailIndex === -1) {
      throw new Error("Kolom 'Dibuat Oleh (Email)' tidak ditemukan di sheet 'Data Backup Terdaftar'.");
    }
    
    const userBackups = data
      .filter(row => row[emailIndex] && row[emailIndex].toLowerCase() === userEmail.toLowerCase())
      .map(row => {
        const tglDibuat = row[headers.indexOf('Tanggal Dibuat')];

        return {
          code: row[headers.indexOf('Kode Restore')],
          id: row[headers.indexOf('ID File Backup')],
          // ▼▼▼ PERBAIKAN UTAMA ADA DI SINI ▼▼▼
          // Mengubah objek Date menjadi string ISO, yang aman untuk dikirim ke frontend.
          date: tglDibuat instanceof Date ? tglDibuat.toISOString() : tglDibuat,
          // ▲▲▲ AKHIR PERBAIKAN ▲▲▲
          name: row[headers.indexOf('Nama File')] || `Backup dari tanggal tidak diketahui`
        };
      })
      .sort((a, b) => new Date(b.date) - new Date(a.date));

    return { status: "success", backups: userBackups };

  } catch (e) {
    Logger.log(`getBackupListForUser Error: ${e.stack}`);
    return { status: "error", message: `Gagal mengambil daftar backup: ${e.message}` };
  }
}

/**
 * [BARU] Memulihkan data dari backup menggunakan kode unik, dengan validasi kepemilikan.
 * Ini memicu proses di latar belakang.
 * @param {string} liveSpreadsheetId ID spreadsheet yang akan ditimpa.
 * @param {string} uniqueCode Kode restore yang dimasukkan pengguna.
 * @param {string} userEmail Email pengguna yang meminta restore (untuk verifikasi).
 */
function restoreFromCode(liveSpreadsheetId, uniqueCode, userEmail) {
  const cache = CacheService.getScriptCache();
  const statusKey = `restore_status_${userEmail}_${liveSpreadsheetId}`;

  // Segera set status 'running' di cache
  cache.put(statusKey, 'running', 21600); // Simpan status selama 6 jam

  try {
    if (!uniqueCode || !userEmail) {
      throw new Error("Kode restore dan email pengguna wajib diisi.");
    }
    
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    // 1. Cari kode di Spreadsheet Induk
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);
    if (!registrySheet) {
      throw new Error("Sistem registry backup tidak ditemukan. Hubungi Superadmin.");
    }

    const data = registrySheet.getRange(2, 1, registrySheet.getLastRow() - 1, 4).getValues();
    let backupFileId = null;
    let found = false;

    for (let i = 0; i < data.length; i++) {
      // Bandingkan kode (kolom 0) dan email (kolom 2)
      if (data[i][0].toString().toUpperCase() === uniqueCode.toUpperCase()) {
        if (data[i][2].toLowerCase() === userEmail.toLowerCase()) {
          backupFileId = data[i][1];
          found = true;
          break;
        } else {
          // Kode ditemukan, tapi bukan milik pengguna ini
          throw new Error("Akses ditolak. Kode restore ini milik pengguna lain.");
        }
      }
    }
    
    lock.releaseLock();
    
    if (!found) {
      throw new Error(`Kode restore '${uniqueCode}' tidak valid atau tidak ditemukan.`);
    }

    // 2. Jalankan proses restore inti
    const liveSs = SpreadsheetApp.openById(liveSpreadsheetId);
    const backupSs = SpreadsheetApp.openById(backupFileId);

    performSheetCopyRestore(backupSs, liveSs); // Panggil helper function

    // 3. Set status 'complete' di cache jika berhasil
    cache.put(statusKey, 'complete', 300); // Simpan status selesai selama 5 menit

  } catch (e) {
    Logger.log(`restoreFromCode Error: ${e.stack}`);
    // Jika ada error, simpan pesan error di cache
    cache.put(statusKey, `error: ${e.message}`, 300);
  }
}

/**
 * [BARU] Helper untuk memeriksa status proses restore yang berjalan di latar belakang.
 * @param {string} liveSpreadsheetId ID spreadsheet yang sedang direstore.
 * @param {string} userEmail Email pengguna yang meminta.
 * @returns {string|null} Status saat ini: 'running', 'complete', 'error: ...', atau null.
 */
function getRestoreStatusForUser(liveSpreadsheetId, userEmail) {
  const cache = CacheService.getScriptCache();
  const statusKey = `restore_status_${userEmail}_${liveSpreadsheetId}`;
  return cache.get(statusKey);
}

/**
 * [BARU] Menghapus file backup dan catatannya di registry, dengan validasi kepemilikan.
 * @param {string} backupFileId ID file backup yang akan dihapus.
 * @param {string} userEmail Email pengguna yang meminta penghapusan.
 * @returns {object} Hasil operasi.
 */
function deleteBackupForUser(backupFileId, userEmail) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  
  try {
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);
    if (!registrySheet) {
      throw new Error("Sistem registry backup tidak ditemukan.");
    }

    const data = registrySheet.getRange(1, 1, registrySheet.getLastRow(), registrySheet.getLastColumn()).getValues();
    const headers = data[0];
    const idIndex = headers.indexOf('ID File Backup');
    const emailIndex = headers.indexOf('Dibuat Oleh (Email)');
    
    let rowIndexToDelete = -1;

    // Cari dari baris ke-2 (indeks 1)
    for (let i = 1; i < data.length; i++) {
      if (data[i][idIndex] === backupFileId) {
        if (data[i][emailIndex].toLowerCase() === userEmail.toLowerCase()) {
          rowIndexToDelete = i + 1; // Nomor baris di spreadsheet
          break;
        } else {
          throw new Error("Akses ditolak. Anda tidak memiliki izin untuk menghapus backup ini.");
        }
      }
    }

    if (rowIndexToDelete !== -1) {
      // Hapus file di Google Drive
      DriveApp.getFileById(backupFileId).setTrashed(true);
      // Hapus baris di registry
      registrySheet.deleteRow(rowIndexToDelete);
      
      lock.releaseLock();
      return { status: 'success', message: 'File backup dan catatannya berhasil dihapus.' };
    } else {
      lock.releaseLock();
      return { status: 'error', message: 'Backup tidak ditemukan atau Anda tidak memiliki izin.' };
    }

  } catch (e) {
    lock.releaseLock();
    Logger.log(`deleteBackupForUser Error: ${e.stack}`);
    return { status: 'error', message: `Gagal menghapus backup: ${e.message}` };
  }
}

/**
 * [HELPER - TIDAK DIUBAH] Fungsi inti untuk menyalin semua sheet dari sumber ke target.
 * @param {SpreadsheetApp.Spreadsheet} sourceSs Objek Spreadsheet sumber.
 * @param {SpreadsheetApp.Spreadsheet} targetSs Objek Spreadsheet tujuan.
 */
function performSheetCopyRestore(sourceSs, targetSs) {
  const placeholderName = '__placeholder__' + new Date().getTime();
  const placeholderSheet = targetSs.insertSheet(placeholderName);
  
  const originalTargetSheets = targetSs.getSheets().filter(s => s.getName() !== placeholderName);
  
  originalTargetSheets.forEach(sheet => {
    try {
      targetSs.deleteSheet(sheet);
    } catch (e) {
      Logger.log(`Gagal menghapus sheet lama: ${sheet.getName()}. Error: ${e.message}`);
    }
  });
  
  const sourceSheets = sourceSs.getSheets();
  sourceSheets.forEach(sourceSheet => {
    const sourceName = sourceSheet.getName();
    sourceSheet.copyTo(targetSs).setName(sourceName);
  });
  
  targetSs.deleteSheet(placeholderSheet);
  
  try {
    const allSheets = targetSs.getSheets();
    if (allSheets.length > 0) {
      targetSs.setActiveSheet(allSheets[0]);
    }
  } catch (e) { 
    Logger.log('Gagal mengaktifkan sheet pertama setelah restore.');
  }
}


/**
 * [BARU] Mencatat setiap aktivitas login ke sheet 'Log Aktivitas'.
 * Fungsi ini akan otomatis membuat sheet jika belum ada.
 * @param {string} email - Email pengguna yang login.
 * @param {string} namaSekolah - Nama sekolah pengguna.
 * @param {string} jenjang - Jenjang sekolah pengguna.
 * @param {string} role - Role pengguna.
 */
function logLoginActivity(email, namaSekolah, jenjang, role) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let logSheet = ss.getSheetByName(SHEET_LOG);

    // Jika sheet 'Log Aktivitas' tidak ditemukan, buat baru beserta header.
    if (!logSheet) {
      logSheet = ss.insertSheet(SHEET_LOG, 0); // Buat sebagai sheet pertama
      const headers = [['Timestamp', 'Email', 'Nama Sekolah', 'Jenjang', 'Role']];
      logSheet.getRange(1, 1, 1, 5).setValues(headers).setFontWeight('bold');
      logSheet.setFrozenRows(1); // Bekukan baris header
    }

    // Tambahkan baris baru untuk setiap aktivitas login
    logSheet.appendRow([new Date(), email, namaSekolah, jenjang, role]);
  } catch (e) {
    // Catat error jika gagal logging, tapi jangan hentikan proses login
    Logger.log(`Gagal mencatat log aktivitas untuk email ${email}: ${e.message}`);
  }
}

/**
 * [VERSI FINAL] Mengambil seluruh riwayat versi dari sheet 'Versi Aplikasi'.
 * Memanggil helper untuk memastikan format tanggal dalam Bahasa Indonesia.
 * @returns {Array} Array berisi objek untuk setiap versi.
 */
function getAllVersionChangelogs() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_VERSI);

    if (!sheet) {
      Logger.log("Sheet 'Versi Aplikasi' tidak ditemukan.");
      return [];
    }

    const data = sheet.getDataRange().getValues();

    if (data.length < 2) {
      return [];
    }

    const allVersions = [];
    const headers = data[0];
    const versionIndex = headers.indexOf("Versi");
    const dateIndex = headers.indexOf("Tanggal Rilis");
    const changelogIndex = headers.indexOf("Catatan Perubahan (pisahkan dengan baris baru)");

    if(versionIndex === -1 || dateIndex === -1 || changelogIndex === -1) {
        throw new Error("Satu atau lebih nama header ('Versi', 'Tanggal Rilis', 'Catatan Perubahan (pisahkan dengan baris baru)') tidak ditemukan di sheet 'Versi Aplikasi'.");
    }

    const spreadsheetTimezone = ss.getSpreadsheetTimeZone();

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const version = row[versionIndex];

      if (!version) {
        continue;
      }

      const releaseDate = row[dateIndex];

      allVersions.push({
        version: version.toString().trim(),

        // ▼▼▼ PERUBAHAN UTAMA ADA DI SINI ▼▼▼
        // Memanggil fungsi helper baru kita untuk format tanggal
        releaseDate: releaseDate instanceof Date ? formatDateToIndonesian(releaseDate, spreadsheetTimezone) : releaseDate.toString(),
        // ▲▲▲ AKHIR DARI PERUBAHAN ▲▲▲

        changelog: row[changelogIndex].toString().split('\n').map(line => line.trim()).filter(line => line)
      });
    }

    return allVersions;

  } catch (e) {
    Logger.log("Error di getAllVersionChangelogs: " + e.message);
    throw new Error("Gagal mengambil data changelog dari server. " + e.message); 
  }
}

/**
 * [BARU] Helper untuk memformat tanggal ke Bahasa Indonesia dengan benar.
 * Menerjemahkan nama bulan dari output default Apps Script.
 * @param {Date} dateObj Objek tanggal yang akan diformat.
 * @param {string} timezone Zona waktu dari spreadsheet.
 * @return {string} Tanggal yang sudah diformat, cth: "18 Oktober 2025".
 */
function formatDateToIndonesian(dateObj, timezone) {
  // Peta untuk menerjemahkan bulan
  const monthMap = {
    'January': 'Januari', 'February': 'Februari', 'March': 'Maret',
    'April': 'April', 'May': 'Mei', 'June': 'Juni',
    'July': 'Juli', 'August': 'Agustus', 'September': 'September',
    'October': 'Oktober', 'November': 'November', 'December': 'Desember'
  };

  // Format tanggal ke dalam Bahasa Inggris terlebih dahulu
  let formattedDate = Utilities.formatDate(dateObj, timezone, "dd MMMM yyyy");

  // Ganti nama bulan Inggris dengan nama bulan Indonesia
  for (const [english, indonesian] of Object.entries(monthMap)) {
    formattedDate = formattedDate.replace(english, indonesian);
  }

  return formattedDate;
}

/**
 * [ADMIN] Mengambil semua data versi untuk ditampilkan di panel kelola update.
 * @returns {Array<object>} Array berisi semua data versi.
 */
function getVersionsForAdmin() {
  // ▼▼▼ GERBANG KEAMANAN YANG BENAR ▼▼▼
  const adminEmail = Session.getActiveUser().getEmail();
  if (!isSuperadmin(adminEmail)) {
    // Gunakan throw Error agar bisa ditangkap oleh withFailureHandler di frontend
    throw new Error("Akses ditolak.");
  }
  // ▲▲▲ AKHIR DARI GERBANG KEAMANAN ▲▲▲

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_VERSI);
    if (!sheet || sheet.getLastRow() < 2) {
      return [];
    }
    
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 3).getValues();
    
    return data.map((row, index) => {
      const releaseDate = row[1];
      return {
        row: index + 2,
        version: row[0],
        releaseDate: releaseDate instanceof Date ? Utilities.formatDate(releaseDate, ss.getSpreadsheetTimeZone(), "yyyy-MM-dd") : releaseDate,
        changelog: row[2]
      };
    }).sort((a, b) => a.row - b.row);

  } catch (e) {
    Logger.log("getVersionsForAdmin Error: " + e.message);
    throw new Error("Gagal mengambil data versi dari server.");
  }
}

/**
 * [ADMIN - DIPERBAIKI] Menambahkan data versi baru ke baris kedua (setelah header)
 * dan memastikan format kolom Versi adalah Teks.
 * @param {object} versionData Objek berisi data versi baru {version, releaseDate, changelog}.
 * @returns {object} Objek status.
 */
function addVersion(versionData) {
    const adminEmail = Session.getActiveUser().getEmail();
    if (!isSuperadmin(adminEmail)) {
        return { status: "error", message: "Akses ditolak." };
    }

    try {
        const { version, releaseDate, changelog } = versionData;
        if (!version || !releaseDate || !changelog) {
            throw new Error("Semua field wajib diisi.");
        }
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sheet = ss.getSheetByName(SHEET_VERSI);

        // --- [PERBAIKAN DIMULAI DI SINI] ---

        // 1. Sisipkan baris baru di bawah header (setelah baris 1)
        sheet.insertRowAfter(1);

        // 2. Ambil range untuk baris baru tersebut (yaitu baris ke-2)
        const newRowRange = sheet.getRange("A2:C2");
        
        // 3. Paksa format kolom A di baris baru itu menjadi Plain Text ('@')
        sheet.getRange("A2").setNumberFormat('@');
        
        // 4. Masukkan data ke baris baru tersebut
        newRowRange.setValues([[version, new Date(releaseDate), changelog]]);
        
        // --- [PERBAIKAN SELESAI] ---

        return { status: "success", message: `Versi ${version} berhasil ditambahkan.` };
    } catch (e) {
        return { status: "error", message: `Gagal menambahkan versi: ${e.message}` };
    }
}

/**
 * [ADMIN] Memperbarui data versi yang sudah ada.
 * @param {object} versionData Objek berisi data versi, termasuk nomor baris {row, version, releaseDate, changelog}.
 * @returns {object} Objek status.
 */
function updateVersion(versionData) {
  const adminEmail = Session.getActiveUser().getEmail();
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }

  try {
    const { row, version, releaseDate, changelog } = versionData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_VERSI);
    // Update 1 baris, 3 kolom (A, B, C)
    sheet.getRange(row, 1, 1, 3).setValues([[version, new Date(releaseDate), changelog]]);
    return { status: "success", message: `Versi ${version} berhasil diperbarui.` };
  } catch (e) {
    return { status: "error", message: `Gagal memperbarui versi: ${e.message}` };
  }
}

/**
 * [ADMIN] Menghapus data versi dari sheet.
 * @param {number} rowNumber Nomor baris yang akan dihapus.
 * @returns {object} Objek status.
 */
function deleteVersion(rowNumber) {
  const adminEmail = Session.getActiveUser().getEmail();
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_VERSI);
    sheet.deleteRow(rowNumber);
    return { status: "success", message: "Data versi berhasil dihapus." };
  } catch (e) {
    return { status: "error", message: `Gagal menghapus versi: ${e.message}` };
  }
}

/**
 * FUNGSI UNTUK DIAGNOSA (VERSI FINAL)
 * Mengirimkan hasil diagnosa langsung ke email pengguna yang terdeteksi.
 */
function cekStatusAdminSaya() {
  try {
    const emailAktif = Session.getActiveUser().getEmail();
    const isAdmin = isSuperadmin(emailAktif); // Memanggil fungsi pengecekan standar kita
    
    const subject = "Hasil Diagnosa Akun Superadmin - Aplikasi Ijazah";
    const message = "Halo,\n\n" +
                  "Anda telah menjalankan fungsi diagnosa dari aplikasi Anda. Berikut adalah hasilnya:\n\n" +
                  "=========================================================\n" +
                  "1. Email yang terdeteksi oleh Google saat ini: " + emailAktif + "\n\n" +
                  "2. Apakah email ini terdaftar sebagai Superadmin di sheet 'Data Pengguna'? " + (isAdmin ? 'YA, Benar.' : 'TIDAK, Salah.') + "\n" +
                  "=========================================================\n\n" +
                  "TINDAK LANJUT:\n" +
                  "- Jika statusnya 'TIDAK', mohon periksa kembali sheet 'Data Pengguna' di Spreadsheet Induk.\n" +
                  "- Pastikan email di atas tertulis dengan benar dan di kolom 'Role' tertulis persis 'Superadmin' (tanpa salah ketik atau spasi tambahan).\n" +
                  "- Jika email yang terdeteksi bukan email yang Anda harapkan, coba gunakan browser dalam mode Incognito/Private.";

    // Kirim hasil ke email pengguna yang terdeteksi
    MailApp.sendEmail(emailAktif, subject, message);
    
    // Juga catat di log untuk backup
    Logger.log(message);
    
    // Beri tahu pengguna di editor bahwa email telah dikirim
    Browser.msgBox("Diagnosa Selesai", "Hasil diagnosa telah dikirim ke email Anda di: " + emailAktif + ". Silakan periksa kotak masuk (dan folder spam) Anda.", Browser.Buttons.OK);

  } catch (e) {
    Browser.msgBox("Error Saat Diagnosa", "Gagal menjalankan diagnosa: " + e.message, Browser.Buttons.OK);
  }
}

/**
 * [BARU] Mengambil daftar mata pelajaran default berdasarkan jenjang sekolah pengguna.
 * Fungsi ini HANYA mengambil daftar, tidak melakukan impor.
 * @param {string} spreadsheetId ID spreadsheet pengguna untuk menentukan jenjang.
 * @returns {Array<object>} Array objek data mata pelajaran default.
 */
function getDefaultMapelList(spreadsheetId) {
  try {
    const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang;

    if (!jenjang) {
      throw new Error('Jenjang sekolah belum diatur. Harap atur di menu Data Sekolah.');
    }

    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const mapelDefaultSheet = masterSs.getSheetByName(SHEET_MAPEL_DEFAULT);
    if (!mapelDefaultSheet) {
      throw new Error(`Sheet '${SHEET_MAPEL_DEFAULT}' tidak ditemukan di spreadsheet master.`);
    }

    const defaultMapelData = mapelDefaultSheet.getDataRange().getValues();
    defaultMapelData.shift(); // Hapus header

    const mapelForJenjang = defaultMapelData
      .filter(row => row[0] === jenjang) // Filter berdasarkan jenjang
      .map(row => ({ // Ubah menjadi objek agar lebih mudah di frontend
        kode: row[1], 
        nama: row[2], 
        kelompok: row[3], 
        jenisUjian: row[4]
      }));

    if (mapelForJenjang.length === 0) {
      // Tidak melempar error, tapi kirim array kosong agar frontend bisa menangani
      return []; 
    }
    
    return mapelForJenjang;

  } catch (e) {
    Logger.log(e);
    // Lempar error agar bisa ditangkap oleh .withFailureHandler di frontend
    throw new Error("Gagal mengambil daftar mapel default: " + e.message);
  }
}

/**
 * [PERBAIKAN SANGAT PENTING] Mengimpor mapel pilihan PENGGUNA.
 * Setelah selesai, fungsi ini akan membaca ulang dan mengembalikan daftar mapel terbaru
 * untuk menghilangkan delay dan memastikan data selalu sinkron.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} selectedMapelArray Array berisi objek mapel yang dipilih pengguna.
 * @returns {object} Hasil proses impor, TERMASUK daftar mapel yang sudah diupdate.
 */
function importSelectedMapel(spreadsheetId, selectedMapelArray) {
  if (!selectedMapelArray || selectedMapelArray.length === 0) {
    return { status: "info", message: "Tidak ada mata pelajaran yang dipilih untuk diimpor." };
  }

  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);

    const existingMapelMap = new Map();
    if (sheet.getLastRow() >= 2) { 
      const existingDataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4);
      const existingValues = existingDataRange.getValues();
      existingValues.forEach((row, index) => {
        const kode = row[0].toString().trim();
        if (kode) {
          existingMapelMap.set(kode, index + 2);
        }
      });
    }

    const rowsToAppend = [];
    let updatedCount = 0;
    let newCount = 0;

    selectedMapelArray.forEach(mapel => {
      const dataToInsert = [mapel.kode, mapel.nama, mapel.kelompok, mapel.jenisUjian];
      if (existingMapelMap.has(mapel.kode)) {
        const rowNumber = existingMapelMap.get(mapel.kode);
        sheet.getRange(rowNumber, 1, 1, 4).setValues([dataToInsert]);
        updatedCount++;
      } else {
        rowsToAppend.push(dataToInsert);
        newCount++;
      }
    });

    if (rowsToAppend.length > 0) {
      sheet.getRange(sheet.getLastRow() + 1, 1, rowsToAppend.length, 4).setValues(rowsToAppend);
    }
    
    // ======================================================
    // === PERUBAHAN INTI ADA DI BAWAH INI ===
    // ======================================================
    
    // 1. Paksa Google Sheet untuk menyelesaikan semua penulisan data
    SpreadsheetApp.flush(); 
    
    // 2. Baca kembali data mapel yang sudah fresh/terbaru
    const updatedMapelList = getMapel(spreadsheetId);

    // 3. Kirim kembali pesan, status, DAN data yang baru ke frontend
    return { 
      status: "success", 
      message: `Impor Selesai. ${newCount} mapel baru ditambahkan dan ${updatedCount} mapel diperbarui.`,
      updatedMapelList: updatedMapelList // <-- Data baru disertakan di sini
    };

  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengimpor mapel: " + e.message };
  }
}

// [PERUBAHAN] Ganti fungsi saveMapelOrder dengan yang ini di Kode.gs.html
/**
 * [BARU] Menyimpan urutan baru dari daftar mata pelajaran.
 * Fungsi ini akan menghapus semua mapel yang ada dan menulisnya kembali
 * sesuai dengan urutan yang diberikan dari frontend.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} orderedMapelArray Array objek mapel yang sudah diurutkan.
 * @returns {object} Status penyimpanan dan daftar mapel yang sudah diupdate.
 */
function saveMapelOrder(spreadsheetId, orderedMapelArray) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);

    // Hapus data lama terlebih dahulu (dari baris 2 ke bawah)
    if (sheet.getLastRow() >= 2) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }

    // Jika ada data baru untuk ditulis
    if (orderedMapelArray && orderedMapelArray.length > 0) {
      // Ubah array of objects menjadi array 2D untuk ditulis ke sheet
      const newValues = orderedMapelArray.map(m => [m.kode, m.nama, m.kelompok, m.jenisUjian]);
      // Tulis semua data baru dalam satu operasi
      sheet.getRange(2, 1, newValues.length, newValues[0].length).setValues(newValues);
    }
    
    SpreadsheetApp.flush(); // Pastikan perubahan segera diterapkan

    // Ambil kembali data yang sudah terupdate untuk dikirim ke frontend
    const updatedMapelList = getMapel(spreadsheetId);

    return { 
        status: "success", 
        message: "Urutan mata pelajaran berhasil disimpan.",
        updatedMapelList: updatedMapelList // Kirim data terbaru
    };

  } catch (e) {
    Logger.log("saveMapelOrder Error: " + e.message);
    return { status: "error", message: "Gagal menyimpan urutan baru: " + e.message };
  }
}

/**
 * [FINAL & DENGAN PROPERTIES SERVICE] Menghitung ulang semua statistik Superadmin
 * dan menyimpannya ke sheet cache DAN PropertiesService.
 */
function updateSuperadminDashboardCache() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let cacheSheet = ss.getSheetByName(SHEET_DASHBOARD_CACHE);

  if (!cacheSheet) {
    cacheSheet = ss.insertSheet(SHEET_DASHBOARD_CACHE);
  }
  cacheSheet.clearContents().appendRow(['Metric', 'Value']);
  cacheSheet.getRange("B:B").setNumberFormat('@');

  const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
  
  // 1. Hitung Statistik Akun & Siswa (Logika ini tidak berubah)
  let totalAccounts = 0, activeAccounts = 0, totalStudents = 0, inactiveAccounts = 0;
  if (userSheet && userSheet.getLastRow() >= 2) {
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 8).getValues();
    const validUsers = usersData.filter(u => u[1]); // Filter baris yang punya email
    totalAccounts = validUsers.length;
    
    validUsers.forEach(userRow => {
      if (userRow[7] === 'Aktif') activeAccounts++;
      
      const role = userRow[6];
      const spreadsheetId = userRow[5];
      if (role !== 'Superadmin' && spreadsheetId) {
        try {
          const studentSheet = SpreadsheetApp.openById(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
          if (studentSheet && studentSheet.getLastRow() > 1) {
            totalStudents += studentSheet.getLastRow() - 1;
          }
        } catch (e) {
          Logger.log(`[Cache] Gagal akses spreadsheet ID ${spreadsheetId}. Error: ${e.message}`);
        }
      }
    });
    inactiveAccounts = totalAccounts - activeAccounts;
  }

  // 2. Hitung Statistik Pengajuan (Logika ini tidak berubah)
  let totalRequests = 0, pendingRequests = 0, approvedRequests = 0, rejectedRequests = 0;
  try {
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (pengajuanSheet && pengajuanSheet.getLastRow() >= 2) {
      const statusColumn = pengajuanSheet.getRange(2, 8, pengajuanSheet.getLastRow() - 1, 1).getValues();
      totalRequests = statusColumn.length;
      pendingRequests = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
      approvedRequests = statusColumn.filter(row => row[0] === 'Disetujui').length;
      rejectedRequests = statusColumn.filter(row => row[0] === 'Ditolak').length;
    }
  } catch(e) {
     Logger.log("updateSuperadminDashboardCache Error saat mengambil data pengajuan: " + e.message);
  }

  // 3. Siapkan data untuk ditulis ke cache sheet (Logika ini tidak berubah)
  const cacheDataForSheet = [
    ['totalAccounts', totalAccounts], ['activeAccounts', activeAccounts],
    ['inactiveAccounts', inactiveAccounts], ['totalStudents', totalStudents],
    ['totalRequests', totalRequests], ['pendingRequests', pendingRequests],
    ['approvedRequests', approvedRequests], ['rejectedRequests', rejectedRequests],
    ['lastUpdated', new Date().toISOString()]
  ];
  cacheSheet.getRange(2, 1, cacheDataForSheet.length, 2).setValues(cacheDataForSheet);

  // ===== PERUBAHAN UTAMA: SIMPAN KE PROPERTIES SERVICE =====
  // 4. Buat objek JavaScript dari statistik yang sudah dihitung
  const statsObject = {
      totalAccounts, activeAccounts, inactiveAccounts, totalStudents,
      totalRequests, pendingRequests, approvedRequests, rejectedRequests,
      lastUpdated: new Date().toISOString()
  };

  // 5. Simpan objek tersebut sebagai string JSON di PropertiesService
  try {
    const scriptProperties = PropertiesService.getScriptProperties();
    scriptProperties.setProperty('superadminDashboardCache', JSON.stringify(statsObject));
    Logger.log('Cache Dashboard Superadmin berhasil disimpan ke PropertiesService.');
  } catch (e) {
    Logger.log('Gagal menyimpan cache ke PropertiesService: ' + e.message);
  }
  // ===== AKHIR PERUBAHAN =====
}

/**
 * [SUPERADMIN - BARU] Memulihkan data dari file backup menggunakan kode unik ke spreadsheet target.
 * Berbeda dari restore pengguna biasa, fungsi ini tidak memeriksa kepemilikan email.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {string} uniqueCode Kode restore unik dari sheet 'Data Backup Terdaftar'.
 * @param {string} targetSpreadsheetId ID spreadsheet pengguna yang akan ditimpa datanya.
 * @returns {object} Objek berisi status dan pesan.
 */
function adminRestoreFromCode_Superadmin(adminEmail, uniqueCode, targetSpreadsheetId) {
  // 1. Verifikasi bahwa yang menjalankan adalah Superadmin
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak. Hanya Superadmin." };
  }

  if (!uniqueCode || !targetSpreadsheetId) {
    return { status: "error", message: "Kode Unik dan ID Spreadsheet Tujuan wajib diisi." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    // 2. Cari kode di Spreadsheet Induk untuk mendapatkan ID file backup
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const registrySheet = masterSs.getSheetByName(SHEET_BACKUP_REGISTRY);
    if (!registrySheet) {
      throw new Error("Sistem registry backup tidak ditemukan.");
    }

    const data = registrySheet.getRange(2, 1, registrySheet.getLastRow() - 1, 2).getValues(); // Ambil kolom Kode dan ID File
    let backupFileId = null;

    for (let i = 0; i < data.length; i++) {
      if (data[i][0].toString().toUpperCase() === uniqueCode.toUpperCase()) {
        backupFileId = data[i][1];
        break;
      }
    }
    
    if (!backupFileId) {
      throw new Error(`Kode restore '${uniqueCode}' tidak valid atau tidak ditemukan.`);
    }

    // 3. Lakukan proses restore inti
    const backupSs = SpreadsheetApp.openById(backupFileId);
    const targetSs = SpreadsheetApp.openById(targetSpreadsheetId);

    performSheetCopyRestore(backupSs, targetSs); // Memanggil helper function yang sudah ada

    lock.releaseLock();
    return { status: "success", message: `Data berhasil dipulihkan dari kode ${uniqueCode} ke spreadsheet tujuan.` };

  } catch (e) {
    lock.releaseLock();
    Logger.log(`adminRestoreFromCode Error: ${e.stack}`);
    return { status: "error", message: `Gagal memulihkan data: ${e.message}` };
  }
}

// ===== [BARU] FUNGSI UNTUK VALIDASI KELENGKAPAN NILAI =====

/**
 * Memvalidasi kelengkapan semua nilai (ujian dan rapor) untuk setiap siswa.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi hasil validasi atau pesan error.
 */
function validateAllScores(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    
    // 1. Ambil data-data dasar yang diperlukan
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) {
      return { status: 'error', message: 'Tidak ada data siswa untuk divalidasi.' };
    }

    const mapel = getMapel(spreadsheetId);
    if (!mapel || mapel.length === 0) {
      return { status: 'error', message: 'Tidak ada data mata pelajaran untuk divalidasi.' };
    }
    
    const schoolData = getSchoolData(spreadsheetId);
    const jenjang = schoolData ? schoolData.jenjang : null;
    if (!jenjang) {
      return { status: 'error', message: 'Jenjang sekolah belum diatur di menu Data Sekolah.' };
    }

    // 2. Tentukan semua nama sheet yang akan diperiksa berdasarkan jenjang
    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    
    const semestersForJenjang = semesterKeys[jenjang] || [];
    
    const sheetNamesToCheck = [
      SHEET_NILAI_UJIAN_MADRASAH,
      SHEET_NILAI_UJIAN_PRAKTEK,
      ...semestersForJenjang.flatMap(smKey => [`Rapor_Pengetahuan_${smKey}`, `Rapor_Keterampilan_${smKey}`])
    ];

    // 3. Ambil semua data nilai dari semua sheet yang relevan
    const allScoreData = {};
    sheetNamesToCheck.forEach(sheetName => {
      // Menggunakan getSheetByName untuk memastikan sheet ada sebelum dibaca
      if (ss.getSheetByName(sheetName)) {
        allScoreData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName);
      } else {
        allScoreData[sheetName] = {}; // Jika sheet tidak ada, anggap datanya kosong
      }
    });

    // 4. Proses validasi untuk setiap siswa
    const validationResults = students.map(student => {
      const nisn = student.nisn;
      const studentStatus = {
        nisn: nisn,
        nama: student.nama,
        completeness: {}
      };
      
      let totalMissingCount = 0;

      sheetNamesToCheck.forEach(sheetName => {
        const studentScoresOnSheet = allScoreData[sheetName][nisn] || {};
        let isComplete = true; // Asumsikan lengkap pada awalnya

        // Tentukan mapel mana yang harus ada di sheet ini
        let requiredMapel;
        if (sheetName === SHEET_NILAI_UJIAN_MADRASAH) {
          requiredMapel = mapel.filter(m => m.jenisUjian === 'Ujian Madrasah' || m.jenisUjian === 'Keduanya');
        } else if (sheetName === SHEET_NILAI_UJIAN_PRAKTEK) {
          requiredMapel = mapel.filter(m => m.jenisUjian === 'Ujian Praktek' || m.jenisUjian === 'Keduanya');
        } else { // Untuk semua sheet rapor
          requiredMapel = mapel;
        }

        // Jika tidak ada mapel yang disyaratkan untuk sheet ini, anggap lengkap
        if (requiredMapel.length === 0) {
           studentStatus.completeness[sheetName] = true;
           return; // Lanjut ke sheet berikutnya
        }
        
        // Cek setiap mapel yang disyaratkan
        for (const m of requiredMapel) {
          const score = studentScoresOnSheet[m.kode];
          if (score === undefined || score === null || String(score).trim() === '') {
            isComplete = false;
            totalMissingCount++;
            break; // Cukup temukan satu yang kosong, sheet ini tidak lengkap
          }
        }
        studentStatus.completeness[sheetName] = isComplete;
      });
      
      studentStatus.missingCount = totalMissingCount;
      return studentStatus;
    });

    return {
      status: 'success',
      data: validationResults,
      sheetHeaders: sheetNamesToCheck
    };

  } catch (e) {
    Logger.log(`Error in validateAllScores: ${e.stack}`);
    return { status: 'error', message: 'Gagal melakukan validasi: ' + e.message };
  }
}

/**
 * [DIPERBARUI] Memvalidasi kelengkapan nilai berdasarkan per-mata pelajaran untuk setiap siswa.
 * Kini juga menyertakan daftar detail nilai yang kosong.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi hasil validasi atau pesan error.
 */
function validateScoresBySubject(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);

    // 1. Ambil data-data dasar
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) {
      return { status: 'error', message: 'Tidak ada data siswa untuk divalidasi.' };
    }

    const mapelList = getMapel(spreadsheetId);
    if (!mapelList || mapelList.length === 0) {
      return { status: 'error', message: 'Tidak ada data mata pelajaran untuk divalidasi.' };
    }
    
    const schoolData = getSchoolData(spreadsheetId);
    const jenjang = schoolData ? schoolData.jenjang : null;
    if (!jenjang) {
      return { status: 'error', message: 'Jenjang sekolah belum diatur di menu Data Sekolah.' };
    }

    // Peta untuk nama yang lebih ramah pengguna
    const semesterNameMap = {
      k4_ganjil: 'Kelas 4 Ganjil', k4_genap: 'Kelas 4 Genap', k5_ganjil: 'Kelas 5 Ganjil',
      k5_genap: 'Kelas 5 Genap', k6_ganjil: 'Kelas 6 Ganjil',
      k7_ganjil: 'Kelas 7 Ganjil', k7_genap: 'Kelas 7 Genap', k8_ganjil: 'Kelas 8 Ganjil',
      k8_genap: 'Kelas 8 Genap', k9_ganjil: 'Kelas 9 Ganjil',
      k10_ganjil: 'Kelas 10 Ganjil', k10_genap: 'Kelas 10 Genap', k11_ganjil: 'Kelas 11 Ganjil',
      k11_genap: 'Kelas 11 Genap', k12_ganjil: 'Kelas 12 Ganjil'
    };

    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    
    const semestersForJenjang = semesterKeys[jenjang] || [];
    const raporSheetNames = semestersForJenjang.flatMap(smKey => [`Rapor_Pengetahuan_${smKey}`, `Rapor_Keterampilan_${smKey}`]);
    const allSheetNames = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK, ...raporSheetNames];

    // Ambil semua data nilai sekali jalan
    const allScoreData = {};
    allSheetNames.forEach(sheetName => {
      if (ss.getSheetByName(sheetName)) {
        allScoreData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName);
      } else {
        allScoreData[sheetName] = {};
      }
    });

    // Proses validasi
    const validationResults = students.map(student => {
      const nisn = student.nisn;
      const studentResult = {
        nisn: nisn,
        nama: student.nama,
        subjectCompleteness: {}
      };

      mapelList.forEach(mapel => {
        let requiredCount = 0;
        let filledCount = 0;
        let missingDetails = []; // <-- [PERUBAHAN] Array untuk menyimpan detail yang kosong
        const mapelKode = mapel.kode;
        const jenisUjian = mapel.jenisUjian;

        // Cek Nilai Ujian Madrasah
        if (jenisUjian === 'Ujian Madrasah' || jenisUjian === 'Keduanya') {
          requiredCount++;
          const score = (allScoreData[SHEET_NILAI_UJIAN_MADRASAH][nisn] || {})[mapelKode];
          if (score !== undefined && score !== null && String(score).trim() !== '') {
            filledCount++;
          } else {
            missingDetails.push('Nilai Ujian Madrasah'); // <-- [PERUBAHAN] Catat jika kosong
          }
        }
        
        // Cek Nilai Ujian Praktek
        if (jenisUjian === 'Ujian Praktek' || jenisUjian === 'Keduanya') {
          requiredCount++;
          const score = (allScoreData[SHEET_NILAI_UJIAN_PRAKTEK][nisn] || {})[mapelKode];
          if (score !== undefined && score !== null && String(score).trim() !== '') {
            filledCount++;
          } else {
            missingDetails.push('Nilai Ujian Praktek'); // <-- [PERUBAHAN] Catat jika kosong
          }
        }
        
        // Cek semua nilai rapor
        semestersForJenjang.forEach(smKey => {
            // Cek Pengetahuan
            requiredCount++;
            const scoreP = (allScoreData[`Rapor_Pengetahuan_${smKey}`][nisn] || {})[mapelKode];
            if (scoreP !== undefined && scoreP !== null && String(scoreP).trim() !== '') {
                filledCount++;
            } else {
                missingDetails.push(`Rapor Pengetahuan ${semesterNameMap[smKey]}`); // <-- [PERUBAHAN] Catat jika kosong
            }

            // Cek Keterampilan
            requiredCount++;
            const scoreK = (allScoreData[`Rapor_Keterampilan_${smKey}`][nisn] || {})[mapelKode];
            if (scoreK !== undefined && scoreK !== null && String(scoreK).trim() !== '') {
                filledCount++;
            } else {
                missingDetails.push(`Rapor Keterampilan ${semesterNameMap[smKey]}`); // <-- [PERUBAHAN] Catat jika kosong
            }
        });

        studentResult.subjectCompleteness[mapelKode] = {
          complete: filledCount,
          total: requiredCount,
          missing: missingDetails // <-- [PERUBAHAN] Sertakan array detail yang kosong
        };
      });

      return studentResult;
    });

    return {
      status: 'success',
      data: validationResults,
      mapelHeaders: mapelList
    };

  } catch (e) {
    Logger.log(`Error in validateScoresBySubject: ${e.stack}`);
    return { status: 'error', message: 'Gagal melakukan validasi per mapel: ' + e.message };
  }
}

// ===== TAMBAHKAN FUNGSI BARU INI DI Kode.gs =====

/**
 * [SUPERADMIN] Mengambil data sesi pengguna target untuk impersonasi.
 * @param {string} adminEmail - Email superadmin yang meminta.
 * @param {number} targetUserRow - Nomor baris dari pengguna yang akan diimpersonasi.
 * @returns {object} Objek berisi data sesi pengguna target.
 */
function getImpersonationData_Superadmin(adminEmail, targetUserRow) {
  // Keamanan: Pastikan yang meminta adalah Superadmin
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak. Hanya Superadmin yang dapat melakukan aksi ini.");
  }

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    
    // Ambil data dari baris target (4 kolom: Email, Nama Sekolah, Spreadsheet ID, Role)
    const targetUserData = userSheet.getRange(targetUserRow, 2, 1, 6).getValues()[0];
    
    const impersonationData = {
      email: targetUserData[0],         // Kolom B
      namaSekolah: targetUserData[2],   // Kolom D
      spreadsheetId: targetUserData[4], // Kolom F
      role: targetUserData[5] || 'Pengguna' // Kolom G
    };

    if (!impersonationData.spreadsheetId) {
        throw new Error("Pengguna target tidak memiliki Spreadsheet ID yang valid.");
    }

    return { status: 'success', impersonationData: impersonationData };

  } catch (e) {
    Logger.log(`Error in getImpersonationData_Superadmin: ${e.message}`);
    return { status: 'error', message: `Gagal mendapatkan data impersonasi: ${e.message}` };
  }
}

// ===== GANTI KEMBALI KEDUA FUNGSI INI DI Kode.gs =====

/**
 * [AKSI MASSAL] Menghapus beberapa siswa berdasarkan nomor baris mereka.
 */
function bulkDeleteStudents(spreadsheetId, rowNumbers) {
  try {
    if (!rowNumbers || rowNumbers.length === 0) {
      return { status: "info", message: "Tidak ada siswa yang dipilih untuk dihapus." };
    }
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);

    rowNumbers.sort((a, b) => b - a);

    rowNumbers.forEach(rowNum => {
      sheet.deleteRow(rowNum);
    });
    
    SpreadsheetApp.flush();
    // Ambil dan kirim kembali daftar siswa yang sudah fresh
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: `${rowNumbers.length} data siswa berhasil dihapus.`,
      updatedStudentList: updatedStudentList 
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data siswa secara massal: " + e.message };
  }
}

/**
 * [AKSI MASSAL] Memperbarui kolom Tahun Lulus untuk beberapa siswa.
 */
function bulkUpdateTahunLulus(spreadsheetId, rowNumbers, tahunLulus) {
  try {
    if (!rowNumbers || rowNumbers.length === 0) {
      return { status: "info", message: "Tidak ada siswa yang dipilih." };
    }
    if (!tahunLulus || tahunLulus.toString().trim() === '') {
        return { status: "error", message: "Tahun lulus tidak boleh kosong." };
    }
      
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    const tahunLulusColumn = 11; // Kolom K

    rowNumbers.forEach(rowNum => {
      sheet.getRange(rowNum, tahunLulusColumn).setValue(tahunLulus);
    });

    SpreadsheetApp.flush();
    // Ambil dan kirim kembali daftar siswa yang sudah fresh
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: `${rowNumbers.length} data siswa berhasil diupdate tahun lurusnya.`,
      updatedStudentList: updatedStudentList
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengupdate tahun lulus secara massal: " + e.message };
  }
}

// GANTI FUNGSI generateNilaiTemplate DENGAN VERSI FINAL INI
/**
 * [FINAL v2] Menghasilkan file template Excel untuk upload nilai.
 * Menambahkan sheet '_validation_' tersembunyi yang berisi 'uploadType' untuk validasi.
 */
function generateNilaiTemplate(spreadsheetId, templateName) {
  let tempFile;
  try {
    const ss = SpreadsheetApp.create(`Template_Upload_${templateName}_${new Date().getTime()}`);
    tempFile = DriveApp.getFileById(ss.getId());

    const students = getStudents(spreadsheetId);
    const studentData = (students || []).map(s => ["'" + s.nisn, s.nama.toUpperCase()]);

    const populateSheet = (sheet, mapel) => {
      if (!mapel || mapel.length === 0) {
        sheet.appendRow(["Tidak ada mata pelajaran yang dikonfigurasi untuk jenis ini."]);
        return;
      }
      const headers = ["NISN", "Nama Lengkap", ...mapel.map(m => m.kode)];
      sheet.appendRow(headers);
      sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold").setBackground("#d9ead3");
      if (studentData.length > 0) {
        sheet.getRange(2, 1, studentData.length, 2).setValues(studentData);
      }
      sheet.getRange("A:A").setNumberFormat('@');
      sheet.setColumnWidth(1, 120);
      sheet.setColumnWidth(2, 250);
    };

    let uploadTypeIdentifier = ''; // Kode unik untuk validasi

    if (templateName.startsWith('Rapor_')) {
      const sheetP = ss.getSheets()[0].setName('Pengetahuan');
      const sheetK = ss.insertSheet('Keterampilan');
      const allMapel = getMapel(spreadsheetId);
      populateSheet(sheetP, allMapel);
      populateSheet(sheetK, allMapel);
      uploadTypeIdentifier = templateName.toLowerCase(); // contoh: 'rapor_k7_ganjil'

    } else if (templateName === 'UjianGabungan') {
      const sheetUM = ss.getSheets()[0].setName('Ujian Madrasah');
      const sheetUP = ss.insertSheet('Ujian Praktek');
      const mapelUM = getMapelByJenis(spreadsheetId, 'madrasah');
      const mapelUP = getMapelByJenis(spreadsheetId, 'praktek');
      populateSheet(sheetUM, mapelUM);
      populateSheet(sheetUP, mapelUP);
      uploadTypeIdentifier = 'ujian_gabungan';
    
    } else {
      throw new Error(`Nama template "${templateName}" tidak valid.`);
    }

    // --- [VALIDASI BARU] ---
    // Buat sheet tersembunyi yang berisi kode identifikasi unik.
    const validationSheet = ss.insertSheet('_validation_');
    validationSheet.getRange("A1").setValue(uploadTypeIdentifier);
    validationSheet.hideSheet(); // Sembunyikan dari pengguna
    // --- [AKHIR VALIDASI BARU] ---
    
    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${ss.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, { headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` }, muteHttpExceptions: true });
    const blob = response.getBlob();

    return {
      fileName: `Template_${templateName}.xlsx`,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(`generateNilaiTemplate Error: ${e.stack}`);
    return { error: e.toString() };
  } finally {
    if (tempFile) tempFile.setTrashed(true);
  }
}


/**
 * [FINAL v2] Menerima file Excel dan mengimpor nilai ke sheet yang sesuai.
 * Kini melakukan validasi berdasarkan sheet '_validation_' yang tersembunyi.
 * Dan menggunakan helper processSheetImport yang baru dan lebih andal.
 */
function uploadNilaiFromExcel(spreadsheetId, fileData, uploadType) {
  let tempFile;
  try {
    const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
    const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
    const tempSpreadsheetFile = Drive.Files.insert({ title: `temp_upload_${uploadType}` }, blob, { convert: true });
    tempFile = DriveApp.getFileById(tempSpreadsheetFile.id);
    const importSs = SpreadsheetApp.openById(tempFile.getId());

    // Validasi tipe file upload
    const validationSheet = importSs.getSheetByName('_validation_');
    if (!validationSheet) {
      throw new Error("File tidak valid. Harap gunakan template yang diunduh langsung dari aplikasi.");
    }
    const fileIdentifier = validationSheet.getRange("A1").getValue().toString().trim();
    if (fileIdentifier !== uploadType) {
      const formatTypeName = (typeStr) => typeStr.replace(/_/g, ' ').replace(/(^\w{1})|(\s+\w{1})/g, letter => letter.toUpperCase());
      throw new Error(`Kesalahan Upload: Anda mencoba mengunggah template untuk "${formatTypeName(fileIdentifier)}" ke slot "${formatTypeName(uploadType)}". Harap gunakan file yang benar.`);
    }

    const targetSs = getSpreadsheet(spreadsheetId);
    
    if (uploadType.startsWith('rapor_')) {
      const semesterKey = uploadType.split('_').slice(1).join('_');
      const allMapel = getMapel(spreadsheetId);
      
      const countP = processSheetImport(targetSs, `Rapor_Pengetahuan_${semesterKey}`, importSs.getSheetByName('Pengetahuan'), allMapel);
      const countK = processSheetImport(targetSs, `Rapor_Keterampilan_${semesterKey}`, importSs.getSheetByName('Keterampilan'), allMapel);
      
      return { status: "success", message: `Impor Rapor Selesai. Pengetahuan: ${countP} nilai diupdate. Keterampilan: ${countK} nilai diupdate.` };
    
    } else if (uploadType === 'ujian_gabungan') {
      const mapelUM = getMapelByJenis(spreadsheetId, 'madrasah');
      const mapelUP = getMapelByJenis(spreadsheetId, 'praktek');

      const countUM = processSheetImport(targetSs, SHEET_NILAI_UJIAN_MADRASAH, importSs.getSheetByName('Ujian Madrasah'), mapelUM);
      const countUP = processSheetImport(targetSs, SHEET_NILAI_UJIAN_PRAKTEK, importSs.getSheetByName('Ujian Praktek'), mapelUP);

      return { status: "success", message: `Impor Ujian Selesai. U. Madrasah: ${countUM} nilai diupdate. U. Praktek: ${countUP} nilai diupdate.` };

    } else {
      throw new Error("Tipe upload tidak dikenali.");
    }

  } catch (e) {
    Logger.log(`uploadNilaiFromExcel Error: ${e.stack}`);
    return { status: "error", message: e.toString() };
  } finally {
    if (tempFile) tempFile.setTrashed(true);
  }
}

// ===== AWAL KODE TAMBAHAN UNTUK FITUR BROADCAST =====

/**
 * [SUPERADMIN] Mengirimkan pesan broadcast ke semua pengguna.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {string} title - Judul pesan.
 * @param {string} message - Isi pesan.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function sendBroadcast_Superadmin(adminEmail, title, message) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak. Hanya Superadmin." };
  }
  try {
    if (!title || !message) {
      return { status: "error", message: "Judul dan Isi Pesan tidak boleh kosong." };
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let broadcastSheet = ss.getSheetByName(SHEET_BROADCAST);

    // Buat sheet jika belum ada
    if (!broadcastSheet) {
      broadcastSheet = ss.insertSheet(SHEET_BROADCAST);
      broadcastSheet.appendRow(['Broadcast ID', 'Tanggal', 'Judul', 'Isi Pesan']);
      broadcastSheet.getRange("A1:D1").setFontWeight("bold");
    }

    const broadcastId = Utilities.getUuid();
    broadcastSheet.appendRow([broadcastId, new Date(), title, message]);

    return { status: "success", message: "Pesan broadcast berhasil dikirim." };

  } catch (e) {
    Logger.log("sendBroadcast_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal mengirim pesan: " + e.message };
  }
}

/**
 * [HELPER] Mengambil data broadcast terbaru dari sheet.
 * @returns {object|null} Objek berisi detail broadcast terbaru atau null jika tidak ada.
 */
function getLatestBroadcast() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_BROADCAST);

    if (!sheet || sheet.getLastRow() < 2) {
      return null;
    }

    const lastRow = sheet.getLastRow();
    const [id, timestamp, title, message] = sheet.getRange(lastRow, 1, 1, 4).getValues()[0];

    return {
      id: id,
      title: title,
      message: message
    };
  } catch (e) {
    Logger.log("getLatestBroadcast Error: " + e.message);
    return null;
  }
}

/**
 * [USER - DIPERBARUI] Menandai bahwa pengguna telah melihat broadcast terbaru.
 * Mencatat status ke sheet terpisah untuk pelacakan yang akurat.
 * @param {string} userEmail - Email pengguna yang akan ditandai.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function markBroadcastAsRead(userEmail) {
  try {
    if (!userEmail) {
      return { status: 'error', message: 'Email pengguna tidak valid.' };
    }

    const latestBroadcast = getLatestBroadcast();
    if (!latestBroadcast) {
      return { status: 'info', message: 'Tidak ada broadcast untuk ditandai.' };
    }
    const latestBroadcastId = latestBroadcast.id;

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let readStatusSheet = ss.getSheetByName(SHEET_BROADCAST_READ_STATUS);
    
    // Buat sheet jika belum ada
    if (!readStatusSheet) {
      readStatusSheet = ss.insertSheet(SHEET_BROADCAST_READ_STATUS);
      readStatusSheet.appendRow(['Broadcast ID', 'User Email', 'Read Timestamp']);
    }
    
    // Cek dulu apakah data sudah ada untuk mencegah duplikat
    if (!hasUserReadBroadcast(latestBroadcastId, userEmail)) {
        readStatusSheet.appendRow([latestBroadcastId, userEmail, new Date()]);
    }

    return { status: 'success', message: 'Status broadcast telah diperbarui.' };

  } catch (e) {
    Logger.log("markBroadcastAsRead Error: " + e.message);
    return { status: 'error', message: 'Gagal memperbarui status broadcast: ' + e.message };
  }
}

/**
 * [HELPER BARU] Mengecek apakah seorang pengguna sudah pernah membaca broadcast tertentu.
 * @param {string} broadcastId - ID broadcast yang ingin dicek.
 * @param {string} userEmail - Email pengguna.
 * @returns {boolean} True jika sudah membaca, false jika belum.
 */
function hasUserReadBroadcast(broadcastId, userEmail) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_BROADCAST_READ_STATUS);
    if (!sheet || sheet.getLastRow() < 2) return false;

    const data = sheet.getRange("A2:B" + sheet.getLastRow()).getValues();
    return data.some(row => row[0] === broadcastId && row[1].toLowerCase() === userEmail.toLowerCase());
  } catch (e) {
    Logger.log("hasUserReadBroadcast Error: " + e.message);
    return false; // Anggap belum baca jika error
  }
}

/**
 * [SUPERADMIN BARU - DIPERBAIKI] Mengambil riwayat semua broadcast beserta jumlah pembacanya.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek data broadcast.
 */
function getBroadcastHistory_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) throw new Error("Akses ditolak.");

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const broadcastSheet = ss.getSheetByName(SHEET_BROADCAST);
  if (!broadcastSheet || broadcastSheet.getLastRow() < 2) return [];

  const broadcasts = broadcastSheet.getRange("A2:D" + broadcastSheet.getLastRow()).getValues().map(row => ({
    id: row[0],
    // PERUBAHAN UTAMA: Ubah objek Date menjadi string ISO yang aman untuk dikirim ke browser.
    date: row[1] instanceof Date ? row[1].toISOString() : row[1],
    title: row[2],
    message: row[3]
  }));

  const readStatusSheet = ss.getSheetByName(SHEET_BROADCAST_READ_STATUS);
  const readCounts = new Map();

  if (readStatusSheet && readStatusSheet.getLastRow() >= 2) {
    const readData = readStatusSheet.getRange("A2:A" + readStatusSheet.getLastRow()).getValues().flat();
    readData.forEach(id => {
      readCounts.set(id, (readCounts.get(id) || 0) + 1);
    });
  }

  return broadcasts.map(b => ({
    ...b,
    readByCount: readCounts.get(b.id) || 0
  })).sort((a, b) => new Date(b.date) - new Date(a.date)); // Urutkan dari terbaru
}

/**
 * [SUPERADMIN BARU] Memperbarui data broadcast yang sudah ada.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {object} broadcastData - Data yang akan diupdate {id, title, message}.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function updateBroadcast_Superadmin(adminEmail, broadcastData) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };

  try {
    const { id, title, message } = broadcastData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_BROADCAST);
    const data = sheet.getRange("A2:A" + sheet.getLastRow()).getValues().flat();
    const rowIndex = data.findIndex(rowId => rowId === id);

    if (rowIndex === -1) throw new Error("Broadcast tidak ditemukan.");

    const rowToUpdate = rowIndex + 2;
    sheet.getRange(rowToUpdate, 3).setValue(title);
    sheet.getRange(rowToUpdate, 4).setValue(message);
    
    return { status: "success", message: "Pengumuman berhasil diperbarui." };
  } catch (e) {
    Logger.log("updateBroadcast_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memperbarui: " + e.message };
  }
}

/**
 * [SUPERADMIN BARU] Menghapus data broadcast dan semua catatan 'telah dibaca' yang terkait.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {string} broadcastId - ID broadcast yang akan dihapus.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function deleteBroadcast_Superadmin(adminEmail, broadcastId) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };

  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // Hapus dari sheet utama
    const broadcastSheet = ss.getSheetByName(SHEET_BROADCAST);
    const dataBroadcast = broadcastSheet.getRange("A2:A" + broadcastSheet.getLastRow()).getValues().flat();
    const indexToDelete = dataBroadcast.findIndex(id => id === broadcastId);
    if (indexToDelete !== -1) {
      broadcastSheet.deleteRow(indexToDelete + 2);
    }
    
    // Hapus dari sheet status baca
    const readStatusSheet = ss.getSheetByName(SHEET_BROADCAST_READ_STATUS);
    if (readStatusSheet && readStatusSheet.getLastRow() >= 2) {
      const readData = readStatusSheet.getRange("A2:A" + readStatusSheet.getLastRow()).getValues();
      const rowsToDelete = [];
      readData.forEach((row, index) => {
        if (row[0] === broadcastId) {
          rowsToDelete.push(index + 2);
        }
      });
      // Hapus dari bawah ke atas agar indeks tidak bergeser
      for (let i = rowsToDelete.length - 1; i >= 0; i--) {
        readStatusSheet.deleteRow(rowsToDelete[i]);
      }
    }
    
    lock.releaseLock();
    return { status: "success", message: "Pengumuman berhasil dihapus." };
  } catch (e) {
    lock.releaseLock();
    Logger.log("deleteBroadcast_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal menghapus: " + e.message };
  }
}

// ===== AWAL KODE TAMBAHAN (Fitur Portal Siswa) =====

/**
 * [MODIFIKASI PENTING] Mencari siswa dan mengambil semua data untuk portal siswa.
 * @param {string} kodeSekolah - Kode unik sekolah.
 * @param {string} nisn - NISN yang diinput siswa.
 * @param {string} tanggalLahir - Tanggal lahir dalam format yyyy-MM-dd.
 * @returns {object} Objek status berisi semua data yang dibutuhkan siswa jika berhasil.
 */
function loginSiswa(kodeSekolah, nisn, tanggalLahir) {
    try {
        if (!kodeSekolah || !nisn || !tanggalLahir) {
            return { status: "error", message: "Kode Sekolah, NISN, dan Tanggal Lahir wajib diisi." };
        }

        const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
        if (!userSheet || userSheet.getLastRow() < 2) {
            return { status: "error", message: "Sistem tidak menemukan data sekolah manapun." };
        }
        
        const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
        const schoolRow = data.find(row => row[12] && row[12].toUpperCase() === kodeSekolah.toUpperCase());

        // Ganti bagian ini di dalam fungsi loginSiswa
        if (!schoolRow) {
            return { status: "error", message: "Kode Sekolah tidak valid atau tidak ditemukan." };
        }

        // --- AWAL MODIFIKASI ---
        // Cek apakah fitur untuk sekolah ini terkunci
        const lockStatus = checkFiturLock(schoolRow[1]); // Cek berdasarkan email pengguna
        if (lockStatus.isLocked) {
          return { 
            status: "locked", 
            message: "Akses untuk siswa dari sekolah ini sementara ditangguhkan. Silakan hubungi administrator sekolah Anda untuk informasi lebih lanjut." 
          };
        }
        // --- AKHIR MODIFIKASI ---
        
        const spreadsheetId = schoolRow[5]; // Kolom F adalah Spreadsheet ID
        if (!spreadsheetId) {
            return { status: "error", message: "Konfigurasi untuk sekolah ini tidak lengkap." };
        }

        const studentInfo = findStudentInSheet(spreadsheetId, nisn, tanggalLahir);

        if (studentInfo) {
            // == AWAL PERUBAHAN ==
            // Ambil data sekolah untuk mendapatkan nama sekolah
            const schoolData = getSchoolData(spreadsheetId);
            // == AKHIR PERUBAHAN ==

            // 1. Ambil pengaturan kelulusan
            const gradSettingsResponse = getGraduationSettings(spreadsheetId);
            const gradSettings = gradSettingsResponse.settings || { announcementDate: null, showTranscriptGlobal: 'TIDAK' };
            
            // 2. Ambil status kelulusan siswa dari rekap ijazah
            const rekapIjazah = getSheetDataAsObject(spreadsheetId, SHEET_REKAP_IJAZAH);
            const studentRekap = rekapIjazah[nisn] || {};
            const statusLulus = studentRekap['Status'] || 'Belum Ditentukan';
            
            // 3. Ambil status visibilitas transkrip per-siswa
            const studentDataSheet = getSpreadsheet(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
            const nisnColumnValues = studentDataSheet.getRange(2, 1, studentDataSheet.getLastRow() - 1, 1).getValues().flat();
            const studentRowIndex = nisnColumnValues.findIndex(val => val.toString() === nisn.toString());
            // Kolom ke-12 adalah kolom L
            const perStudentVisibility = (studentRowIndex !== -1) ? studentDataSheet.getRange(studentRowIndex + 2, 12).getValue() : 'TIDAK';

            // 4. Gabungkan semua data dalam respons
            return {
                status: "success",
                webAppUrl: ScriptApp.getService().getUrl(),
                nisn: nisn,
                spreadsheetId: spreadsheetId,
                studentData: studentInfo,
                schoolData: schoolData, // <-- DATA BARU YANG DIKIRIM
                announcementDate: gradSettings.announcementDate,
                showTranscriptGlobal: gradSettings.showTranscriptGlobal,
                showTranscriptPerStudent: perStudentVisibility,
                statusLulus: statusLulus
            };
        } else {
            return { status: "error", message: "Login Gagal. Pastikan NISN dan Tanggal Lahir Anda benar. Jika masih mengalami kendala login, silahkan hubungi Operator Sekolah/Madrasah." };
        }

    } catch (error) {
        Logger.log("loginSiswa Error: " + error.message + " Stack: " + error.stack);
        return { status: "error", message: "Terjadi kesalahan pada server." };
    }
}

/**
 * [PERBAIKAN] Fungsi pembantu untuk mencari siswa dan mengembalikan SEMUA datanya.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {string} nisn - NISN yang dicari.
 * @param {string} tanggalLahir - Tanggal lahir yang dicari.
 * @returns {object|null} Objek berisi semua data siswa jika cocok, atau null jika tidak.
 */
function findStudentInSheet(spreadsheetId, nisn, tanggalLahir) {
  const ss = SpreadsheetApp.openById(spreadsheetId);
  const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
  if (!sheet || sheet.getLastRow() < 2) return null;

  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 11).getValues();

  for (const row of data) {
    const sheetNisn = String(row[0]).trim();

    if (sheetNisn === nisn) {
      const sheetTglLahir = row[5]; // Kolom F adalah Tanggal Lahir
      if (sheetTglLahir instanceof Date) {
        const formattedSheetTglLahir = Utilities.formatDate(sheetTglLahir, Session.getScriptTimeZone(), "yyyy-MM-dd");
        if (formattedSheetTglLahir === tanggalLahir) {
          // Jika cocok, kembalikan semua data siswa dalam bentuk objek
          return {
            nisn: String(row[0] || ''),
            nis: String(row[1] || ''),
            nama: String(row[2] || ''),
            jenisKelamin: String(row[3] || ''),
            tempatLahir: String(row[4] || ''),
            tanggalLahir: formattedSheetTglLahir,
            alamat: String(row[6] || ''),
            telepon: String(row[7] || ''),
            emailSiswa: String(row[8] || ''),
            tahunMasuk: String(row[9] || ''),
            tahunLulus: String(row[10] || '')
          };
        }
      }
    }
  }
  return null; // Tidak ada yang cocok di sheet ini
}
// ===== AKHIR KODE TAMBAHAN (Fitur Portal Siswa) =====

function generateMissingSchoolCodes_Superadmin() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEET_PENGGUNA);
  if (!sheet || sheet.getLastRow() < 2) {
    Logger.log("Sheet Data Pengguna kosong atau tidak ditemukan.");
    return;
  }
  
  const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 13);
  const data = dataRange.getValues();
  const existingCodes = data.map(row => row[12]).filter(Boolean);
  let updatedCount = 0;

  data.forEach((row, index) => {
    // Cek jika kolom Kode Sekolah (indeks 12) kosong
    if (!row[12]) {
      let newCode;
      let isUnique = false;
      while (!isUnique) {
        newCode = Math.random().toString(36).substring(2, 8).toUpperCase();
        if (!existingCodes.includes(newCode)) {
          isUnique = true;
        }
      }
      // Tulis kode baru ke spreadsheet di baris yang benar dan kolom M (13)
      sheet.getRange(index + 2, 13).setValue(newCode);
      existingCodes.push(newCode); // Tambahkan ke daftar agar tidak terduplikasi di loop yang sama
      updatedCount++;
    }
  });
  
  Logger.log(`Proses Selesai. ${updatedCount} kode sekolah baru telah dibuat.`);
  Browser.msgBox(`Proses Selesai. ${updatedCount} kode sekolah baru telah dibuat.`);
}

// ===== AWAL KODE TAMBAHAN UNTUK AKSI MASSAL ADMIN =====

/**
 * [AKSI MASSAL] Mengubah batas siswa untuk beberapa akun sekaligus.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {Array<number>} rowNumbers - Array berisi nomor baris akun yang akan diubah.
 * @param {number} newLimit - Batas siswa baru yang akan diterapkan.
 * @returns {object} Hasil operasi.
 */
function bulkUpdateLimit_Superadmin(adminEmail, rowNumbers, newLimit) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };
  
  try {
    const limit = parseInt(newLimit);
    if (isNaN(limit) || limit < 0) {
      return { status: "error", message: "Batas siswa harus berupa angka positif." };
    }
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    
    rowNumbers.forEach(rowNum => {
      userSheet.getRange(rowNum, 9).setValue(limit); // Kolom I adalah Student Limit
    });

    return { status: "success", message: `${rowNumbers.length} akun berhasil diupdate batas siswanya.` };
  } catch (e) {
    return { status: "error", message: "Gagal mengupdate batas secara massal: " + e.message };
  }
}

/**
 * [AKSI MASSAL] Mengubah status (Aktif/Nonaktif) untuk beberapa akun sekaligus.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {Array<number>} rowNumbers - Array berisi nomor baris akun yang akan diubah.
 * @param {string} newStatus - Status baru ('Aktif' atau 'Nonaktif').
 * @returns {object} Hasil operasi.
 */
function bulkSetStatus_Superadmin(adminEmail, rowNumbers, newStatus) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };

  if (newStatus !== 'Aktif' && newStatus !== 'Nonaktif') {
      return { status: "error", message: "Status tidak valid." };
  }
  
  try {
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    
    rowNumbers.forEach(rowNum => {
      userSheet.getRange(rowNum, 8).setValue(newStatus); // Kolom H adalah Status
    });

    return { status: "success", message: `${rowNumbers.length} akun berhasil diubah statusnya menjadi ${newStatus}.` };
  } catch (e) {
    return { status: "error", message: "Gagal mengubah status secara massal: " + e.message };
  }
}

// ===== AKHIR KODE TAMBAHAN UNTUK AKSI MASSAL ADMIN =====

/**
 * [BARU] Men-generate dan menyimpan Kode Sekolah unik untuk pengguna yang sudah ada.
 * Hanya akan membuat kode jika kolomnya masih kosong.
 * @param {string} spreadsheetId ID spreadsheet pengguna yang meminta.
 * @returns {{status: string, message: string, newCode?: string}} Hasil operasi.
 */
function generateSchoolCodeForUser(spreadsheetId) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);

    if (!userSheet || userSheet.getLastRow() < 2) {
      throw new Error("Sheet 'Data Pengguna' tidak ditemukan.");
    }

    const dataRange = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13);
    const usersData = dataRange.getValues();
    
    // Cari baris pengguna berdasarkan spreadsheetId (Kolom F, index 5)
    const userIndex = usersData.findIndex(row => row[5] === spreadsheetId);

    if (userIndex === -1) {
      throw new Error("Data pengguna tidak ditemukan.");
    }

    const rowToUpdate = userIndex + 2; // +2 karena data dimulai dari baris 2 dan index array dimulai dari 0
    const existingCode = usersData[userIndex][12]; // Kolom M (Kode Sekolah) adalah index 12

    if (existingCode && existingCode.toString().trim() !== '') {
      return { status: "error", message: "Anda sudah memiliki Kode Sekolah.", newCode: existingCode };
    }

    // Generate kode unik baru
    let schoolCode;
    let isCodeUnique = false;
    const allExistingCodes = usersData.map(row => row[12]).filter(Boolean);
    
    while (!isCodeUnique) {
      schoolCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      if (!allExistingCodes.includes(schoolCode)) {
        isCodeUnique = true;
      }
    }

    // Simpan kode baru ke sheet
    userSheet.getRange(rowToUpdate, 13).setValue(schoolCode);
    
    SpreadsheetApp.flush(); // Pastikan perubahan segera tersimpan

    return { status: "success", message: "Kode Sekolah berhasil dibuat!", newCode: schoolCode };

  } catch (e) {
    Logger.log("Error in generateSchoolCodeForUser: " + e.message);
    return { status: "error", message: "Gagal membuat kode: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [VERSI FINAL & PALING STABIL] Membuat PDF transkrip dengan mengambil pengaturan
 * langsung dari spreadsheet dan menyematkan token validasi unik ke dalam QR code.
 * Fungsi ini tidak lagi memerlukan parameter 'printOptions'.
 *
 * @param {string} spreadsheetId ID spreadsheet pengguna.
 * @param {string} nisn NISN siswa yang akan dibuatkan transkrip.
 * @returns {object} Objek berisi data file PDF yang telah di-encode base64.
 */
function generateTranscriptPdfForSiswa(spreadsheetId, nisn) {
  try {
    // 1. Ambil semua data utama yang diperlukan dalam satu panggilan
    const transcriptDataResponse = getTranscriptData(spreadsheetId, nisn);
    if (transcriptDataResponse.status !== 'success') {
      throw new Error(transcriptDataResponse.message);
    }
    const { student, school, subjects, bobot, printSettings } = transcriptDataResponse.data;

    // 2. Ambil pengaturan dokumen (gambar)
    const docSettingsResponse = getDocumentSettings(spreadsheetId);
    const docSettings = docSettingsResponse.settings || {};
    const { logo, signature, stamp, customHeader } = docSettings;

    // 3. Fungsi Helper dan Kalkulasi Nilai
    const toProperCase = (str) => {
        if (!str || typeof str !== 'string') return '';
        return str.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
    };
    const tglLahirFormatted = new Date(student.tanggalLahir).toLocaleDateString('id-ID', { day: 'numeric', month: 'long', year: 'numeric' });
    const nomorIndukGabungan = student.nis ? (school.nsm || '') + student.nis : '-';
    const formatScore = (score) => {
      if (score === null || score === undefined || isNaN(score)) return '0';
      return `${Math.round(score)}`;
    };
    let totalNilaiIjazah = 0;
    const mapelCount = subjects.length;
    subjects.forEach(s => {
      totalNilaiIjazah += (s.nilaiIjazah !== null && !isNaN(s.nilaiIjazah)) ? Math.round(s.nilaiIjazah) : 0;
    });
    const rataRataIjazah = mapelCount > 0 ? (totalNilaiIjazah / mapelCount).toFixed(2).replace('.', ',') : '0,00';

    // 4. Logika Dinamis untuk Teks Transkrip (berdasarkan data yang sudah diambil)
    let tahunAjaranText = '';
    if (printSettings && printSettings.tahunAjaran && printSettings.tahunAjaran.trim() !== '') {
        tahunAjaranText = printSettings.tahunAjaran;
    } else if (student.tahunLulus && !isNaN(parseInt(student.tahunLulus))) {
        const tahunLulus = parseInt(student.tahunLulus);
        tahunAjaranText = `${tahunLulus - 1}/${tahunLulus}`;
    }

    const tempatTTD = printSettings.tempatTtd || toProperCase(school.kabupaten) || '(Tempat)';
    let tanggalTTD = new Date().toLocaleDateString('id-ID', { day: '2-digit', month: 'long', year: 'numeric' });
    if (printSettings.tanggalTtd) {
        const inputDate = new Date(printSettings.tanggalTtd);
        inputDate.setMinutes(inputDate.getMinutes() + inputDate.getTimezoneOffset());
        tanggalTTD = inputDate.toLocaleDateString('id-ID', { day: '2-digit', month: 'long', year: 'numeric' });
    }

    let qrCodeHtml = '';
    if (printSettings.showQRCode) {
        // PENTING: Pastikan nisn dan spreadsheetId dikirim ke sini
        const qrCodeBase64 = getQrCodeAsBase64(nisn, spreadsheetId);
        if (qrCodeBase64) {
            qrCodeHtml = `<img src="data:image/png;base64,${qrCodeBase64}" style="width: 80px; height: 80px;" alt="QR Code"><br><span style="font-size:7pt;">Scan untuk validasi</span>`;
        }
    }
    
    // 6. Logika untuk Kop Surat
    let headerHtml;
    if (customHeader) {
        headerHtml = `<div style="width: 100%; margin-bottom: 10px; border-bottom: 3px solid black;"><img src="${customHeader}" alt="Kop Surat" style="width: 100%; height: auto;"></div>`;
    } else {
        const kantorKemenagLine = `KANTOR KEMENTERIAN AGAMA ${school.tipeKabupaten || ''} ${school.kabupaten || ''}`.toUpperCase();
        const tipeKabSingkat = school.tipeKabupaten === 'Kabupaten' ? 'Kab.' : 'Kota';
        const tipeKelSingkat = school.tipeKelurahan === 'Kelurahan' ? 'Kel.' : 'Desa';
        const alamatLengkap = [ school.alamat, `${tipeKelSingkat} ${toProperCase(school.kelurahan || '')}`, `Kec. ${toProperCase(school.kecamatan || '')}`, `${tipeKabSingkat} ${toProperCase(school.kabupaten || '')}`, toProperCase(school.provinsi || ''), school.kodePos ].filter(Boolean).join(', ');
        
        const phone = school.telepon ? `Telepon : ${school.telepon}` : '';
        const web = school.website ? `Website : ${school.website}` : '';
        let contactLine = '';
        if (phone && web) {
          contactLine = `${phone} | ${web}`;
        } else {
          contactLine = phone || web;
        }
        const contactLineHtml = contactLine ? `<div style="font-family: Arial, sans-serif; font-size: 9pt;">${contactLine}</div>` : '';

        headerHtml = `
            <div style="display: flex; align-items: flex-start; padding-bottom: 5px; border-bottom: 3px solid black; margin-bottom: 10px;">
                ${logo ? `<img src="${logo}" style="width:75px; height:75px; margin-right: 20px;" alt="Logo">` : '<div style="width:75px; height:75px; margin-right: 20px;"></div>'}
                <div style="text-align: center; flex-grow: 1; line-height: 1.4; font-family: Arial, sans-serif;">
                   <div style="font-size: 14pt; font-weight: bold;">KEMENTERIAN AGAMA REPUBLIK INDONESIA</div>
                   <div style="font-size: 12pt; font-weight: bold;">${kantorKemenagLine}</div>
                   <div style="font-size: 11pt; font-weight: bold;">${(school.namaSekolah || 'NAMA SEKOLAH').toUpperCase()}</div>
                   <div style="font-size: 9pt;">Alamat : ${alamatLengkap}</div>
                   ${contactLineHtml}
                </div>
            </div>`;
    }

    // 7. Template HTML untuk PDF
    const htmlContent = `
      <html>
        <head>
          <style>
            body{font-family: Arial, sans-serif; font-size: 10pt;} 
            table{border-collapse: collapse; width: 100%;} 
            th, td{border: 1px solid black; padding: 4px; text-align: left; vertical-align: middle;} 
            .no-border{border: none !important;}
            .text-center{text-align: center;} 
            .font-bold{font-weight: bold;} 
            .bg-gray{background-color: #f2f2f2;}
            .footer-container { margin-top: 40px; width: 100%; display: flex; justify-content: space-between; align-items: flex-end; }
            .ttd-block { width: 45%; text-align: center; font-size: 10pt; }
            .qr-block { text-align: center; font-size: 8pt; color: #555; }
            .ttd-signature-area { position: relative; height: 80px; margin-top: 10px; margin-bottom: 5px; }
            .ttd-signature { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); max-width: 150px; max-height: 100px; z-index: 1; }
            .ttd-stamp { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) rotate(-15deg); opacity: 0.75; max-width: 120px; max-height: 120px; z-index: 2; }
            .ttd-name-nip { position: absolute; bottom: -25px; width: 100%; left: 0; }
            .ttd-name { font-weight: bold; text-decoration: underline; margin-bottom: 2px; margin-top: 0; }
            .ttd-nip { margin-top: 0; }
          </style>
        </head>
        <body>
          ${headerHtml}
          <div class="text-center" style="margin-top: 10px; line-height: 1.2;">
             <h3 class="font-bold" style="text-decoration: underline; font-size: 14pt; margin-bottom: 0;">TRANSKRIP NILAI</h3>
             ${tahunAjaranText ? `<p style="font-size: 11pt; font-weight: bold; margin-top: 0; margin-bottom: 10px;">TAHUN AJARAN ${tahunAjaranText}</p>` : ''}
          </div>
          
          <table class="no-border" style="margin-top: 1rem; margin-bottom: 1rem;">
              <tbody>
                  <tr><td class="no-border" style="padding: 1px; width: 180px;">Nama Peserta Didik</td><td class="no-border" style="padding: 1px; width: 10px;">:</td><td class="no-border font-bold" style="padding: 1px;">${student.nama.toUpperCase()}</td></tr>
                  <tr><td class="no-border" style="padding: 1px;">Tempat, Tanggal Lahir</td><td class="no-border" style="padding: 1px;">:</td><td class="no-border font-bold" style="padding: 1px;">${student.tempatLahir ? toProperCase(student.tempatLahir) + ', ' : ''}${tglLahirFormatted}</td></tr>
                  <tr><td class="no-border" style="padding: 1px;">Nomor Induk / NISN</td><td class="no-border" style="padding: 1px;">:</td><td class="no-border font-bold" style="padding: 1px;">${nomorIndukGabungan} / ${student.nisn}</td></tr>
              </tbody>
          </table>

          <table>
            <thead class="bg-gray">
              <tr><th class="text-center" rowspan="2">No</th><th rowspan="2">Mata Pelajaran</th><th class="text-center" colspan="3">Nilai</th></tr>
              <tr><th class="text-center">Rata-Rata Rapor</th><th class="text-center">Ujian Madrasah</th><th class="text-center">Nilai Ijazah</th></tr>
            </thead>
            <tbody>${subjects.map((s, index) => `<tr><td class="text-center">${index + 1}</td><td>${s.nama}</td><td class="text-center">${formatScore(s.nilaiRapor)}</td><td class="text-center">${formatScore(s.nilaiUjian)}</td><td class="text-center font-bold">${formatScore(s.nilaiIjazah)}</td></tr>`).join('')}</tbody>
            <tfoot class="font-bold"><tr><td class="text-center" colspan="4">Rata-rata Nilai Akhir Ijazah</td><td class="text-center bg-gray">${rataRataIjazah}</td></tr></tfoot>
          </table>

          <div style="font-style: italic; font-size: 8pt; margin-top: 15px;">
              Ket: Nilai Ijazah = ${bobot.bobotUjian}% Nilai Ujian Madrasah + ${bobot.bobotRapor}% Nilai Rapor 5 Semester
          </div>

          <div class="footer-container">
              <div class="qr-block">
                ${qrCodeHtml}
              </div>
              <div class="ttd-block">
                  <p>${tempatTTD}, ${tanggalTTD}</p>
                  <p>Kepala Madrasah,</p>
                  <div class="ttd-signature-area">
                      ${stamp ? `<img src="${stamp}" alt="Stempel" class="ttd-stamp">` : ''}
                      ${signature ? `<img src="${signature}" alt="Tanda Tangan" class="ttd-signature">` : ''}
                      <div class="ttd-name-nip">
                        <p class="ttd-name">${school.namaKepsek || '(Nama Kepala Sekolah)'}</p>
                        <p class="ttd-nip">NIP. ${school.nipKepsek || '-'}</p>
                      </div>
                  </div>
              </div>
          </div>
        </body>
      </html>
    `;

    // 8. Konversi ke PDF
    const pdfBlob = Utilities.newBlob(htmlContent, MimeType.HTML).getAs(MimeType.PDF);
    pdfBlob.setName(`Transkrip - ${student.nama}.pdf`);
    
    return {
      status: 'success',
      fileName: pdfBlob.getName(),
      pdfData: Utilities.base64Encode(pdfBlob.getBytes())
    };

  } catch (e) {
    Logger.log("Error in generateTranscriptPdfForSiswa: " + e.message + " | Stack: " + e.stack);
    return { status: "error", message: "Gagal membuat PDF: " + e.message };
  }
}

/**
 * [BARU - VERSI DINAMIS & WARNA UNIK] Mengambil data perkembangan nilai per semester untuk seorang siswa.
 * Membaca dari semua sheet Rapor dan menampilkan SEMUA mapel yang ada di Data Mata Pelajaran.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @param {string} nisn NISN siswa yang datanya akan diambil.
 * @returns {object} Objek berisi data yang siap digunakan untuk membuat grafik.
 */
function getStudentGradeProgress(spreadsheetId, nisn) {
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    
    // 1. Dapatkan jenjang sekolah untuk menentukan daftar semester yang relevan
    const schoolData = getSchoolData(spreadsheetId);
    if (!schoolData || !schoolData.jenjang) {
      throw new Error("Jenjang sekolah tidak ditemukan.");
    }
    
    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    const semestersForJenjang = semesterKeys[schoolData.jenjang] || [];

    // 2. Ambil semua data nilai dari semua sheet rapor yang relevan sekali jalan
    const allScoreData = {};
    semestersForJenjang.forEach(smKey => {
        allScoreData[`Rapor_Pengetahuan_${smKey}`] = getSheetDataAsObject(spreadsheetId, `Rapor_Pengetahuan_${smKey}`);
        allScoreData[`Rapor_Keterampilan_${smKey}`] = getSheetDataAsObject(spreadsheetId, `Rapor_Keterampilan_${smKey}`);
    });
    
    // 3. Ambil SEMUA mata pelajaran dari sheet pengguna untuk ditampilkan di grafik
    const subjectsToChart = getMapel(spreadsheetId);

    if (!subjectsToChart || subjectsToChart.length === 0) {
      return { status: 'nodata', message: 'Tidak ada mata pelajaran yang ditemukan untuk dibuatkan grafik.' };
    }

    // 4. Proses data untuk setiap mapel dan semester
    const datasets = [];
    // Palet warna yang lebih besar untuk memastikan keunikan warna
    const colorPalette = [
        '#3B82F6', '#10B981', '#EF4444', '#F97316', '#8B5CF6', '#EC4899', 
        '#6366F1', '#F59E0B', '#14B8A6', '#65A30D', '#A855F7', '#D97706', 
        '#06B6D4', '#F472B6', '#4B5563', '#059669', '#DB2777', '#7C3AED'
    ];

    subjectsToChart.forEach((mapel, index) => {
      const subjectData = [];
      let hasAnyGrade = false;

      semestersForJenjang.forEach(smKey => {
        const scoresP = (allScoreData[`Rapor_Pengetahuan_${smKey}`] || {})[nisn] || {};
        const scoresK = (allScoreData[`Rapor_Keterampilan_${smKey}`] || {})[nisn] || {};
        
        const nilaiP = parseFloat(scoresP[mapel.kode]);
        const nilaiK = parseFloat(scoresK[mapel.kode]);
        
        let avgScore = null;
        if (!isNaN(nilaiP) && !isNaN(nilaiK)) {
          avgScore = (nilaiP + nilaiK) / 2;
          hasAnyGrade = true;
        } else if (!isNaN(nilaiP)) {
          avgScore = nilaiP;
          hasAnyGrade = true;
        } else if (!isNaN(nilaiK)) {
          avgScore = nilaiK;
          hasAnyGrade = true;
        }
        subjectData.push(avgScore);
      });
      
      if (hasAnyGrade) {
        const colorIndex = index % colorPalette.length; // Gunakan modulo untuk mencegah error jika mapel > warna
        datasets.push({
          label: mapel.nama,
          data: subjectData,
          borderColor: colorPalette[colorIndex],
          backgroundColor: colorPalette[colorIndex] + '33', // Warna transparan untuk area di bawah garis
          fill: false,
          tension: 0.1
        });
      }
    });

    if (datasets.length === 0) {
       return { status: 'nodata', message: 'Siswa ini belum memiliki nilai rapor untuk mata pelajaran yang ada.' };
    }

    const semesterLabels = semestersForJenjang.map(key => key.replace('k','Kls ').replace('_',' '));

    return {
      status: 'success',
      labels: semesterLabels,
      datasets: datasets
    };

  } catch (e) {
    Logger.log("Error in getStudentGradeProgress: " + e.message + " Stack: " + e.stack);
    return { status: 'error', message: 'Gagal mengambil data grafik: ' + e.message };
  }
}

// ===== TAMBAHKAN DUA FUNGSI BARU INI DI BAGIAN SUPERADMIN PADA Kode.gs =====

/**
 * [SUPERADMIN] Membuat Kode Sekolah unik untuk satu pengguna tertentu.
 * @param {string} adminEmail Email Superadmin untuk verifikasi.
 * @param {number} targetUserRow Nomor baris pengguna yang akan dibuatkan kode.
 * @returns {object} Hasil operasi berisi status dan kode baru jika berhasil.
 */
function generateSchoolCodeForSingleUser_Superadmin(adminEmail, targetUserRow) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);

    const codeCell = userSheet.getRange(targetUserRow, 13); // Kolom M

    if (codeCell.getValue()) {
      return { status: "info", message: "Pengguna ini sudah memiliki Kode Sekolah." };
    }

    const allExistingCodes = userSheet.getLastRow() > 1 
      ? userSheet.getRange(2, 13, userSheet.getLastRow() - 1, 1).getValues().flat().filter(Boolean)
      : [];

    let newCode;
    let isCodeUnique = false;
    while (!isCodeUnique) {
      newCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      if (!allExistingCodes.includes(newCode)) {
        isCodeUnique = true;
      }
    }
    
    codeCell.setValue(newCode);
    SpreadsheetApp.flush(); // Pastikan perubahan segera tersimpan

    return { status: "success", message: `Kode ${newCode} berhasil dibuat.` };

  } catch (e) {
    Logger.log("generateSchoolCodeForSingleUser_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal membuat kode: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [AKSI MASSAL SUPERADMIN] Membuat Kode Sekolah untuk beberapa akun terpilih yang belum memilikinya.
 * @param {string} adminEmail Email Superadmin untuk verifikasi.
 * @param {Array<number>} rowNumbers Array nomor baris akun yang akan diproses.
 * @returns {object} Hasil operasi.
 */
function bulkGenerateSchoolCodes_Superadmin(adminEmail, rowNumbers) {
  if (!isSuperadmin(adminEmail)) return { status: "error", message: "Akses ditolak." };
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) throw new Error("Sheet Pengguna tidak ditemukan.");
    
    let generatedCount = 0;
    const allUserData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
    const existingCodes = new Set(allUserData.map(row => row[12]).filter(Boolean));

    rowNumbers.forEach(rowNum => {
      const arrayIndex = rowNum - 2; // Konversi nomor baris ke indeks array
      if (allUserData[arrayIndex] && !allUserData[arrayIndex][12]) { // Cek jika data ada dan kode kosong
        let newCode;
        let isCodeUnique = false;
        while (!isCodeUnique) {
          newCode = Math.random().toString(36).substring(2, 8).toUpperCase();
          if (!existingCodes.has(newCode)) {
            isCodeUnique = true;
          }
        }
        
        userSheet.getRange(rowNum, 13).setValue(newCode);
        existingCodes.add(newCode); // Tambahkan ke Set agar tidak duplikat di iterasi berikutnya
        generatedCount++;
      }
    });

    if (generatedCount > 0) {
      SpreadsheetApp.flush();
    }

    return { status: "success", message: `${generatedCount} kode sekolah baru berhasil dibuat.` };
  } catch (e) {
    Logger.log("bulkGenerateSchoolCodes_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memproses: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [KHUSUS TRIGGER & DENGAN PROPERTIES SERVICE] Menjalankan pembaruan cache akun pengguna.
 * Menyimpan hasil ke Sheet Cache dan PropertiesService.
 */
function runUserCacheUpdateTrigger() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const cacheSheet = ss.getSheetByName(SHEET_CACHE_AKUN);

    if (!userSheet || !cacheSheet) {
      Logger.log("runUserCacheUpdateTrigger: Sheet Pengguna atau Cache Akun tidak ditemukan.");
      return; 
    }

    if (cacheSheet.getLastRow() > 1) {
      cacheSheet.getRange(2, 1, cacheSheet.getLastRow() - 1, cacheSheet.getLastColumn()).clearContent();
    }

    // --- PERBAIKAN 1: BACA HINGGA KOLOM O (15) ---
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 15).getValues();
    const cacheData = [];

    usersData.forEach((row, index) => {
      const email = row[1];
      if (!email || row[0] === 'last_updated') return;

      let currentStudentCount = '-';
      const role = row[6];
      const spreadsheetId = row[5];

      if (role !== 'Superadmin' && spreadsheetId) {
        try {
          const studentSheet = SpreadsheetApp.openById(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
          currentStudentCount = studentSheet ? Math.max(0, studentSheet.getLastRow() - 1) : 0;
        } catch (e) {
          currentStudentCount = 'Error Akses';
        }
      }

      // --- PERBAIKAN 2: Simpan data dari kolom O (indeks 14) ---
      cacheData.push([
        email,            // 1
        row[3],           // 2. Nama Sekolah
        row[4],           // 3. Jenjang
        row[12],          // 4. Kode Sekolah
        row[7],           // 5. Status Akun
        row[8],           // 6. Batas Siswa
        currentStudentCount, // 7
        index + 2,        // 8. Nomor Baris
        role,             // 9. Role
        row[14] || 'TIDAK' // 10. FiturTerkunci dari kolom O
      ]);
    });

    if (cacheData.length > 0) {
      cacheSheet.getRange(2, 1, cacheData.length, cacheData[0].length).setValues(cacheData);
    }

    cacheSheet.appendRow(['last_updated', new Date().toISOString()]);

    try {
        const scriptProperties = PropertiesService.getScriptProperties();
        scriptProperties.setProperty('userManagementCache', JSON.stringify(cacheData));
        Logger.log('Cache Manajemen Akun berhasil disimpan ke PropertiesService.');
    } catch (e) {
        Logger.log('Gagal menyimpan cache Manajemen Akun ke PropertiesService: ' + e.message);
    }

  } catch(e) {
    Logger.log("Error pada runUserCacheUpdateTrigger: " + e.message);
  }
}

/**
 * [FUNGSI INTI BARU] Membangun ulang dan menyimpan data nilai ke sheet yang ditentukan.
 * Fungsi ini menangani data yang datang langsung dari input web.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet tujuan.
 * @param {Array<object>} mapelList Daftar mata pelajaran yang relevan untuk sheet ini.
 * @param {Array<object>} nilaiData Daftar objek nilai dari frontend.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveScoresToSheet(spreadsheetId, sheetName, mapelList, nilaiData) {
  try {
    const ss = getSpreadsheet(spreadsheetId); //
    let sheet = ss.getSheetByName(sheetName); //
    const headers = ["NISN", "Nama Lengkap", ...mapelList.map(m => m.kode)]; //

    // Buat sheet jika belum ada
    if (!sheet) {
      sheet = ss.insertSheet(sheetName); //
    }

    // 1. Dapatkan daftar siswa utama sebagai sumber kebenaran
    const students = getStudents(spreadsheetId); //
    if (!students || students.length === 0) {
      return { status: 'error', message: 'Tidak ada data siswa. Harap isi data siswa terlebih dahulu.' };
    }

    // 2. Ubah array nilai dari input menjadi Map untuk pencarian cepat
    const nilaiDataMap = new Map();
    nilaiData.forEach(n => {
      if (n.nisn) {
        nilaiDataMap.set(n.nisn.toString(), n.scores);
      }
    });

    // 3. Bangun kembali seluruh data yang akan ditulis
    const finalDataToWrite = [];
    students.forEach(student => {
      const nisn = student.nisn.toString();
      const studentScores = nilaiDataMap.get(nisn) || {}; // Ambil skor dari input, atau objek kosong jika tidak ada
      const newRow = [student.nisn, student.nama];

      mapelList.forEach(mapel => {
        // Gunakan nilai dari input jika ada, jika tidak, biarkan kosong
        const score = studentScores[mapel.kode] !== undefined ? studentScores[mapel.kode] : '';
        newRow.push(score);
      });
      finalDataToWrite.push(newRow);
    });

    // 4. Hapus semua data lama dan tulis kembali dengan data yang baru dan lengkap
    sheet.clear();
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold"); //
    sheet.getRange("A:A").setNumberFormat('@'); //
    
    if (finalDataToWrite.length > 0) {
      sheet.getRange(2, 1, finalDataToWrite.length, headers.length).setValues(finalDataToWrite); //
    }

    SpreadsheetApp.flush();
    return { status: 'success', message: `Data nilai untuk sheet '${sheetName}' berhasil disimpan.` }; //

  } catch (e) {
    Logger.log(e);
    return { status: 'error', message: `Gagal menyimpan data: ${e.message}` }; //
  }
}

// Tambahkan dua fungsi baru ini di bagian mana saja di dalam file

/**
 * [BARU] Menerima dan menyimpan saran dari pengguna ke dalam sheet.
 * @param {string} userEmail Email pengguna yang mengirim.
 * @param {object} saranData Objek berisi {judul, penjelasan}.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function submitSaran(userEmail, saranData) {
  try {
    const { judul, penjelasan } = saranData;
    if (!userEmail || !judul || !penjelasan) {
      throw new Error("Data tidak lengkap.");
    }
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let saranSheet = ss.getSheetByName(SHEET_SARAN);

    if (!saranSheet) {
      saranSheet = ss.insertSheet(SHEET_SARAN);
      const headers = ["Saran ID", "Email Pengguna", "Tanggal", "Judul", "Pesan", "Status", "Balasan Admin", "Tanggal Balasan"];
      saranSheet.appendRow(headers);
      saranSheet.getRange("A1:H1").setFontWeight("bold");
    }

    const saranId = Utilities.getUuid();
    saranSheet.appendRow([
      saranId, userEmail, new Date(), judul, penjelasan, "Baru", "", ""
    ]);

    return { status: "success", message: "Saran Anda telah berhasil dikirim. Terima kasih atas masukannya!" };
  } catch (e) {
    Logger.log("submitSaran Error: " + e.message);
    return { status: "error", message: "Gagal mengirim saran: " + e.message };
  }
}

/**
 * [BARU] Mengambil riwayat saran dan balasan untuk pengguna tertentu.
 * @param {string} userEmail Email pengguna yang sedang login.
 * @returns {Array<object>} Array objek riwayat saran.
 */
function getSaranForUser(userEmail) {
  try {
    if (!userEmail) return [];

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return [];
    }
    
    const data = saranSheet.getDataRange().getValues();
    const headers = data.shift(); // Ambil header untuk mapping
    const emailIndex = headers.indexOf("Email Pengguna");

    const history = data
      .filter(row => row[emailIndex] === userEmail)
      .map(row => ({
        id: row[headers.indexOf("Saran ID")],
        tanggal: row[headers.indexOf("Tanggal")].toISOString(),
        judul: row[headers.indexOf("Judul")],
        pesan: row[headers.indexOf("Pesan")],
        status: row[headers.indexOf("Status")],
        balasanAdmin: row[headers.indexOf("Balasan Admin")],
        tanggalBalasan: row[headers.indexOf("Tanggal Balasan")] ? row[headers.indexOf("Tanggal Balasan")].toISOString() : null
      }))
      .sort((a, b) => new Date(b.tanggal) - new Date(a.tanggal)); // Urutkan dari terbaru

    return history;
  } catch (e) {
    Logger.log("getSaranForUser Error: " + e.message);
    return []; // Kembalikan array kosong jika error
  }
}

// File: Kode.gs.html

/**
 * [SUPERADMIN] Mengambil semua saran yang masuk dari semua pengguna.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek data saran, diurutkan berdasarkan status dan tanggal.
 */
function getAllSaran_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return [];
    }

    const data = saranSheet.getDataRange().getValues();
    const headers = data.shift();
    
    const history = data.map(row => ({
        id: row[headers.indexOf("Saran ID")],
        userEmail: row[headers.indexOf("Email Pengguna")],
        tanggal: row[headers.indexOf("Tanggal")].toISOString(),
        judul: row[headers.indexOf("Judul")],
        pesan: row[headers.indexOf("Pesan")],
        status: row[headers.indexOf("Status")],
        balasanAdmin: row[headers.indexOf("Balasan Admin")],
        tanggalBalasan: row[headers.indexOf("Tanggal Balasan")] ? row[headers.indexOf("Tanggal Balasan")].toISOString() : null
    }));
    
    // Urutkan: Tampilkan status "Baru" di atas, lalu urutkan berdasarkan tanggal terbaru
    history.sort((a, b) => {
        if (a.status === 'Baru' && b.status !== 'Baru') return -1;
        if (a.status !== 'Baru' && b.status === 'Baru') return 1;
        return new Date(b.tanggal) - new Date(a.tanggal);
    });

    return history;
  } catch (e) {
    Logger.log("getAllSaran_Superadmin Error: " + e.message);
    throw new Error("Gagal mengambil data saran: " + e.message);
  }
}

/**
 * [SUPERADMIN] Menyimpan balasan untuk sebuah saran dan mengubah statusnya.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {object} replyData - Objek berisi {saranId, balasanText}.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function replyToSaran_Superadmin(adminEmail, replyData) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try {
    const { saranId, balasanText } = replyData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);

    const idColumn = saranSheet.getRange("A2:A").getValues().flat();
    const rowIndex = idColumn.findIndex(id => id === saranId);

    if (rowIndex === -1) {
      throw new Error("Saran tidak ditemukan.");
    }
    const rowToUpdate = rowIndex + 2;

    // Update kolom Status, Balasan, Tanggal Balasan, dan Status Baca Pengguna
    saranSheet.getRange(rowToUpdate, 6, 1, 4).setValues([
        ['Dibalas', balasanText, new Date(), 'Belum Dibaca']
    ]);

    return { status: "success", message: "Balasan berhasil dikirim." };
  } catch (e) {
    Logger.log("replyToSaran_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal mengirim balasan: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

// ===== AWAL FUNGSI BARU UNTUK BADGE SARAN =====

/**
 * [SUPERADMIN] Menghitung jumlah saran baru yang belum diproses.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {number} Jumlah saran dengan status "Baru".
 */
function getNewSaranCount_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    return 0;
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return 0;
    }
    // Hitung semua baris di kolom F (Status) yang nilainya "Baru"
    const statusColumn = saranSheet.getRange(2, 6, saranSheet.getLastRow() - 1, 1).getValues();
    return statusColumn.filter(row => row[0] === 'Baru').length;
  } catch (e) {
    Logger.log("getNewSaranCount_Superadmin Error: " + e.message);
    return 0;
  }
}

/**
 * [PENGGUNA] Menghitung jumlah balasan dari admin yang belum dibaca oleh pengguna.
 * @param {string} userEmail - Email pengguna yang sedang login.
 * @returns {number} Jumlah saran berstatus "Dibalas" dan "Belum Dibaca".
 */
function getUnreadRepliesCount_User(userEmail) {
  if (!userEmail) return 0;
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return 0;
    }
    // Ambil data: Email (B), Status (F), Status Baca (I)
    const data = saranSheet.getRange(2, 2, saranSheet.getLastRow() - 1, 8).getValues();
    let unreadCount = 0;
    data.forEach(row => {
      const email = row[0]; // Kolom B -> indeks 0
      const status = row[4]; // Kolom F -> indeks 4
      const statusBaca = row[7]; // Kolom I -> indeks 7
      if (email === userEmail && status === 'Dibalas' && statusBaca === 'Belum Dibaca') {
        unreadCount++;
      }
    });
    return unreadCount;
  } catch (e) {
    Logger.log("getUnreadRepliesCount_User Error: " + e.message);
    return 0;
  }
}

/**
 * [PENGGUNA] Menandai semua balasan yang belum dibaca menjadi "Sudah Dibaca".
 * @param {string} userEmail - Email pengguna yang sedang login.
 * @returns {{status: string}} Hasil operasi.
 */
function markAllSaranRepliesAsRead_User(userEmail) {
  if (!userEmail) return { status: 'error' };
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const saranSheet = ss.getSheetByName(SHEET_SARAN);
    if (!saranSheet || saranSheet.getLastRow() < 2) {
      return { status: 'no_data' };
    }
    const data = saranSheet.getRange(2, 1, saranSheet.getLastRow() - 1, 9).getValues();
    const rowsToUpdate = [];
    data.forEach((row, index) => {
      const email = row[1]; // Kolom B -> indeks 1
      const status = row[5]; // Kolom F -> indeks 5
      const statusBaca = row[8]; // Kolom I -> indeks 8
      if (email === userEmail && status === 'Dibalas' && statusBaca === 'Belum Dibaca') {
        // Tandai baris ini untuk diupdate
        rowsToUpdate.push(index + 2); // +2 karena indeks array mulai dari 0 dan data dari baris 2
      }
    });

    // Lakukan update dalam satu batch jika ada yang perlu diubah
    if (rowsToUpdate.length > 0) {
      rowsToUpdate.forEach(rowNum => {
        saranSheet.getRange(rowNum, 9).setValue('Sudah Dibaca'); // Kolom I
      });
    }
    return { status: 'success' };
  } catch (e) {
    Logger.log("markAllSaranRepliesAsRead_User Error: " + e.message);
    return { status: 'error' };
  }
}
// ===== AKHIR FUNGSI BARU UNTUK BADGE SARAN =====

// =================================================================
// [FITUR BARU] FUNGSI PENGATURAN KELULUSAN & TRANSKRIP
// =================================================================

/**
 * [BARU] Helper untuk mencari baris pengaturan atau membuatnya jika tidak ada.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - Objek sheet 'Pengaturan'.
 * @param {string} settingName - Nama pengaturan yang dicari (misal: "KKM Sekolah").
 * @returns {number} Nomor baris dari pengaturan tersebut.
 */
function findOrCreateSettingRow(sheet, settingName) {
    const data = sheet.getRange("A:A").getValues().flat();
    const rowIndex = data.indexOf(settingName);
    if (rowIndex !== -1) {
        return rowIndex + 1; // Mengembalikan nomor baris yang sudah ada
    } else {
        // Jika tidak ditemukan, tambahkan di baris baru dan kembalikan nomor baris terakhir
        sheet.appendRow([settingName, '']);
        return sheet.getLastRow();
    }
}

/**
 * [VERSI FINAL 2.1 - FIX PENYIMPANAN TANGGAL]
 * Menyimpan pengaturan kelulusan dan transkrip.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} settings Objek berisi { announcementDate, showTranscriptGlobal }.
 * @returns {object} Status penyimpanan.
 */
function saveGraduationSettings(spreadsheetId, settings) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        let sheet = ss.getSheetByName(SHEET_PENGATURAN);

        if (!sheet) {
            sheet = ss.insertSheet(SHEET_PENGATURAN);
            sheet.getRange("A1:B1").setValues([['Nama Pengaturan', 'Value']]).setFontWeight('bold');
        }
        
        // ---- AWAL PERBAIKAN PENTING ----
        // Kita tidak perlu lagi menggunakan 'new Date()'. 
        // Langsung simpan string tanggal ISO yang dikirim dari frontend.
        // Google Sheets akan secara otomatis mengenalinya sebagai tanggal.
        if (settings.announcementDate) {
            const row = findOrCreateSettingRow(sheet, "Tanggal Pengumuman Kelulusan");
            sheet.getRange(row, 2).setValue(settings.announcementDate);
        } else {
            // Jika tanggal dikosongkan, hapus nilainya di sheet
            const row = findOrCreateSettingRow(sheet, "Tanggal Pengumuman Kelulusan");
            sheet.getRange(row, 2).clearContent();
        }
        // ---- AKHIR PERBAIKAN PENTING ----

        if (settings.showTranscriptGlobal) {
            const row = findOrCreateSettingRow(sheet, "Tampilkan Transkrip Global");
            sheet.getRange(row, 2).setValue(settings.showTranscriptGlobal);
        }

        return { status: "success", message: "Pengaturan kelulusan berhasil disimpan." };
    } catch (e) {
        Logger.log("saveGraduationSettings Error: " + e.message);
        return { status: "error", message: "Gagal menyimpan pengaturan: " + e.message };
    }
}

/**
 * [BARU] Mengambil pengaturan kelulusan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi pengaturan.
 */
function getGraduationSettings(spreadsheetId) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_PENGATURAN);
        if (!sheet) return { announcementDate: null, showTranscriptGlobal: 'TIDAK' };

        const data = sheet.getDataRange().getValues();
        const settings = { announcementDate: null, showTranscriptGlobal: 'TIDAK' }; // Default values

        data.forEach(row => {
            if (row[0] === "Tanggal Pengumuman Kelulusan" && row[1]) {
                settings.announcementDate = new Date(row[1]).toISOString();
            }
            if (row[0] === "Tampilkan Transkrip Global" && row[1]) {
                settings.showTranscriptGlobal = row[1];
            }
        });
        return { status: 'success', settings: settings };
    } catch (e) {
        return { status: 'error', message: e.message };
    }
}

/**
 * [BARU] Mengatur visibilitas transkrip untuk siswa yang dipilih.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<string>} nisnList Array berisi NISN siswa yang dipilih.
 * @param {string} isVisible Status baru ('YA' atau 'TIDAK').
 * @returns {object} Status operasi.
 */
function setPerStudentTranscriptVisibility(spreadsheetId, nisnList, isVisible) {
    try {
        const sheet = getSpreadsheet(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
        const nisnColumnValues = sheet.getRange(2, 1, sheet.getLastRow() - 1, 1).getValues().flat();
        const visibilityColumnIndex = 12; // Kolom L

        nisnList.forEach(nisn => {
            const rowIndex = nisnColumnValues.indexOf(nisn.toString());
            if (rowIndex !== -1) {
                // rowIndex adalah 0-based dari data, baris aktual di sheet adalah rowIndex + 2
                sheet.getRange(rowIndex + 2, visibilityColumnIndex).setValue(isVisible);
            }
        });
        
        SpreadsheetApp.flush(); // Pastikan perubahan segera disimpan
        return { status: "success", message: `${nisnList.length} data siswa berhasil diupdate.` };
    } catch (e) {
        return { status: "error", message: "Gagal mengupdate visibilitas: " + e.message };
    }
}

/**
 * [SUPERADMIN] Menyimpan pengaturan kelulusan GLOBAL.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {object} settings - Objek berisi { announcementDate }.
 * @returns {object} Status penyimpanan.
 */
function saveGlobalGraduationSettings_Superadmin(adminEmail, settings) {
    if (!isSuperadmin(adminEmail)) {
        return { status: "error", message: "Akses ditolak." };
    }
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        let sheet = ss.getSheetByName(SHEET_PENGATURAN);

        if (!sheet) {
            sheet = ss.insertSheet(SHEET_PENGATURAN);
            sheet.getRange("A1:B1").setValues([['Nama Pengaturan', 'Value']]).setFontWeight('bold');
        }

        if (settings.announcementDate) {
            const row = findOrCreateSettingRow(sheet, "Tanggal Pengumuman Kelulusan Global");
            sheet.getRange(row, 2).setValue(settings.announcementDate);
        } else {
            const row = findOrCreateSettingRow(sheet, "Tanggal Pengumuman Kelulusan Global");
            sheet.getRange(row, 2).clearContent();
        }

        return { status: "success", message: "Pengaturan pengumuman global berhasil disimpan." };
    } catch (e) {
        Logger.log("saveGlobalGraduationSettings_Superadmin Error: " + e.message);
        return { status: "error", message: "Gagal menyimpan pengaturan: " + e.message };
    }
}

/**
 * [PUBLIC] Mengambil pengaturan kelulusan GLOBAL.
 * Fungsi ini dapat diakses tanpa login untuk menampilkan countdown.
 * @returns {object} Objek berisi pengaturan.
 */
function getGlobalGraduationSettings() {
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sheet = ss.getSheetByName(SHEET_PENGATURAN);
        if (!sheet) return { announcementDate: null };

        const data = sheet.getDataRange().getValues();
        const settings = { announcementDate: null }; 

        data.forEach(row => {
            if (row[0] === "Tanggal Pengumuman Kelulusan Global" && row[1]) {
                settings.announcementDate = new Date(row[1]).toISOString();
            }
        });
        return settings;
    } catch (e) {
        // Jika error, kembalikan null agar halaman login tetap tampil
        return { announcementDate: null };
    }
}

/**
 * [BARU] Menghapus aset dokumen tertentu (logo, ttd, atau stempel).
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @param {string} settingKey - Kunci pengaturan yang akan dihapus (misal: 'ID Logo Sekolah').
 * @returns {object} Status penghapusan.
 */
function deleteDocumentAsset(spreadsheetId, settingKey) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
      return { status: 'info', message: 'Tidak ada pengaturan untuk dihapus.' };
    }

    const settingRow = findOrCreateSettingRow(sheet, settingKey);
    const fileIdCell = sheet.getRange(settingRow, 2);
    const fileId = fileIdCell.getValue();

    if (fileId) {
      try {
        DriveApp.getFileById(fileId).setTrashed(true);
      } catch (e) {
        Logger.log(`File dengan ID ${fileId} tidak dapat dihapus (mungkin sudah dihapus manual): ${e.message}`);
      }
      fileIdCell.clearContent(); // Hapus ID dari sel
    }
    
    // Konversi nama kunci menjadi nama yang lebih ramah pengguna untuk pesan sukses
    const assetName = settingKey.replace('ID ', '').replace(' Sekolah', '');
    return { status: 'success', message: `${assetName} berhasil dihapus.` };

  } catch (e) {
    Logger.log('deleteDocumentAsset Error: ' + e.message);
    return { status: 'error', message: 'Gagal menghapus aset: ' + e.message };
  }
}

/**
 * [PUBLIC BARU] Mengambil pengaturan sekolah berdasarkan Kode Sekolah.
 * Fungsi ini digunakan untuk menampilkan countdown per sekolah sebelum login.
 * @param {string} kodeSekolah - Kode unik sekolah yang dimasukkan siswa.
 * @returns {object} Objek berisi nama sekolah dan tanggal pengumuman.
 */
function getSchoolSettingsByCode(kodeSekolah) {
  try {
    if (!kodeSekolah) {
      return { status: "error", message: "Kode Sekolah tidak boleh kosong." };
    }

    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    if (!userSheet || userSheet.getLastRow() < 2) {
      return { status: "error", message: "Sistem tidak dapat menemukan data sekolah." };
    }
    
    // Cari baris yang cocok dengan Kode Sekolah (kolom M, indeks 12)
    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
    const schoolRow = data.find(row => row[12] && row[12].toUpperCase() === kodeSekolah.toUpperCase());

    if (!schoolRow) {
      return { status: "error", message: "Kode Sekolah tidak valid atau tidak ditemukan." };
    }
    
    const spreadsheetId = schoolRow[5]; // Kolom F adalah Spreadsheet ID
    const namaSekolah = schoolRow[3];   // Kolom D adalah Nama Sekolah

    if (!spreadsheetId) {
      return { status: "error", message: "Konfigurasi untuk sekolah ini tidak lengkap." };
    }

    // Ambil pengaturan spesifik sekolah tersebut
    const gradSettingsResponse = getGraduationSettings(spreadsheetId);
    const gradSettings = gradSettingsResponse.settings || { announcementDate: null };

    // [MODIFIKASI] Panggil getDocumentSettings untuk mendapatkan logo
    const docSettingsResponse = getDocumentSettings(spreadsheetId);
    const docSettings = docSettingsResponse.settings || {};

    return {
      status: "success",
      namaSekolah: namaSekolah,
      announcementDate: gradSettings.announcementDate,
      portalLogo: docSettings.portalLogo || null
    };

  } catch (error) {
    Logger.log("getSchoolSettingsByCode Error: " + error.message);
    return { status: "error", message: "Terjadi kesalahan pada server saat memeriksa kode." };
  }
}

// ===== AWAL FITUR BARU: PENGATURAN KOP SURAT =====

// ===== AWAL DARI KODE BARU UNTUK PENYIMPANAN GAMBAR DI DRIVE =====

/**
 * [BARU] Helper untuk mencari atau membuat folder 'Aset Aplikasi' di Google Drive
 * tempat spreadsheet pengguna berada.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {DriveApp.Folder} Objek folder aset.
 */
function getOrCreateAssetFolder(spreadsheetId) {
  try {
    const userSpreadsheetFile = DriveApp.getFileById(spreadsheetId);
    const parentFolder = userSpreadsheetFile.getParents().next();
    const assetFolderName = `_Aset Aplikasi Ijazah [JANGAN DIHAPUS]`;
    
    let assetFolderIterator = parentFolder.getFoldersByName(assetFolderName);

    if (assetFolderIterator.hasNext()) {
      return assetFolderIterator.next();
    } else {
      return parentFolder.createFolder(assetFolderName);
    }
  } catch (e) {
    Logger.log(`Gagal mendapatkan folder induk untuk SS ID: ${spreadsheetId}. Membuat di Root. Error: ${e.message}`);
    const rootFolder = DriveApp.getRootFolder();
    const fallbackFolderName = `_Aset Aplikasi Ijazah - ${spreadsheetId}`;
    let fallbackFolderIterator = rootFolder.getFoldersByName(fallbackFolderName);
    if (fallbackFolderIterator.hasNext()) {
      return fallbackFolderIterator.next();
    } else {
      return rootFolder.createFolder(fallbackFolderName);
    }
  }
}

/**
 * [VERSI BARU] Menyimpan gambar ke Google Drive dan menyimpan ID filenya ke sheet Pengaturan.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @param {object} settings - Objek berisi data gambar Base64 { logo, signature, stamp }.
 * @returns {object} Status penyimpanan.
 */
function saveDocumentSettings(spreadsheetId, settings) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
        sheet = ss.insertSheet(SHEET_PENGATURAN);
        sheet.appendRow(['Nama Pengaturan', 'Value']);
    }

    const assetFolder = getOrCreateAssetFolder(spreadsheetId);

    // Helper untuk menyimpan satu file
    const saveFile = (settingKey, base64Data, fileName) => {
      if (!base64Data) return;

      const decoded = Utilities.base64Decode(base64Data.split(',')[1]);
      const blob = Utilities.newBlob(decoded, MimeType.PNG, fileName);
      
      // Hapus file lama jika ada untuk mencegah penumpukan file
      const oldFileIdRow = findOrCreateSettingRow(sheet, settingKey);
      const oldFileId = sheet.getRange(oldFileIdRow, 2).getValue();
      if (oldFileId) {
        try { DriveApp.getFileById(oldFileId).setTrashed(true); } catch(e) { Logger.log(`File lama ${oldFileId} tidak ditemukan untuk dihapus.`);}
      }

      const newFile = assetFolder.createFile(blob);
      const newFileId = newFile.getId();
      sheet.getRange(oldFileIdRow, 2).setValue(newFileId);
    };

    saveFile('ID Logo Sekolah', settings.logo, 'logo_sekolah.png');
    saveFile('ID Tanda Tangan', settings.signature, 'tanda_tangan.png');
    saveFile('ID Stempel', settings.stamp, 'stempel_sekolah.png');
    saveFile('ID Logo Portal', settings.portalLogo, 'logo_portal.png');
    saveFile('ID Header Kustom', settings.customHeader, 'header_kustom.png');

    return { status: 'success', message: 'Pengaturan kop surat dan tanda tangan berhasil disimpan.' };
  } catch (e) {
    Logger.log('saveDocumentSettings Error: ' + e.message);
    return { status: 'error', message: 'Gagal menyimpan pengaturan dokumen: ' + e.message };
  }
}

/**
 * [VERSI BARU] Mengambil ID file dari sheet Pengaturan, lalu mengambil data gambar
 * dari Google Drive dan mengubahnya menjadi Base64.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {object} Objek berisi data gambar Base64.
 */
/**
 * [VERSI BARU] Mengambil ID file dari sheet Pengaturan, lalu mengambil data gambar
 * dari Google Drive dan mengubahnya menjadi Base64.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {object} Objek berisi data gambar Base64.
 */
function getDocumentSettings(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    // [PERBAIKAN UTAMA] Pastikan semua properti diinisialisasi sebagai null
    const settings = { logo: null, signature: null, stamp: null, portalLogo: null, customHeader: null };
    if (!sheet) return { status: 'success', settings: settings };
    
    const data = sheet.getDataRange().getValues();
    
    const settingsMap = new Map(data.map(row => [row[0], row[1]]));

    const getBase64 = (fileId) => {
      if (!fileId) return null;
      try {
        const file = DriveApp.getFileById(fileId);
        return `data:image/png;base64,${Utilities.base64Encode(file.getBlob().getBytes())}`;
      } catch (e) {
        Logger.log(`Gagal mengambil file gambar dengan ID ${fileId}: ${e.message}`);
        return null;
      }
    };
    
    // Ambil nilai untuk setiap pengaturan
    settings.logo = getBase64(settingsMap.get('ID Logo Sekolah'));
    settings.signature = getBase64(settingsMap.get('ID Tanda Tangan'));
    settings.stamp = getBase64(settingsMap.get('ID Stempel'));
    settings.portalLogo = getBase64(settingsMap.get('ID Logo Portal'));
    settings.customHeader = getBase64(settingsMap.get('ID Header Kustom'));

    return { status: 'success', settings: settings };
  } catch (e) {
    Logger.log('getDocumentSettings Error: ' + e.message);
    return { status: 'error', settings: {} };
  }
}

//=================================================================
// [BARU] FUNGSI UNTUK VALIDASI QR CODE
//=================================================================

/**
 * [HELPER] Membuat token validasi yang aman dan berbatas waktu.
 * Token ini mengenkripsi NISN dan ID Spreadsheet.
 * @param {string} nisn - NISN siswa.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @returns {string} Token yang sudah dienkripsi dan di-encode.
 */
function generateValidationToken(nisn, spreadsheetId) {
    const payload = JSON.stringify({
        nisn: nisn,
        ssId: spreadsheetId,
        exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 365) // Token berlaku 1 tahun
    });
    // Menggunakan TextCipher untuk enkripsi sederhana (bukan JWT sejati, tapi cukup untuk tujuan ini)
    const encrypted = Utilities.base64Encode(Utilities.newBlob(payload).getBytes());
    return encrypted;
}

/**
 * [PUBLIC - MODIFIKASI] Mengambil data validasi, sekarang termasuk Nama Sekolah.
 * @param {string} token - Token yang di-scan dari QR code.
 * @returns {object} Objek berisi data siswa dan sekolah jika valid.
 */
function getValidationData(token) {
    try {
        const decodedPayload = Utilities.newBlob(Utilities.base64Decode(token)).getDataAsString();
        const payload = JSON.parse(decodedPayload);

        // Validasi kadaluwarsa token
        if (payload.exp < Math.floor(Date.now() / 1000)) {
            return { status: 'error', message: 'Token validasi telah kedaluwarsa.' };
        }

        // --- AWAL PERUBAHAN ---
        // 1. Ambil data sekolah menggunakan ID dari token
        const schoolData = getSchoolData(payload.ssId);
        if (!schoolData || !schoolData.namaSekolah) {
            return { status: 'error', message: 'Data sekolah tidak dapat ditemukan.' };
        }
        // --- AKHIR PERUBAHAN ---

        const student = getStudents(payload.ssId).find(s => s.nisn === payload.nisn);
        if (!student) {
            return { status: 'error', message: 'Data siswa tidak ditemukan.' };
        }

        const rekapIjazah = getSheetDataAsObject(payload.ssId, SHEET_REKAP_IJAZAH);
        const studentRekap = rekapIjazah[student.nisn] || {};
        const rataRata = studentRekap['Rata-rata'] !== undefined ? parseFloat(studentRekap['Rata-rata']).toFixed(2) : 'N/A';
        
        return {
            status: 'success',
            data: {
                namaSekolah: schoolData.namaSekolah.toUpperCase(), // Tambahkan nama sekolah ke data
                nisn: student.nisn,
                namaLengkap: student.nama.toUpperCase(),
                rataRataIjazah: rataRata
            }
        };
    } catch (e) {
        Logger.log("getValidationData Error: " + e.message);
        return { status: 'error', message: 'Token tidak valid atau rusak.' };
    }
}

/**
 * [MODIFIKASI] Mengubah fungsi QR Code untuk menyematkan URL validasi dengan token.
 */
function getQrCodeAsBase64(nisn, spreadsheetId) {
  try {
    const token = generateValidationToken(nisn, spreadsheetId);
    // URL ini harus memiliki ?page=validasi dan &token=...
    const validationUrl = `${ScriptApp.getService().getUrl()}?page=validasi&token=${token}`;
    
    // Menggunakan resolusi yang lebih baik dan tingkat koreksi error Medium
    const qrCodeApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(validationUrl)}&ecc=M&margin=1`;

    const qrCodeBlob = UrlFetchApp.fetch(qrCodeApiUrl).getBlob();
    return Utilities.base64Encode(qrCodeBlob.getBytes());
  } catch (e) {
    Logger.log("Gagal membuat QR Code Base64: " + e.message);
    return null;
  }
}

/**
 * [VERSI FINAL] Membandingkan nilai JUMLAH ijazah yang dihitung secara live
 * dengan nilai JUMLAH yang tersimpan di sheet rekapitulasi untuk deteksi yang lebih akurat.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {{needsUpdate: boolean}} Objek yang berisi status apakah rekap perlu diperbarui.
 */
function checkRekapSyncStatus(spreadsheetId) {
  try {
    // 1. Ambil data rekap yang tersimpan saat ini
    const storedRekapData = getSheetDataAsObject(spreadsheetId, SHEET_REKAP_IJAZAH);

    // 2. Lakukan perhitungan live
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) return { needsUpdate: false }; 

    const mapel = getMapel(spreadsheetId);
    if (!mapel || mapel.length === 0) return { needsUpdate: false };

    const bobot = getBobot(spreadsheetId);
    const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang;
    if (!jenjang) return { needsUpdate: true }; 

    const semesterKeys = { MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'], MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'], MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil'] };
    const semestersForJenjang = semesterKeys[jenjang] || [];

    const sheetsToRead = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK, ...semestersForJenjang.flatMap(smKey => [`Rapor_Pengetahuan_${smKey}`, `Rapor_Keterampilan_${smKey}`])];
    const allData = {};
    sheetsToRead.forEach(sheetName => { allData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName); });

    // 3. Bandingkan nilai untuk setiap siswa
    for (const student of students) {
        const nisn = student.nisn.toString().trim();
        const storedStudentData = storedRekapData[nisn];
        
        // Jika data siswa tidak ada di rekap, berarti perlu update
        if (!storedStudentData) {
          Logger.log(`Siswa baru ditemukan (${nisn}), rekap perlu diupdate.`);
          return { needsUpdate: true };
        }

        let liveTotalNilaiIjazah = 0;

        mapel.forEach(m => {
            const kode = m.kode;
            const nilaiUM = parseFloat((allData[SHEET_NILAI_UJIAN_MADRASAH][nisn] || {})[kode]);
            const nilaiUP = parseFloat((allData[SHEET_NILAI_UJIAN_PRAKTEK][nisn] || {})[kode]);

            let rataUjian = null;
            if (!isNaN(nilaiUM) && !isNaN(nilaiUP)) rataUjian = (nilaiUM + nilaiUP) / 2;
            else if (!isNaN(nilaiUM)) rataUjian = nilaiUM;
            else if (!isNaN(nilaiUP)) rataUjian = nilaiUP;
            
            let totalNilaiRapor = 0;
            let semesterCount = 0;
            semestersForJenjang.forEach(smKey => {
                const nilaiP = parseFloat(((allData[`Rapor_Pengetahuan_${smKey}`] || {})[nisn] || {})[kode]);
                const nilaiK = parseFloat(((allData[`Rapor_Keterampilan_${smKey}`] || {})[nisn] || {})[kode]);
                if (!isNaN(nilaiP) && !isNaN(nilaiK)) { totalNilaiRapor += (nilaiP + nilaiK) / 2; semesterCount++; }
                else if (!isNaN(nilaiP)) { totalNilaiRapor += nilaiP; semesterCount++; }
                else if (!isNaN(nilaiK)) { totalNilaiRapor += nilaiK; semesterCount++; }
            });
            const rataRapor = semesterCount > 0 ? totalNilaiRapor / semesterCount : null;

            if (rataUjian !== null || rataRapor !== null) {
                const finalRataUjian = rataUjian !== null ? rataUjian : 0;
                const finalRataRapor = rataRapor !== null ? rataRapor : 0;
                const nilaiIjazah = (finalRataUjian * (bobot.bobotUjian / 100)) + (finalRataRapor * (bobot.bobotRapor / 100));
                // Nilai total adalah penjumlahan dari setiap nilai ijazah yang DIBULATKAN
                liveTotalNilaiIjazah += Math.round(nilaiIjazah);
            }
        });
        
        // [PERUBAHAN UTAMA] Bandingkan nilai 'Jumlah' (bilangan bulat)
        const storedTotal = parseInt(storedStudentData['Jumlah']) || 0;

        if (liveTotalNilaiIjazah !== storedTotal) {
            Logger.log(`Data tidak sinkron untuk NISN ${nisn}. Live Total: ${liveTotalNilaiIjazah}, Stored Total: ${storedTotal}`);
            return { needsUpdate: true }; // Ditemukan perbedaan, langsung hentikan dan kirim status
        }
    }
    
    // Jika loop selesai tanpa menemukan perbedaan, data sudah sinkron
    return { needsUpdate: false };
  } catch (e) {
    Logger.log("Error di checkRekapSyncStatus: " + e.message);
    return { needsUpdate: true }; // Jika terjadi error, lebih aman untuk menampilkan notifikasi
  }
}

// ===== AWAL KODE BARU UNTUK DATABASE WILAYAH DARI SHEET =====

// HAPUS FUNGSI getWilayahData_, getProvinsiList, getKabupatenList, dll. LAMA
// GANTI DENGAN SATU FUNGSI BARU INI

function getWilayahData() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Data Wilayah"); // Pastikan nama sheet sudah benar
    if (!sheet) {
      throw new Error("Sheet 'Data Wilayah' tidak ditemukan.");
    }
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 5).getValues(); // Ambil dari baris 2
    
    // Kelompokkan data untuk mempermudah frontend
    const wilayah = {
      provinsi: {},
      kodepos: {}
    };

    data.forEach(row => {
      const [prov, kab, kec, kel, pos] = row;
      
      if (!wilayah.provinsi[prov]) wilayah.provinsi[prov] = {};
      if (!wilayah.provinsi[prov][kab]) wilayah.provinsi[prov][kab] = {};
      if (!wilayah.provinsi[prov][kab][kec]) wilayah.provinsi[prov][kab][kec] = [];
      
      wilayah.provinsi[prov][kab][kec].push(kel);
      
      // Buat peta kodepos untuk pencarian cepat
      const key = `${prov}-${kab}-${kec}-${kel}`;
      wilayah.kodepos[key] = pos;
    });

    return { status: 'success', data: wilayah };

  } catch (e) {
    Logger.log("Error di getWilayahData: " + e.message);
    return { status: 'error', message: e.message };
  }
}

// Fungsi yang akan dipanggil dari frontend untuk mendapatkan daftar provinsi unik
function getProvinsiList() {
  try {
    const data = getWilayahData_();
    const provinsiSet = new Set(data.map(item => item.provinsi));
    return [...provinsiSet].sort();
  } catch (e) {
    return { error: e.message };
  }
}

// Fungsi untuk mendapatkan daftar kabupaten berdasarkan provinsi
function getKabupatenList(provinsi) {
  try {
    const data = getWilayahData_();
    const kabupatenSet = new Set(
      data
        .filter(item => item.provinsi === provinsi)
        .map(item => item.kabupaten)
    );
    return [...kabupatenSet].sort();
  } catch (e) {
    return { error: e.message };
  }
}

// Fungsi untuk mendapatkan daftar kecamatan berdasarkan kabupaten
function getKecamatanList(provinsi, kabupaten) {
  try {
    const data = getWilayahData_();
    const kecamatanSet = new Set(
      data
        .filter(item => item.provinsi === provinsi && item.kabupaten === kabupaten)
        .map(item => item.kecamatan)
    );
    return [...kecamatanSet].sort();
  } catch (e) {
    return { error: e.message };
  }
}

// Fungsi untuk mendapatkan daftar kelurahan berdasarkan kecamatan
function getKelurahanList(provinsi, kabupaten, kecamatan) {
  try {
    const data = getWilayahData_();
    const kelurahanData = data
      .filter(item => item.provinsi === provinsi && item.kabupaten === kabupaten && item.kecamatan === kecamatan)
      .map(item => ({ nama: item.kelurahan, kodepos: item.kodepos }));
    return kelurahanData.sort((a, b) => a.nama.localeCompare(b.nama));
  } catch (e) {
    return { error: e.message };
  }
}

// ===== AWAL KODE FITUR LOCK & DONASI =====

// --- FUNGSI UNTUK SUPERADMIN ---

/**
 * [SUPERADMIN] Mengunci atau membuka fitur untuk pengguna tertentu.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {string} targetUserEmail - Email pengguna yang akan diubah statusnya.
 * @param {boolean} isLocked - true untuk mengunci, false untuk membuka.
 * @returns {object} Hasil operasi.
 */
function setFiturLock_Superadmin(adminEmail, targetUserEmail, isLocked) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const emailColumn = userSheet.getRange("B2:B").getValues().flat();
    const userIndex = emailColumn.findIndex(email => email && email.toLowerCase() === targetUserEmail.toLowerCase());

    if (userIndex === -1) {
      throw new Error("Pengguna tidak ditemukan.");
    }
    const rowToUpdate = userIndex + 2;
    // Asumsi kolom FiturTerkunci adalah kolom ke-15 (O)
    userSheet.getRange(rowToUpdate, 15).setValue(isLocked ? 'YA' : 'TIDAK');
    
    const action = isLocked ? "dikunci" : "dibuka";
    return { status: "success", message: `Fitur untuk akun ${targetUserEmail} berhasil ${action}.` };
  } catch (e) {
    Logger.log("setFiturLock_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal mengubah status fitur: " + e.message };
  }
}

/**
 * [SUPERADMIN] Mengambil daftar semua donasi yang masuk.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @returns {Array<object>} Daftar donasi.
 */
function getDonasiList_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data Donasi");
    if (!sheet || sheet.getLastRow() < 2) return [];
    
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    return data.map(row => ({
      id: row[0],
      tanggal: row[1].toISOString(),
      email: row[2],
      namaSekolah: row[3],
      fileId: row[4],
      fileUrl: row[5],
      status: row[6]
    })).sort((a, b) => new Date(b.tanggal) - new Date(a.tanggal));
  } catch (e) {
    Logger.log("getDonasiList_Superadmin Error: " + e.message);
    return [];
  }
}

/**
 * [SUPERADMIN - DIPERBARUI] Memverifikasi donasi, membuka kunci fitur, DAN menaikkan limit siswa.
 * @param {string} adminEmail - Email Superadmin.
 * @param {string} donasiId - ID donasi yang akan diverifikasi.
 * @param {string} targetUserEmail - Email pengguna yang fiturnya akan dibuka.
 * @returns {object} Hasil operasi.
 */
function verifyDonasi_Superadmin(adminEmail, donasiId, targetUserEmail) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    
    // 1. Ubah status di sheet Data Donasi
    const donasiSheet = ss.getSheetByName("Data Donasi");
    const idColumn = donasiSheet.getRange("A2:A").getValues().flat();
    const donasiRowIndex = idColumn.findIndex(id => id === donasiId);

    if (donasiRowIndex === -1) throw new Error("Donasi tidak ditemukan.");
    
    donasiSheet.getRange(donasiRowIndex + 2, 7).setValue("Terverifikasi");

    // --- AWAL MODIFIKASI ---

    // 2. Temukan pengguna di sheet 'Data Pengguna' untuk update limit
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const userEmailColumn = userSheet.getRange("B2:B").getValues().flat();
    const userRowIndex = userEmailColumn.findIndex(email => email && email.toLowerCase() === targetUserEmail.toLowerCase());

    if (userRowIndex !== -1) {
        const userRowToUpdate = userRowIndex + 2;
        // Kolom I (indeks 9) adalah 'Batas Siswa'
        userSheet.getRange(userRowToUpdate, 9).setValue(500);
    } else {
        Logger.log(`Peringatan: Pengguna ${targetUserEmail} tidak ditemukan untuk update limit saat verifikasi donasi.`);
    }

    // 3. Buka kunci fitur pengguna (fungsi ini sudah ada)
    const unlockResult = setFiturLock_Superadmin(adminEmail, targetUserEmail, false);
    if (unlockResult.status === 'error') throw new Error(unlockResult.message);
    
    // --- AKHIR MODIFIKASI ---

    return { status: "success", message: `Donasi dari ${targetUserEmail} berhasil diverifikasi. Fitur telah dibuka dan limit siswa diatur ke 500.` };

  } catch (e) {
    return { status: "error", message: e.message };
  }
}

/**
 * [AKSI MASSAL SUPERADMIN] Mengunci atau membuka fitur premium untuk beberapa akun sekaligus.
 * @param {string} adminEmail - Email Superadmin untuk verifikasi.
 * @param {Array<number>} rowNumbers - Array berisi nomor baris akun yang akan diubah.
 * @param {boolean} isLocked - true untuk mengunci, false untuk membuka.
 * @returns {object} Hasil operasi.
 */
function bulkSetFiturLock_Superadmin(adminEmail, rowNumbers, isLocked) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  if (!rowNumbers || rowNumbers.length === 0) {
    return { status: "info", message: "Tidak ada akun yang dipilih." };
  }

  try {
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    const newValue = isLocked ? 'YA' : 'TIDAK';
    const lockColumn = 15; // Kolom N untuk 'FiturTerkunci'

    // Lakukan update untuk setiap baris yang dipilih
    rowNumbers.forEach(rowNum => {
      userSheet.getRange(rowNum, lockColumn).setValue(newValue);
    });

    const actionText = isLocked ? "dikunci" : "dibuka";
    return { status: "success", message: `${rowNumbers.length} akun berhasil ${actionText}.` };

  } catch (e) {
    Logger.log("bulkSetFiturLock_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memproses aksi massal: " + e.message };
  }
}


// --- FUNGSI UNTUK PENGGUNA & SISWA ---

/**
 * [HELPER] Fungsi pusat untuk memeriksa apakah fitur pengguna terkunci.
 * @param {string} email - Email pengguna atau spreadsheetId.
 * @returns {{isLocked: boolean, message: string}}
 */
function checkFiturLock(emailOrId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const data = userSheet.getRange("A2:O" + userSheet.getLastRow()).getValues(); // Baca hingga kolom O
    
    let userRow = data.find(row => row[1].toLowerCase() === emailOrId.toLowerCase() || row[5] === emailOrId);
    
    if (userRow) {
      const isLocked = userRow[14] === 'YA'; // Kolom O adalah indeks ke-14
      if (isLocked) {
        return { isLocked: true, message: "Fitur ini terkunci. Silakan lakukan donasi untuk membukanya." };
      }
    }
    return { isLocked: false, message: "" };
  } catch (e) {
    Logger.log("checkFiturLock Error: " + e.message);
    return { isLocked: false, message: "" }; // Default ke tidak terkunci jika ada error
  }
}

/**
 * [PUBLIC] Menerima data form donasi dan file bukti transfer.
 * @param {object} donationData - Data dari form { email, namaSekolah }.
 * @param {object} fileData - Objek file dari frontend.
 * @returns {object} Hasil penyimpanan.
 */
function simpanDonasi(donationData, fileData) {
  try {
    // 1. Buat folder 'Bukti Donasi' jika belum ada di root Drive Anda
    let folder;
    const folders = DriveApp.getFoldersByName("Bukti Donasi Aplikasi Ijazah");
    if (folders.hasNext()) {
      folder = folders.next();
    } else {
      folder = DriveApp.createFolder("Bukti Donasi Aplikasi Ijazah");
    }

    // 2. Simpan file
    const decoded = Utilities.base64Decode(fileData.content.split(',')[1]);
    const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); // Agar admin bisa lihat

    // 3. Simpan data ke sheet 'Data Donasi'
    const donasiSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data Donasi");
    donasiSheet.appendRow([
      Utilities.getUuid(),
      new Date(),
      donationData.email,
      donationData.namaSekolah,
      file.getId(),
      file.getUrl(),
      "Menunggu Verifikasi"
    ]);

    // --- AWAL KODE NOTIFIKASI EMAIL SUPERADMIN ---
    try {
      const superadminEmail = "syamsulbahri.agro27b@gmail.com"; // GANTI DENGAN EMAIL SUPERADMIN ANDA
      const subject = "[Aplikasi Ijazah] Konfirmasi Donasi Baru";
      const body = `
        <p>Halo Superadmin,</p>
        <p>Ada konfirmasi donasi baru yang masuk dari pengguna:</p>
        <ul>
          <li><b>Email Pengguna:</b> ${donationData.email}</li>
          <li><b>Nama Sekolah:</b> ${donationData.namaSekolah}</li>
          <li><b>Tanggal Konfirmasi:</b> ${new Date().toLocaleString('id-ID')}</li>
        </ul>
        <p>Bukti transfer dapat dilihat melalui link di panel Manajemen Donasi.</p>
        <p>Silakan masuk untuk melakukan verifikasi dan membuka fitur premium untuk pengguna tersebut.</p>
        <br>
        <p>Terima kasih.</p>
      `;
      MailApp.sendEmail(superadminEmail, subject, "", { htmlBody: body });
    } catch (e) {
      Logger.log("Gagal mengirim notifikasi email donasi ke Superadmin: " + e.message);
    }
    // --- AKHIR KODE NOTIFIKASI EMAIL SUPERADMIN ---

    return { status: "success", message: "Data donasi dan bukti transfer berhasil dikirim. Admin akan segera memverifikasinya. Terima kasih!" };
  } catch (e) {
    Logger.log("simpanDonasi Error: " + e.message);
    return { status: "error", message: "Gagal menyimpan data donasi: " + e.message };
  }
}

/**
 * [PENGGUNA] Memeriksa status donasi terakhir dari pengguna.
 * @param {string} userEmail - Email pengguna yang akan diperiksa.
 * @returns {object|null} Detail donasi jika ada yang menunggu, atau null jika tidak.
 */
function getDonationStatus_User(userEmail) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data Donasi");
    if (!sheet || sheet.getLastRow() < 2) return null;

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    // Cari dari bawah ke atas untuk mendapatkan data terbaru
    for (let i = data.length - 1; i >= 0; i--) {
      const row = data[i];
      // Cek email dan status
      if (row[2].toLowerCase() === userEmail.toLowerCase() && row[6] === "Menunggu Verifikasi") {
        return {
          id: row[0],
          fileUrl: row[5],
          status: row[6]
        };
      }
    }
    return null; // Tidak ada donasi yang menunggu dari pengguna ini
  } catch (e) {
    Logger.log("getDonationStatus_User Error: " + e.message);
    return null;
  }
}

/**
 * [PENGGUNA] Membatalkan pengajuan donasi dan menghapus file terkait.
 * @param {string} donationId - ID donasi yang akan dibatalkan.
 * @param {string} userEmail - Email pengguna untuk verifikasi kepemilikan.
 * @returns {object} Hasil operasi.
 */
function cancelDonation_User(donationId, userEmail) {
  if (!donationId || !userEmail) {
    return { status: "error", message: "Informasi tidak lengkap." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Data Donasi");
    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn());
    const data = dataRange.getValues();
    
    const rowIndex = data.findIndex(row => row[0] === donationId);

    if (rowIndex === -1) {
      throw new Error("Data donasi tidak ditemukan.");
    }

    const rowData = data[rowIndex];
    const ownerEmail = rowData[2];
    const fileId = rowData[4];

    if (ownerEmail.toLowerCase() !== userEmail.toLowerCase()) {
      throw new Error("Anda tidak memiliki izin untuk membatalkan donasi ini.");
    }
    
    // Hapus file dari Google Drive
    if (fileId) {
      try {
        DriveApp.getFileById(fileId).setTrashed(true);
      } catch (driveError) {
        Logger.log(`Gagal menghapus file di Drive (ID: ${fileId}): ${driveError.message}`);
        // Tetap lanjutkan proses hapus data di sheet
      }
    }
    
    // Hapus baris dari sheet
    sheet.deleteRow(rowIndex + 2); // +2 karena data dimulai dari baris 2 dan indeks array dari 0

    return { status: "success", message: "Konfirmasi donasi berhasil dibatalkan." };

  } catch (e) {
    Logger.log("cancelDonation_User Error: " + e.message);
    return { status: "error", message: "Gagal membatalkan donasi: " + e.message };
  } finally {
    lock.releaseLock();
  }
}
// ===== AKHIR KODE FITUR LOCK & DONASI =====

/**
 * [BARU] Memulai proses pengarsipan tahunan.
 * @param {string} spreadsheetId ID spreadsheet pengguna.
 * @param {string} userEmail Email pengguna untuk pengiriman notifikasi.
 * @returns {object} Hasil dari proses pengarsipan.
 */
function prosesArsipTahunan(spreadsheetId, userEmail) {
  const FOLDER_ARSIP_NAME = "Arsip Aplikasi Ijazah";
  const now = new Date();
  const timestamp = Utilities.formatDate(now, Session.getScriptTimeZone(), "yyyy-MM-dd");

  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const schoolName = ss.getSheetByName(SHEET_DATA_SEKOLAH).getRange("B2").getValue() || "Data Sekolah";
    const archiveFileName = `[ARSIP ${timestamp}] - ${schoolName}`;

    // 1. Dapatkan folder induk dari spreadsheet pengguna
    const fileInduk = DriveApp.getFileById(spreadsheetId);
    const folderInduk = fileInduk.getParents().next();

    // 2. Cari atau buat folder "Arsip Aplikasi Ijazah"
    let folderArsip = folderInduk.getFoldersByName(FOLDER_ARSIP_NAME);
    if (folderArsip.hasNext()) {
      folderArsip = folderArsip.next();
    } else {
      folderArsip = folderInduk.createFolder(FOLDER_ARSIP_NAME);
    }

    // 3. Salin spreadsheet saat ini sebagai file arsip
    const fileArsip = fileInduk.makeCopy(archiveFileName, folderArsip);
    const urlArsip = fileArsip.getUrl();

    // ==========================================================
    // === PERUBAHAN UTAMA ADA DI SINI ===
    // Menambahkan pengguna sebagai editor pada file arsip yang baru dibuat.
    fileArsip.addEditor(userEmail);
    // ==========================================================

    // 4. Kirim email notifikasi ke pengguna dengan link file arsip
    const subject = `Arsip Tahunan Aplikasi Ijazah Telah Selesai`;
    const body = `
      <p>Halo,</p>
      <p>Proses pengarsipan data untuk sekolah <b>${schoolName}</b> telah berhasil diselesaikan pada ${now.toLocaleString('id-ID')}.</p>
      <p>File arsip Anda dapat diakses melalui link berikut:</p>
      <p><a href="${urlArsip}" style="font-size: 16px; font-weight: bold;">Buka File Arsip</a></p>
      <p>Data pada aplikasi utama Anda telah dibersihkan untuk tahun ajaran berikutnya. Harap simpan email ini dengan baik.</p>
      <br>
      <p>Terima kasih.</p>
    `;
    MailApp.sendEmail(userEmail, subject, "", { htmlBody: body });

    // 5. Bersihkan data di spreadsheet utama (LIVE)
    const sheetsToClear = [
      SHEET_DATA_SISWA, SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK,
      SHEET_REKAP_UJIAN, SHEET_REKAP_RAPOR, SHEET_REKAP_IJAZAH
      // Tambahkan sheet nilai rapor per semester jika perlu
    ];
    
    // Logika untuk membersihkan sheet rapor per semester
    const jenjang = ss.getSheetByName(SHEET_DATA_SEKOLAH).getRange("A2").getValue();
    const semesterKeys = { MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'], MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'], MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil'] };
    if (semesterKeys[jenjang]) {
        semesterKeys[jenjang].forEach(key => {
            sheetsToClear.push(`Rapor_Pengetahuan_${key}`);
            sheetsToClear.push(`Rapor_Keterampilan_${key}`);
        });
    }

    sheetsToClear.forEach(sheetName => {
      const sheet = ss.getSheetByName(sheetName);
      if (sheet && sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
      }
    });

    return { status: 'success', message: 'Proses arsip berhasil! File telah disimpan di Google Drive dan link dikirim ke email Anda. Data di aplikasi telah dibersihkan.', fileUrl: urlArsip };

  } catch (e) {
    Logger.log(`Proses Arsip Gagal: ${e.toString()}`);
    return { status: 'error', message: `Terjadi kesalahan saat proses pengarsipan: ${e.message}` };
  }
}

// Kode.gs: Fungsi baru untuk menyimpan dan mengambil pengaturan

/**
 * [MODIFIKASI] Menyimpan pengaturan cetak transkrip ke dalam sheet 'Pengaturan'
 * di spreadsheet pengguna.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @param {object} settings - Objek berisi pengaturan cetak.
 * @returns {{status: string, message: string}} Hasil operasi.
 */
function savePrintSettings(spreadsheetId, settings) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
        sheet = ss.insertSheet(SHEET_PENGATURAN);
        sheet.appendRow(['Nama Pengaturan', 'Value']);
    }

    // Menggunakan helper yang sudah ada untuk mencari atau membuat baris pengaturan
    const findAndSet = (key, value) => {
        const row = findOrCreateSettingRow(sheet, key);
        sheet.getRange(row, 2).setValue(value);
    };

    findAndSet('Cetak - Tahun Ajaran', settings.tahunAjaran);
    findAndSet('Cetak - Tempat TTD', settings.tempatTtd);
    findAndSet('Cetak - Tanggal TTD', settings.tanggalTtd);
    findAndSet('Cetak - Tampilkan QR', settings.showQRCode ? 'YA' : 'TIDAK'); // Simpan sebagai YA/TIDAK

    return { status: 'success', message: 'Pengaturan berhasil disimpan di spreadsheet.' };
  } catch (e) {
    Logger.log("savePrintSettings Error: " + e.message);
    return { status: 'error', message: 'Gagal menyimpan pengaturan ke spreadsheet.' };
  }
}

/**
 * [MODIFIKASI] Mengambil pengaturan cetak dari sheet 'Pengaturan'.
 * @param {string} spreadsheetId - ID spreadsheet pengguna.
 * @returns {{status: string, settings?: object}} Hasil operasi.
 */
function getPrintSettings(spreadsheetId) {
  // Fungsi ini dibuat agar bisa dipanggil dari Index.html (admin) dan Siswa.html (publik)
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    const settings = {
        tahunAjaran: '',
        tempatTtd: '',
        tanggalTtd: '',
        showQRCode: true 
    };

    if (sheet) {
        const data = sheet.getDataRange().getValues();
        const settingsMap = new Map(data.map(row => [row[0], row[1]]));
        
        settings.tahunAjaran = settingsMap.get('Cetak - Tahun Ajaran') || '';
        settings.tempatTtd = settingsMap.get('Cetak - Tempat TTD') || '';
        const tgl = settingsMap.get('Cetak - Tanggal TTD');
        settings.tanggalTtd = (tgl instanceof Date) ? Utilities.formatDate(tgl, Session.getScriptTimeZone(), "yyyy-MM-dd") : '';
        settings.showQRCode = settingsMap.get('Cetak - Tampilkan QR') !== 'TIDAK';
    }
    
    return { status: 'success', settings: settings };
  } catch (e) {
    Logger.log("getPrintSettings Error: " + e.message);
    return { status: 'error', message: 'Gagal memuat pengaturan.' };
  }
}

/**
 * [FUNGSI BARU] Membangun halaman validasi HTML lengkap secara dinamis.
 * Ini menggantikan kebutuhan akan file Validasi.html.
 * @param {string} token - Token validasi yang diambil dari URL.
 * @returns {HtmlService.HtmlOutput} Halaman HTML yang siap ditampilkan.
 */
function buildValidationPage(token) {
  // Menggunakan template literal untuk membuat string HTML
  const html = `
    <!DOCTYPE html>
    <html lang="id">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Validasi Transkrip Nilai</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            body { background-color: #f3f4f6; }
            .loading-animation::after {
                display: inline-block;
                animation: loading-dots 1.4s infinite;
                content: '.';
                width: 1em;
                text-align: left;
            }
            @keyframes loading-dots {
                0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; }
            }
        </style>
    </head>
    <body class="flex items-center justify-center min-h-screen p-4">
        <div id="app" class="w-full max-w-2xl mx-auto">
            <div class="bg-white rounded-lg shadow-xl p-6 md:p-8">
                <h1 class="text-xl md:text-2xl font-bold text-center text-gray-800">
                    Data Valid di Aplikasi Pengolahan Nilai Ijazah
                </h1>
                <p class="text-sm text-center text-gray-500 mt-1 mb-8">by Syamsul Bahri</p>
                <div id="validation-result" class="text-center">
                    <p class="text-gray-600 loading-animation">Memvalidasi data, mohon tunggu</p>
                </div>
            </div>
        </div>

        <script>
            window.addEventListener('load', () => {
                const resultDiv = document.getElementById('validation-result');
                // Token sekarang disisipkan langsung dari server, ini lebih aman
                const token = "${token || ''}";

                if (!token) {
                    resultDiv.innerHTML = '<p class="text-red-600 font-bold">Error: Token validasi tidak ditemukan.</p>';
                    return;
                }

                google.script.run
                    .withSuccessHandler(response => {
                        if (response && response.status === 'success') {
                            const data = response.data;
                            resultDiv.innerHTML = \`
                                <div class="overflow-x-auto border rounded-lg">
                                    <table class="min-w-full text-left text-sm md:text-base">
                                        <thead class="bg-gray-50">
                                            <tr>
                                                <th class="px-4 py-3 font-medium text-gray-600">Data</th>
                                                <th class="px-4 py-3 font-medium text-gray-800">Informasi</th>
                                            </tr>
                                        </thead>
                                        <tbody class="divide-y divide-gray-200">
                                            <tr class="border-b"><td class="px-4 py-3 text-gray-500">Nama Sekolah</td><td class="px-4 py-3 font-bold text-gray-900">\${data.namaSekolah}</td></tr>
                                            
                                            <tr class="border-b"><td class="px-4 py-3 text-gray-500">NISN</td><td class="px-4 py-3 font-bold text-gray-900">\${data.nisn}</td></tr>
                                            <tr class="border-b"><td class="px-4 py-3 text-gray-500">Nama Lengkap Siswa</td><td class="px-4 py-3 font-bold text-gray-900">\${data.namaLengkap}</td></tr>
                                            <tr><td class="px-4 py-3 text-gray-500">Nilai Rata-Rata Ijazah</td><td class="px-4 py-3 font-bold text-blue-600 text-lg">\${data.rataRataIjazah}</td></tr>
                                        </tbody>
                                    </table>
                                </div>
                                <div class="mt-6 p-3 bg-green-100 text-green-800 rounded-lg flex items-center justify-center gap-3">
                                    <svg class="w-6 h-6 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>
                                    <span class="font-semibold text-center">DATA TERVERIFIKASI DAN VALID</span>
                                </div>
                            \`;
                        } else {
                            resultDiv.innerHTML = \`
                                <div class="mt-6 p-3 bg-red-100 text-red-800 rounded-lg flex items-center justify-center gap-3">
                                    <svg class="w-6 h-6 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>
                                    <span class="font-semibold text-center">VALIDASI GAGAL: \${response.message}</span>
                                </div>
                            \`;
                        }
                    })
                    .withFailureHandler(err => {
                        resultDiv.innerHTML = '<p class="text-red-600 font-bold">Terjadi kesalahan saat menghubungi server. Coba lagi nanti.</p>';
                    })
                    .getValidationData(token);
            });
        </script>
    </body>
    </html>
  `;
  // Membuat dan mengembalikan output HTML
  return HtmlService.createHtmlOutput(html)
      .setTitle('Validasi Transkrip')
      .setFaviconUrl("https://i.imgur.com/CmVVVxB.png")
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

// =================================================================
// [BARU] FUNGSI UNTUK PORTAL GURU
// =================================================================

// [PERUBAHAN] Ganti fungsi loginGuru() dengan versi ini
function loginGuru(schoolCode, username, password) {
  try {
    if (!schoolCode || !username || !password) { return { status: "error", message: "Kode Sekolah, Username, dan Password wajib diisi." }; }
    
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) throw new Error("Sheet 'Data Pengguna' tidak ditemukan.");
    
    const users = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 13).getValues();
    const schoolRow = users.find(row => row[12] && row[12].toUpperCase() === schoolCode.toUpperCase());
    
    if (!schoolRow) { return { status: "error", message: "Kode Sekolah tidak valid." }; }
    
    // [PERUBAHAN] Cek apakah fitur untuk sekolah ini terkunci
    const lockStatus = checkFiturLock(schoolRow[1]); // Cek berdasarkan email admin sekolah (indeks ke-1)
    if (lockStatus.isLocked) {
      return { 
        status: "locked", // Menggunakan status "locked" agar frontend bisa menanganinya
        message: "Akses untuk guru dari sekolah ini ditangguhkan. Silakan hubungi administrator sekolah Anda." 
      };
    }
    
    const schoolSpreadsheetId = schoolRow[5];
    if (!schoolSpreadsheetId) { return { status: "error", message: "Konfigurasi sekolah ini tidak lengkap. Hubungi Admin." }; }
    
    const ss = SpreadsheetApp.openById(schoolSpreadsheetId);
    const guruSheet = ss.getSheetByName(SHEET_DATA_GURU);
    if (!guruSheet || guruSheet.getLastRow() < 2) { return { status: "error", message: "Data guru tidak ditemukan di sekolah ini." }; }
    
    const data = guruSheet.getRange(2, 1, guruSheet.getLastRow() - 1, 7).getValues();
    const guruUserRow = data.find(row => row[1] === username && row[2].toString() === password.toString());

    if (guruUserRow) {
      const mapelSheet = ss.getSheetByName(SHEET_MAPEL);
      const allMapel = mapelSheet.getLastRow() > 1 ? mapelSheet.getRange(2, 1, mapelSheet.getLastRow() - 1, 4).getValues() : [];
      const kodeMapelGuru = guruUserRow[3].split(',').map(k => k.trim());
      
      const kelasDiajarString = guruUserRow[6] || '';
      const kelasMap = new Map();

      if (kelasDiajarString) {
        const assignments = kelasDiajarString.split(',').map(a => a.trim()).filter(Boolean);
        assignments.forEach(assignment => {
          const parts = assignment.split(':');
          if (parts.length === 2) {
              const mapelCode = parts[0].trim().toUpperCase();
              const kelas = parts[1].trim();
              if (!kelasMap.has(mapelCode)) {
                  kelasMap.set(mapelCode, []);
              }
              kelasMap.get(mapelCode).push(kelas);
          }
        });
      }

      const mapelGuru = allMapel
        .filter(m => kodeMapelGuru.includes(m[0]))
        .map(m => ({ 
            kode: m[0], 
            nama: m[1], 
            jenisUjian: m[3],
            kelas: kelasMap.get(m[0]) || [] 
        }));
      
      const submissionStatus = getNilaiSubmissionStatus(schoolSpreadsheetId);

      return {
        status: "success",
        data: {
          spreadsheetId: schoolSpreadsheetId,
          nama: guruUserRow[0],
          username: guruUserRow[1],
          mapel: mapelGuru,
          isSubmissionEnabled: submissionStatus.isEnabled
        }
      };
    } else {
      return { status: "error", message: "Username atau password salah." };
    }
  } catch (e) {
    Logger.log("loginGuru Error: " + e.message + " Stack: " + e.stack);
    return { status: "error", message: "Terjadi kesalahan server saat login." };
  }
}

/**
 * [PERBAIKAN FINAL] Mengambil daftar siswa dari spreadsheet ID tertentu.
 * Menggunakan .getDisplayValues() untuk memastikan NISN terbaca sebagai Teks.
 */
function getStudentsForGuru(spreadsheetId, className = null) { // Tambah parameter opsional
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const studentSheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (!studentSheet || studentSheet.getLastRow() < 2) return [];

    const data = studentSheet.getRange(2, 1, studentSheet.getLastRow() - 1, 15).getDisplayValues();
    
    let filteredData = data;
    // Jika nama kelas diberikan, filter data
    if(className) {
        // Kolom Kelas adalah kolom ke-14 (indeks 13)
        filteredData = data.filter(row => row[13] === className);
    }

    const students = filteredData.map(row => ({ 
        nisn: row[0],
        nama: row[3],
        nomorUjian: row[2],
        ruangUjian: row[14]
    }));

    // Baris di bawah ini yang mengurutkan berdasarkan nama telah dihapus.
    // students.sort((a, b) => a.nama.localeCompare(b.nama)); 

    return students;
}

/**
 * [DIPERBARUI] Mengambil daftar siswa dan jenjang dari spreadsheet ID tertentu.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @returns {object} Objek berisi daftar siswa dan jenjang.
 */
function getStudentsAndJenjangForGuru(spreadsheetId) {
  const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang;
  const students = getStudentsForGuru(spreadsheetId);
  return { students, jenjang };
}

/**
 * [DIPERBARUI] Menerima data nilai dan menyimpan ke sheet persetujuan di spreadsheet yang benar.
 * @param {object} payload - Objek berisi data nilai.
 * @returns {object} Hasil penyimpanan.
 */
function submitNilaiUntukPersetujuan(payload) {
  try {
    const { spreadsheetId, guru, mapelKode, tipeNilai, dataNilai } = payload;
    const ss = SpreadsheetApp.openById(spreadsheetId); // Buka spreadsheet sekolah yang benar
    const sheetName = "Pengajuan Nilai";
    let approvalSheet = ss.getSheetByName(sheetName);

    if (!approvalSheet) {
      approvalSheet = ss.insertSheet(sheetName);
      approvalSheet.appendRow(["ID Pengajuan", "Guru", "Mapel", "Tipe Nilai", "NISN", "Nama Siswa", "Nilai", "Tanggal Ajuan", "Status"]);
      approvalSheet.getRange("A1:I1").setFontWeight("bold");
    }
    
    const students = getStudentsForGuru(spreadsheetId); // Ambil siswa dari spreadsheet yang sama
    const studentMap = new Map(students.map(s => [s.nisn.toString(), s.nama]));
    const submissionId = Utilities.getUuid();
    const timestamp = new Date();

    const rowsToAppend = dataNilai.map(item => [
      submissionId, guru, mapelKode, tipeNilai, item.nisn,
      studentMap.get(item.nisn.toString()) || 'Siswa tidak ditemukan',
      item.nilai, timestamp, "Menunggu Persetujuan"
    ]);

    if (rowsToAppend.length > 0) {
        approvalSheet.getRange(approvalSheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
    }

    return { status: "success", message: "Nilai berhasil dikirim dan menunggu persetujuan admin." };
  } catch(e) {
    Logger.log("submitNilaiUntukPersetujuan Error: " + e.message);
    return { status: "error", message: "Gagal mengirim nilai: " + e.message };
  }
}

// =================================================================
// [BARU] FUNGSI UNTUK PERSETUJUAN NILAI OLEH ADMIN
// =================================================================

/**
 * [ADMIN - PERBAIKAN] Mengambil semua data dari sheet "Pengajuan Nilai".
 * Menggunakan getDisplayValues() untuk memastikan NISN dengan awalan nol terbaca sebagai teks.
 */
function getPengajuanNilaiUntukAdmin(spreadsheetId) {
    try {
        const ss = SpreadsheetApp.openById(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
        if (!sheet || sheet.getLastRow() < 2) return [];

        // === PERUBAHAN UTAMA ADA DI SINI ===
        // Menggunakan .getDisplayValues() untuk membaca semua data sebagai Teks.
        const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getDisplayValues();
        // ===================================
        
        const result = [];
        const originalData = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues(); // Untuk mengambil objek tanggal asli

        data.forEach((row, index) => {
            if (row[8] === "Menunggu Persetujuan") {
                result.push({
                    rowNum: index + 2,
                    guru: row[1],
                    mapelKode: row[2],
                    tipeNilai: row[3],
                    nisn: row[4], // NISN sekarang akan menjadi string "098", bukan angka 98.
                    namaSiswa: row[5],
                    nilai: row[6],
                    tanggal: originalData[index][7].toISOString() // Ambil tanggal sebagai objek Date lalu ubah ke ISO string
                });
            }
        });
        return result.sort((a, b) => new Date(b.tanggal) - new Date(a.tanggal));
    } catch (e) {
        Logger.log("getPengajuanNilaiUntukAdmin Error: " + e.message);
        throw new Error("Gagal mengambil data pengajuan nilai: " + e.message);
    }
}

/**
 * [PERBAIKAN WAJIB] Memproses persetujuan nilai dengan data siswa yang lengkap.
 * Memastikan NISN selalu diperlakukan sebagai Teks saat menulis ke sheet nilai.
 */
function processNilaiSubmission(spreadsheetId, rowNum, status) {
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);
    try {
        const ss = SpreadsheetApp.openById(spreadsheetId);
        const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
        
        // Baca NISN dari sheet pengajuan sebagai Teks
        const dataRowDisplay = approvalSheet.getRange(rowNum, 1, 1, 9).getDisplayValues()[0];
        const dataRowValues = approvalSheet.getRange(rowNum, 1, 1, 9).getValues()[0];


        if (dataRowDisplay[8] !== 'Menunggu Persetujuan') {
            return { status: "error", message: "Pengajuan ini sudah pernah diproses." };
        }

        approvalSheet.getRange(rowNum, 9).setValue(status);

        if (status === 'Disetujui') {
            const tipeNilaiLengkap = dataRowDisplay[3];
            const nisn = dataRowDisplay[4]; // NISN sekarang adalah string, misal "098"
            const mapelKode = dataRowDisplay[2];
            const nilai = dataRowDisplay[6];

            let targetSheetName = '';
            const parts = tipeNilaiLengkap.split('_');

            if (parts[0] === 'ujian') {
                targetSheetName = (parts[1] === 'um') ? SHEET_NILAI_UJIAN_MADRASAH : SHEET_NILAI_UJIAN_PRAKTEK;
            } else if (parts[0] === 'rapor') {
                const semesterKey = `${parts[1]}_${parts[2]}`;
                const jenisNilai = parts[3] === 'peng' ? 'Pengetahuan' : 'Keterampilan';
                targetSheetName = `Rapor_${jenisNilai}_${semesterKey}`;
            }

            if (targetSheetName) {
                let targetSheet = ss.getSheetByName(targetSheetName);
                if (!targetSheet) {
                    targetSheet = ss.insertSheet(targetSheetName);
                }
                
                // Set format kolom NISN di sheet tujuan sebagai Teks
                targetSheet.getRange("A:A").setNumberFormat('@');
                
                const nisnValues = targetSheet.getRange(2, 1, targetSheet.getLastRow()).getDisplayValues().flat();
                let studentRowIndex = nisnValues.findIndex(n => n === nisn);
                let studentSheetRow;

                if (studentRowIndex !== -1) {
                    studentSheetRow = studentRowIndex + 2;
                } else {
                    const allStudentsData = getStudents(spreadsheetId);
                    const studentFullData = allStudentsData.find(s => s.nisn === nisn);
                    
                    const newRowData = [
                        "'" + nisn, // Tambahkan ' untuk memaksa format Teks
                        studentFullData ? studentFullData.nama : dataRowDisplay[5]
                    ];
                    targetSheet.appendRow(newRowData);
                    studentSheetRow = targetSheet.getLastRow();
                }

                const headers = targetSheet.getRange(1, 1, 1, targetSheet.getLastColumn()).getDisplayValues()[0];
                const mapelCol = headers.indexOf(mapelKode);
                
                if (mapelCol !== -1) {
                    targetSheet.getRange(studentSheetRow, mapelCol + 1).setValue(nilai);
                } else {
                     throw new Error(`Kolom Mapel ${mapelKode} tidak ditemukan di sheet ${targetSheetName}.`);
                }
            }
        }
        SpreadsheetApp.flush();
        return { status: "success", message: `Nilai berhasil ${status.toLowerCase()}.` };
    } catch (e) {
        Logger.log("processNilaiSubmission Error: " + e.message + " Stack: " + e.stack);
        return { status: "error", message: "Gagal memproses pengajuan: " + e.message };
    } finally {
        lock.releaseLock();
    }
}

// =================================================================
// [BARU] FUNGSI UNTUK MANAJEMEN DATA GURU OLEH PENGGUNA/SEKOLAH
// =================================================================

/**
 * [PENGGUNA - DIPERBARUI] Mengambil daftar guru, kini termasuk status "Diubah Guru" dan "Kelas Diajar".
 */
function getGuru(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_DATA_GURU);
    
    if (!sheet) {
      sheet = ss.insertSheet(SHEET_DATA_GURU);
      // Tambahkan header baru "Kelas Diajar" di kolom G
      sheet.appendRow(["Nama Guru", "Username", "Password", "Kode Mapel", "NIP", "Diubah Guru", "Kelas Diajar"]);
      sheet.getRange("A1:G1").setFontWeight("bold");
      return [];
    }
    
    // Pastikan semua header ada jika sheet sudah ada sebelumnya
    if (sheet.getRange("F1").getValue() !== "Diubah Guru") {
        sheet.getRange("F1").setValue("Diubah Guru").setFontWeight("bold");
    }
    if (sheet.getRange("G1").getValue() !== "Kelas Diajar") {
        sheet.getRange("G1").setValue("Kelas Diajar").setFontWeight("bold");
    }
    
    sheet.getRange("E:E").setNumberFormat('@');
    if (sheet.getLastRow() < 2) return [];

    // Baca 7 kolom untuk menyertakan data baru
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 7).getDisplayValues();
    return data.map((row, index) => ({
        row: index + 2,
        nama: row[0],
        username: row[1],
        password: row[2],
        mapel: row[3],
        nip: row[4],
        isModifiedByGuru: row[5],
        kelas: row[6] || '' // Ambil data kelas atau string kosong jika kosong
    }));
  } catch (e) {
    Logger.log(`getGuru Error: ${e.message}`);
    return [];
  }
}

/**
 * [PENGGUNA - DIPERBARUI] Menyimpan data guru baru, menambahkan kolom NIP dan Kelas.
 */
function saveGuru(spreadsheetId, guruData) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_GURU);

        if (sheet.getLastRow() > 1) {
            const usernames = sheet.getRange(2, 2, sheet.getLastRow() - 1, 1).getValues().flat();
            if (usernames.some(u => u.toLowerCase() === guruData.username_guru.toLowerCase())) {
                return { status: "error", message: "Username sudah digunakan." };
            }
        }
        
        sheet.appendRow([
            guruData.nama_guru,
            guruData.username_guru,
            guruData.password_guru,
            guruData.mapel_kode_guru,
            guruData.nip_guru ? "'" + guruData.nip_guru : '',
            'TIDAK', // Status awal "Diubah Guru"
            guruData.kelas_diajar || '' // Data kelas baru
        ]);

        return { status: "success", message: "Data guru berhasil disimpan." };
    } catch (e) {
        Logger.log(`saveGuru Error: ${e.message}`);
        return { status: "error", message: `Gagal menyimpan: ${e.message}` };
    }
}

/**
 * [PENGGUNA - DIPERBARUI] Memperbarui data guru dengan logika kondisional untuk username/password.
 */
function updateGuru(spreadsheetId, guruData) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_GURU);
        const rowToUpdate = parseInt(guruData.guruRow);

        // 1. Ambil data baris saat ini, terutama status 'Diubah Guru'
        const currentRowData = sheet.getRange(rowToUpdate, 1, 1, 6).getValues()[0];
        const isModifiedByGuru = currentRowData[5] === 'YA';

        // 2. Logika untuk data yang akan diupdate
        let dataToUpdate;

        if (isModifiedByGuru) {
            // Jika guru sudah pernah mengubah, admin HANYA bisa mengubah data non-kredensial
            sheet.getRange(rowToUpdate, 1).setValue(guruData.nama_guru);      // Nama
            sheet.getRange(rowToUpdate, 4).setValue(guruData.mapel_kode_guru); // Mapel
            sheet.getRange(rowToUpdate, 5).setValue(guruData.nip_guru ? "'" + guruData.nip_guru : ''); // NIP
            sheet.getRange(rowToUpdate, 7).setValue(guruData.kelas_diajar || ''); // Kelas
        } else {
            // Jika guru belum mengubah, admin bisa mengubah SEMUA data
            dataToUpdate = [[
                guruData.nama_guru,
                guruData.username_guru,
                guruData.password_guru,
                guruData.mapel_kode_guru,
                guruData.nip_guru ? "'" + guruData.nip_guru : '',
                'TIDAK', // Status tetap TIDAK karena diubah oleh admin
                guruData.kelas_diajar || ''
            ]];
            sheet.getRange(rowToUpdate, 1, 1, 7).setValues(dataToUpdate);
        }
        
        return { status: "success", message: "Data guru berhasil diperbarui." };
    } catch (e) {
        Logger.log(`updateGuru Error: ${e.message}`);
        return { status: "error", message: `Gagal memperbarui: ${e.message}` };
    }
}

/**
 * [PENGGUNA] Menghapus data guru.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {number} rowNum - Nomor baris yang akan dihapus.
 * @returns {object} Status penghapusan.
 */
function deleteGuru(spreadsheetId, rowNum) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_GURU);
        sheet.deleteRow(rowNum);
        return { status: "success", message: "Data guru berhasil dihapus." };
    } catch (e) {
        Logger.log(`deleteGuru Error: ${e.message}`);
        return { status: "error", message: `Gagal menghapus: ${e.message}` };
    }
}

/**
 * [DIPERBARUI] Mengambil nilai yang sudah disimpan (draf), yang sudah dikirim,
 * dan status persetujuan dari admin.
 */
function getGuruNilai(spreadsheetId, username, mapelKode) {
  const ss = SpreadsheetApp.openById(spreadsheetId);

  // Fungsi helper untuk mengambil data dari sheet draf dan terkirim
  const getValuesFromSheet = (sheetName) => {
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) return {};
    const data = sheet.getDataRange().getValues();
    const result = {};
    data.forEach(row => {
      // row[0]=username, row[1]=mapelKode, row[2]=tipe, row[3]=nilai (JSON string)
      if (row[0] === username && row[1] === mapelKode) {
        try {
            result[row[2]] = JSON.parse(row[3]);
        } catch(e){
            result[row[2]] = {}; // Jika JSON tidak valid, kembalikan objek kosong
        }
      }
    });
    return result;
  };

  const getApprovalData = () => {
      const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
      if (!approvalSheet) return { statuses: {}, latestSubmissionId: null };

      const data = approvalSheet.getRange(2, 1, approvalSheet.getLastRow() - 1, 9).getValues();
      const statuses = {};
      let latestTimestamp = new Date(0);
      let latestSubmissionId = null;

      data.forEach(row => {
          if (row[1] === username && row[2] === mapelKode) {
              const tipe = row[3];
              const nisn = row[4];
              const status = row[8];
              const timestamp = new Date(row[7]);
              const submissionId = row[0];

              const key = `${tipe}_${nisn}`;
              statuses[key] = status;

              // Cek dan simpan ID pengajuan terbaru
              if (timestamp > latestTimestamp) {
                  latestTimestamp = timestamp;
                  latestSubmissionId = submissionId;
              }
          }
      });
      return { statuses, latestSubmissionId };
  };
  
  const approvalData = getApprovalData();

  return {
      savedValues: getValuesFromSheet(SHEET_NILAI_GURU_DRAFT),
      submittedValues: getValuesFromSheet(SHEET_NILAI_GURU_SUBMITTED),
      approvalStatus: approvalData.statuses,
      submissionId: approvalData.latestSubmissionId // <-- Kirim ID ini
  };
}

// [PERBAIKAN] Mengganti 'tipe' menjadi 'type'
function saveGuruDraftNilai(payload) {
  const { spreadsheetId, username, mapelKode, type, nilai } = payload;
  const ss = SpreadsheetApp.openById(spreadsheetId);
  let sheet = ss.getSheetByName(SHEET_NILAI_GURU_DRAFT);
  if (!sheet) {
    sheet = ss.insertSheet(SHEET_NILAI_GURU_DRAFT).hideSheet();
    sheet.appendRow(["Username", "MapelKode", "Tipe", "NilaiJSON"]);
  }
  
  const data = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === username && data[i][1] === mapelKode && data[i][2] === type) {
      rowIndex = i + 1;
      break;
    }
  }

  const nilaiJSON = JSON.stringify(nilai);
  if (rowIndex !== -1) {
    sheet.getRange(rowIndex, 4).setValue(nilaiJSON);
  } else {
    sheet.appendRow([username, mapelKode, type, nilaiJSON]);
  }
  return { status: 'success', message: 'Draf berhasil disimpan.' };
}

/**
 * [DIPERBARUI & PERBAIKAN FINAL] Menerima data nilai dari guru, memvalidasi izin,
 * dan menyimpannya ke sheet persetujuan di spreadsheet yang benar.
 */
function submitGuruNilai(payload) {
  try {
    // ===== AWAL PERUBAHAN 1: Ambil 'nama' dari payload =====
    const { spreadsheetId, username, nama, mapelKode, type, nilai } = payload;
    // =======================================================

    const submissionStatus = getNilaiSubmissionStatus(spreadsheetId);
    if (!submissionStatus.isEnabled) {
      return { 
        status: "error", 
        message: "Gagal: Pengiriman nilai saat ini sedang ditutup oleh admin. Silakan simpan sebagai draf." 
      };
    }

    const ss = SpreadsheetApp.openById(spreadsheetId);

    let submittedSheet = ss.getSheetByName(SHEET_NILAI_GURU_SUBMITTED);
    if (!submittedSheet) {
      submittedSheet = ss.insertSheet(SHEET_NILAI_GURU_SUBMITTED).hideSheet();
      submittedSheet.appendRow(["Username", "MapelKode", "Tipe", "NilaiJSON", "Tanggal"]);
    }
    const nilaiJSON = JSON.stringify(nilai);
    submittedSheet.appendRow([username, mapelKode, type, nilaiJSON, new Date()]);

    let draftSheet = ss.getSheetByName(SHEET_NILAI_GURU_DRAFT);
    if (draftSheet) {
        const data = draftSheet.getDataRange().getValues();
        for (let i = data.length - 1; i >= 1; i--) {
            if (data[i][0] === username && data[i][1] === mapelKode && data[i][2] === type) {
                draftSheet.deleteRow(i + 1);
            }
        }
    }

    let approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet) {
      approvalSheet = ss.insertSheet(SHEET_PENGAJUAN_NILAI);
      approvalSheet.appendRow(["ID Pengajuan", "Guru", "Mapel", "Tipe Nilai", "NISN", "Nama Siswa", "Nilai", "Tanggal Ajuan", "Status"]);
      approvalSheet.getRange("A1:I1").setFontWeight("bold");
    }

    const students = getStudentsForGuru(spreadsheetId);
    const studentMap = new Map(students.map(s => [s.nisn.toString(), s.nama]));
    const submissionId = Utilities.getUuid();
    const timestamp = new Date();
    const rowsToAppend = [];

    for (const [key, value] of Object.entries(nilai)) {
      const parts = key.split('_'); 
      const nisn = parts[0];
      const subTipe = parts[1];
      
      let tipeNilaiLengkap = '';
      if (type.startsWith('rapor')) {
        tipeNilaiLengkap = `${type}_${subTipe}`;
      } else if (type === 'ujian') {
        tipeNilaiLengkap = `ujian_${subTipe}`;
      }

      rowsToAppend.push([
        submissionId, username, mapelKode, tipeNilaiLengkap,
        "'" + nisn, // <-- PERUBAHAN: Menambahkan ' untuk memaksa format Teks di sheet
        studentMap.get(nisn) || 'Siswa tidak ditemukan',
        value, timestamp, "Menunggu Persetujuan"
      ]);
    }

    if (rowsToAppend.length > 0) {
      approvalSheet.getRange(approvalSheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
      // Format kolom NISN sebagai teks untuk pengajuan di masa mendatang
      approvalSheet.getRange("E:E").setNumberFormat('@'); 
    }

    try {
        const masterSs = SpreadsheetApp.getActiveSpreadsheet();
        const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
        const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 6).getValues();
        const schoolAdminRow = usersData.find(row => row[5] === spreadsheetId);

        if (schoolAdminRow) {
            const adminEmail = schoolAdminRow[1];
            const schoolName = schoolAdminRow[3];
            const mapelInfo = getMapel(spreadsheetId).find(m => m.kode === mapelKode);
            const mapelName = mapelInfo ? mapelInfo.nama : mapelKode;

            // ===== AWAL PERUBAHAN 2: Gunakan 'nama' di Judul dan Isi Email =====
            const subject = `[Notifikasi Aplikasi Ijazah] Pengajuan Nilai Baru dari ${nama}`; // Menggunakan nama lengkap
            const body = `
              <p>Halo Admin ${schoolName},</p>
              <p>Anda telah menerima pengajuan nilai baru dengan detail sebagai berikut:</p>
              <ul>
                <li><b>Guru Pengirim:</b> ${nama}</li> 
                <li><b>Mata Pelajaran:</b> ${mapelName}</li>
                <li><b>Jenis Nilai:</b> ${type.replace(/_/g, ' ')}</li>
                <li><b>Jumlah Data Nilai Diajukan:</b> ${rowsToAppend.length}</li>
                <li><b>Tanggal Pengajuan:</b> ${timestamp.toLocaleString('id-ID')}</li>
              </ul>
              <p>Silakan masuk ke aplikasi untuk meninjau dan memproses pengajuan ini di menu "Persetujuan Nilai".</p>
              <br>
              <p>Terima kasih.</p>
            `;
            // ======================================================================
            MailApp.sendEmail({ to: adminEmail, subject: subject, htmlBody: body });
        }
    } catch (e) {
        Logger.log(`Gagal mengirim email notifikasi pengajuan nilai ke admin: ${e.message}`);
    }
    
    return { status: 'success', message: 'Nilai berhasil dikirim untuk persetujuan admin.' };
  } catch(e) {
    Logger.log("submitGuruNilai Error: " + e.message);
    return { status: "error", message: "Gagal mengirim nilai: " + e.message };
  }
}

/**
 * [BARU] Menghitung jumlah pengajuan nilai yang masih menunggu.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @returns {number} Jumlah pengajuan yang pending.
 */
function getPendingApprovalCount(spreadsheetId) {
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!sheet || sheet.getLastRow() < 2) {
      return 0;
    }
    const statusColumn = sheet.getRange(2, 9, sheet.getLastRow() - 1, 1).getValues();
    const pendingCount = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
    return pendingCount;
  } catch (e) {
    Logger.log(`getPendingApprovalCount Error: ${e.message}`);
    return 0;
  }
}

/**
 * [BARU] Memproses beberapa pengajuan nilai sekaligus (aksi massal).
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {Array<number>} rowNumbers - Array nomor baris yang akan diproses.
 * @param {string} status - Keputusan ("Disetujui" atau "Ditolak").
 * @returns {object} Hasil proses.
 */
function processMultipleSubmissions(spreadsheetId, rowNumbers, status) {
  if (!rowNumbers || rowNumbers.length === 0) {
    return { status: "info", message: "Tidak ada item yang dipilih." };
  }
  let successCount = 0;
  let errorCount = 0;
  
  rowNumbers.forEach(rowNum => {
    try {
      // Memanggil fungsi yang sudah ada untuk setiap baris
      const result = processNilaiSubmission(spreadsheetId, rowNum, status);
      if (result.status === 'success') {
        successCount++;
      } else {
        errorCount++;
        Logger.log(`Gagal memproses baris ${rowNum}: ${result.message}`);
      }
    } catch (e) {
      errorCount++;
      Logger.log(`Error saat memproses baris ${rowNum}: ${e.message}`);
    }
  });

  let message = `${successCount} item berhasil diproses.`;
  if (errorCount > 0) {
    message += ` ${errorCount} item gagal diproses (lihat log untuk detail).`;
  }
  return { status: "success", message: message };
}

// =================================================================
// [BARU] FUNGSI CETAK PDF UNTUK GURU
// =================================================================

/**
 * Helper function untuk mengubah angka menjadi teks terbilang dalam Bahasa Indonesia.
 * @param {number} angka - Angka yang akan diubah.
 * @returns {string} Teks terbilang dari angka.
 */
function terbilang(angka) {
    const bilangan = ["", "Satu", "Dua", "Tiga", "Empat", "Lima", "Enam", "Tujuh", "Delapan", "Sembilan", "Sepuluh", "Sebelas"];
    if (angka < 12) {
        return bilangan[angka];
    } else if (angka < 20) {
        return terbilang(angka - 10) + " Belas";
    } else if (angka < 100) {
        return terbilang(Math.floor(angka / 10)) + " Puluh " + terbilang(angka % 10);
    } else if (angka < 200) {
        return "Seratus " + terbilang(angka - 100);
    } else if (angka < 1000) {
        return terbilang(Math.floor(angka / 100)) + " Ratus " + terbilang(angka % 100);
    }
    return "";
}

/**
 * [REVISI TAMPILAN PDF FINAL] Membuat file PDF daftar nilai dengan format Times New Roman
 * dan penyesuaian tata letak sesuai permintaan.
 *
 * @param {object} payload - Data yang dikirim dari frontend.
 * @returns {object} Objek berisi data file PDF yang di-encode base64.
 */
function generateNilaiPdfForGuru(payload) {
  try {
    const { spreadsheetId, tipe, mapelKode, guruData } = payload;
    
    // --- Validasi di Sisi Server ---
    const guruNilaiInfo = getGuruNilai(spreadsheetId, guruData.username, mapelKode);
    const submissionId = guruNilaiInfo.submissionId;
    if (!submissionId) {
      throw new Error("Gagal mencetak: Tidak dapat menemukan riwayat pengajuan nilai untuk mapel ini.");
    }
    const batchStatus = getSubmissionBatchStatus(spreadsheetId, submissionId);
    if (!batchStatus.allApproved) {
        throw new Error("Cetak nilai gagal. Pastikan semua nilai siswa telah disetujui oleh admin.");
    }
    
    // --- Pengambilan Data ---
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const schoolData = getSchoolData(spreadsheetId);
    const students = getStudentsForGuru(spreadsheetId);
    const allMapel = getMapel(spreadsheetId);
    const mapelInfo = allMapel.find(m => m.kode === mapelKode);
    const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet) throw new Error("Sheet 'Pengajuan Nilai' tidak ditemukan.");
    
    const approvalData = approvalSheet.getRange(2, 1, approvalSheet.getLastRow() - 1, 9).getValues();
    const nilaiPerSiswa = [];
    students.forEach(s => {
        let nilaiAkhir = null;
        if (tipe === 'ujian') {
            const nilaiUMRow = approvalData.find(row => row[0].toString() === submissionId.toString() && row[1] === guruData.username && row[2] === mapelKode && row[3] === 'ujian_um' && row[4].toString() === s.nisn.toString() && row[8] === 'Disetujui');
            const nilaiUPrRow = approvalData.find(row => row[0].toString() === submissionId.toString() && row[1] === guruData.username && row[2] === mapelKode && row[3] === 'ujian_upr' && row[4].toString() === s.nisn.toString() && row[8] === 'Disetujui');
            const nilaiUM = nilaiUMRow ? parseFloat(nilaiUMRow[6]) : null;
            const nilaiUPr = nilaiUPrRow ? parseFloat(nilaiUPrRow[6]) : null;

            if (nilaiUM !== null && nilaiUPr !== null) { nilaiAkhir = Math.round((nilaiUM + nilaiUPr) / 2); } 
            else if (nilaiUM !== null) { nilaiAkhir = Math.round(nilaiUM); } 
            else if (nilaiUPr !== null) { nilaiAkhir = Math.round(nilaiUPr); }
        } else {
            const tipeNilaiCari = `rapor_${tipe.split('_')[1]}_${tipe.split('_')[2]}`;
            const tipePeng = `${tipeNilaiCari}_peng`;
            const nilaiPengRow = approvalData.find(row => row[0].toString() === submissionId.toString() && row[1] === guruData.username && row[2] === mapelKode && row[3] === tipePeng && row[4].toString() === s.nisn.toString() && row[8] === 'Disetujui');
            if (nilaiPengRow) { nilaiAkhir = Math.round(parseFloat(nilaiPengRow[6])); }
        }
        if (nilaiAkhir !== null) { nilaiPerSiswa.push({ ...s, nilai: nilaiAkhir }); }
    });
    if (nilaiPerSiswa.length === 0) { throw new Error("Tidak ada data nilai yang disetujui untuk dicetak."); }

    // ==========================================================
    // === AWAL LOGIKA BARU UNTUK TAHUN AJARAN & JUDUL ===
    // ==========================================================
    const printSettings = getPrintSettings(spreadsheetId).settings || {};
    const tahunSekarang = new Date().getFullYear();
    
    // Terapkan logika prioritas: Gunakan dari pengaturan jika ada, jika tidak gunakan default baru.
    const tahunAjaran = printSettings.tahunAjaran || `${tahunSekarang - 1}/${tahunSekarang}`;
    
    // Ekstrak tahun kedua dari string tahun ajaran untuk judul utama.
    const tahunUntukJudul = tahunAjaran.split('/')[1] || tahunSekarang;

    let reportTitle = "";
    if (tipe === 'ujian') {
        reportTitle = `NILAI UJIAN MADRASAH TAHUN ${tahunUntukJudul}`;
    } else if (tipe.startsWith('rapor_')) {
        const semesterKey = tipe.split('_').slice(1).join('_');
        const semesterMap = { k4_ganjil: 'KELAS IV SEMESTER GANJIL', k4_genap: 'KELAS IV SEMESTER GENAP', k5_ganjil: 'KELAS V SEMESTER GANJIL', k5_genap: 'KELAS V SEMESTER GENAP', k6_ganjil: 'KELAS VI SEMESTER GANJIL', k7_ganjil: 'KELAS VII SEMESTER GANJIL', k7_genap: 'KELAS VII SEMESTER GENAP', k8_ganjil: 'KELAS VIII SEMESTER GANJIL', k8_genap: 'KELAS VIII SEMESTER GENAP', k9_ganjil: 'KELAS IX SEMESTER GANJIL', k10_ganjil: 'KELAS X SEMESTER GANJIL', k10_genap: 'KELAS X SEMESTER GENAP', k11_ganjil: 'KELAS XI SEMESTER GANJIL', k11_genap: 'KELAS XI SEMESTER GENAP', k12_ganjil: 'KELAS XII SEMESTER GANJIL' };
        reportTitle = `DAFTAR NILAI RAPOR ${semesterMap[semesterKey] || ''} TAHUN AJARAN ${tahunAjaran}`;
    }

    // --- Logika Kop Surat Dinamis ---
    const { logo, customHeader } = getDocumentSettings(spreadsheetId).settings || {};
    let headerHtml;
    if (customHeader) {
        headerHtml = `<div style="width: 100%; margin-bottom: 10px; border-bottom: 3px solid black;"><img src="${customHeader}" alt="Kop Surat" style="width: 100%; height: auto;"></div>`;
    } else {
        const kantorKemenagLine = `KANTOR KEMENTERIAN AGAMA ${schoolData.tipeKabupaten || ''} ${schoolData.kabupaten || ''}`.toUpperCase();
        const tipeKabSingkat = schoolData.tipeKabupaten === 'Kabupaten' ? 'Kab.' : 'Kota';
        const tipeKelSingkat = schoolData.tipeKelurahan === 'Kelurahan' ? 'Kel.' : 'Desa';
        const alamatLengkap = [ schoolData.alamat, `${tipeKelSingkat} ${toProperCase(schoolData.kelurahan || '')}`, `Kec. ${toProperCase(schoolData.kecamatan || '')}`, `${tipeKabSingkat} ${toProperCase(schoolData.kabupaten || '')}`, toProperCase(schoolData.provinsi || ''), schoolData.kodePos ].filter(Boolean).join(', ');
        const phone = schoolData.telepon ? `Telepon : ${schoolData.telepon}` : '';
        const web = schoolData.website ? `Website : ${schoolData.website}` : '';
        let contactLine = '';
        if (phone && web) { contactLine = `${phone} | ${web}`; } 
        else { contactLine = phone || web; }
        const contactLineHtml = contactLine ? `<div style="font-family: 'Times New Roman', Times, serif; font-size: 9pt;">${contactLine}</div>` : '';
        headerHtml = `
            <div style="display: flex; align-items: flex-start; padding-bottom: 5px; border-bottom: 3px solid black; margin-bottom: 10px;">
                ${logo ? `<img src="${logo}" style="width:75px; height:75px; margin-right: 20px;" alt="Logo">` : '<div style="width:75px; height:75px; margin-right: 20px;"></div>'}
                <div style="text-align: center; flex-grow: 1; line-height: 1.4; font-family: 'Times New Roman', Times, serif;">
                   <div style="font-size: 14pt; font-weight: bold;">KEMENTERIAN AGAMA REPUBLIK INDONESIA</div>
                   <div style="font-size: 12pt; font-weight: bold;">${kantorKemenagLine}</div>
                   <div style="font-size: 11pt; font-weight: bold;">${(schoolData.namaSekolah || 'NAMA SEKOLAH').toUpperCase()}</div>
                   <div style="font-size: 9pt;">Alamat : ${alamatLengkap}</div>
                   ${contactLineHtml}
                </div>
            </div>`;
    }

    // --- Data Pelengkap ---
    const tanggalCetak = new Date().toLocaleDateString('id-ID', { day: 'numeric', month: 'long', year: 'numeric' });
    const tempatCetak = schoolData.kabupaten ? toProperCase(schoolData.kabupaten) : 'Tempat';

    // --- Pembuatan Konten HTML untuk PDF ---
    const htmlContent = `
      <html><head><style>
        body{font-family: 'Times New Roman', Times, serif; font-size: 11pt;} 
        table{border-collapse: collapse; width: 100%;} 
        
        /* PERUBAHAN CSS: Menghapus text-align: left agar lebih fleksibel */
        th, td{border: 1px solid black; padding: 4px; vertical-align: middle;}
        
        /* PERUBAHAN CSS: Aturan baru khusus untuk header tabel */
        thead th { text-align: center; }

        .text-center{text-align: center;} 
        .font-bold{font-weight: bold;}
        .no-border{border: none !important;}
      </style></head><body>
        ${headerHtml}
        <h3 style="text-align:center; font-size: 13pt; margin-top: 20px; margin-bottom: 20px; text-decoration: underline; font-weight: bold;">${reportTitle}</h3>
        <table class="no-border" style="width: 100%; font-size: 12pt; margin-bottom: 15px;">
            <tr>
                <td class="no-border" style="width: 180px;">Nama Mata Pelajaran</td>
                <td class="no-border" style="width:10px;">:</td>
                <td class="no-border font-bold" style="white-space: nowrap;">${mapelInfo.nama.toUpperCase()}</td>
            </tr>
            <tr><td class="no-border">Tahun Pelajaran</td><td class="no-border">:</td><td class="no-border font-bold">${tahunAjaran}</td></tr>
            <tr><td class="no-border">Guru Pemeriksa</td><td class="no-border">:</td><td class="no-border font-bold">${guruData.nama.toUpperCase()}</td></tr>
        </table>
        
        <table>
            <thead style="background-color: #e5e5e5; font-weight:bold;">
                <tr>
                    <th>No</th>
                    <th>Ruang<br>Ujian</th>
                    <th>Nomor Ujian</th>
                    <th>Nama Peserta Ujian</th>
                    <th>Nilai</th>
                    <th>Nilai dengan huruf</th>
                </tr>
            </thead>
            <tbody>
                ${nilaiPerSiswa.map((s, i) => `
                    <tr>
                        <td class="text-center">${i + 1}</td>
                        <td class="text-center">${s.ruangUjian || '-'}</td>
                        <td class="text-center">${s.nomorUjian || '-'}</td>
                        <td>${s.nama}</td>
                        <td class="text-center font-bold">${s.nilai}</td>
                        <td style="font-style: italic;">${terbilang(s.nilai)}</td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
        <div style="margin-top: 40px; width: 100%; display: flex; justify-content: space-between; page-break-inside: avoid;">
            <div style="width: 45%; text-align: center;">
                <p style="margin-bottom: 60px;">Mengetahui,<br>Kepala Madrasah,</p>
                <p style="font-weight: bold; text-decoration: underline; margin: 0; padding: 0;">${schoolData.namaKepsek ? schoolData.namaKepsek.toUpperCase() : '(NAMA KEPALA SEKOLAH)'}</p>
                <p style="margin: 0; padding: 0;">NIP. ${schoolData.nipKepsek || '-'}</p>
            </div>
            <div style="width: 45%; text-align: center;">
                <p style="margin-bottom: 60px;">${tempatCetak}, ${tanggalCetak}<br>Guru Pemeriksa,</p>
                <p style="font-weight: bold; text-decoration: underline;">${guruData.nama.toUpperCase()}</p>
                <p style="margin: 0; padding: 0;">NIP. ${guruData.nip || '-'}</p>
            </div>
        </div>
      </body></html>`;

    const pdfBlob = Utilities.newBlob(htmlContent, MimeType.HTML).getAs(MimeType.PDF);
    const fileName = `Nilai_${mapelKode}_${tipe}.pdf`;
    pdfBlob.setName(fileName);
    
    return {
      status: 'success',
      fileName: fileName,
      pdfData: Utilities.base64Encode(pdfBlob.getBytes())
    };

  } catch(e) {
    Logger.log("generateNilaiPdfForGuru Error: " + e.stack);
    return { status: "error", message: e.message };
  }
}

/**
 * [PERBAIKAN FINAL] Mengekspor data siswa ke dalam file Excel.
 * Menambahkan kutip tunggal di depan NISN, NIS, No. Ujian, dan Telepon
 * untuk memastikan format teks tetap terjaga (termasuk angka 0 di depan).
 */
function exportSiswaToExcel(spreadsheetId) {
  let tempFile;
  try {
    const students = getStudents(spreadsheetId);
    if (!students || students.length === 0) {
      return { error: "Tidak ada data siswa untuk diekspor." };
    }

    const schoolData = getSchoolData(spreadsheetId);
    const schoolName = schoolData ? schoolData.namaSekolah.replace(/ /g, "_") : "Data_Siswa";
    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd");
    const exportFileName = `Data_Siswa_${schoolName}_${timestamp}`;
    
    const tempSpreadsheet = SpreadsheetApp.create(exportFileName);
    tempFile = DriveApp.getFileById(tempSpreadsheet.getId());
    
    const sheet = tempSpreadsheet.getSheets()[0];
    const headers = [
      "NISN", "NIS", "Nomor Ujian", "Nama Lengkap", "Jenis Kelamin (L/P)", 
      "Tempat Lahir", "Tanggal Lahir (Format: yyyy-MM-dd)",
      "Alamat Lengkap Siswa", "Nomor Telepon", "Email", 
      "Tahun Masuk", "Tahun Lulus", "Kelas", "Ruang Ujian"
    ];
    sheet.appendRow(headers);
    sheet.getRange("A1:N1").setFontWeight("bold").setBackground("#d9ead3");

    // [PERBAIKAN DI SINI] Tambahkan kutip tunggal (') di depan data yang relevan
    const rowsToWrite = students.map(s => [
      "'" + s.nisn, 
      "'" + s.nis, 
      "'" + s.nomorUjian, 
      s.nama, 
      s.jenisKelamin,
      s.tempatLahir, 
      s.tanggalLahir, 
      s.alamat, 
      "'" + s.telepon,
      s.emailSiswa, 
      s.tahunMasuk, 
      s.tahunLulus, 
      s.kelas, 
      s.ruangUjian
    ]);

    if (rowsToWrite.length > 0) {
      sheet.getRange(2, 1, rowsToWrite.length, headers.length).setValues(rowsToWrite);
    }
    
    sheet.getRange("G:G").setNumberFormat("yyyy-mm-dd");
    sheet.autoResizeColumns(1, headers.length);

    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${tempSpreadsheet.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: `${exportFileName}.xlsx`,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

// =================================================================
// [BARU] FUNGSI KONTROL PENGIRIMAN NILAI
// =================================================================

function setNilaiSubmissionStatus(spreadsheetId, isEnabled) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
        sheet = ss.insertSheet(SHEET_PENGATURAN);
        sheet.appendRow(['Nama Pengaturan', 'Value']);
    }
    const settingName = "Izinkan Pengiriman Nilai";
    const data = sheet.getRange("A:A").getValues().flat();
    let rowIndex = data.indexOf(settingName);

    if (rowIndex === -1) {
        sheet.appendRow([settingName, isEnabled ? "YA" : "TIDAK"]);
    } else {
        sheet.getRange(rowIndex + 1, 2).setValue(isEnabled ? "YA" : "TIDAK");
    }
    
    const message = isEnabled ? "Pengiriman nilai oleh guru telah diaktifkan." : "Pengiriman nilai oleh guru telah dinonaktifkan.";
    return { status: 'success', message: message };
  } catch (e) {
    Logger.log(`setNilaiSubmissionStatus Error: ${e.message}`);
    return { status: 'error', message: 'Gagal mengubah pengaturan.' };
  }
}

function getNilaiSubmissionStatus(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
      return { isEnabled: true };
    }
    const data = sheet.getRange("A:B").getValues();
    const settingRow = data.find(row => row[0] === "Izinkan Pengiriman Nilai");
    
    const isEnabled = settingRow ? settingRow[1] !== "TIDAK" : true;
    return { isEnabled: isEnabled };
  } catch (e) {
    Logger.log(`getNilaiSubmissionStatus Error: ${e.message}`);
    return { isEnabled: true };
  }
}

/**
 * [FUNGSI BARU] Memeriksa status lengkap dari sebuah batch pengajuan berdasarkan ID-nya.
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {string} submissionId - ID unik dari batch pengajuan.
 * @returns {object} Objek berisi status batch { total, approved, rejected, pending, allApproved }.
 */
function getSubmissionBatchStatus(spreadsheetId, submissionId) {
    if (!submissionId) {
        return { total: 0, approved: 0, rejected: 0, pending: 0, allApproved: false };
    }
    try {
        const ss = SpreadsheetApp.openById(spreadsheetId);
        const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
        if (!approvalSheet || approvalSheet.getLastRow() < 2) {
            return { total: 0, approved: 0, rejected: 0, pending: 0, allApproved: false };
        }

        const data = approvalSheet.getRange(2, 1, approvalSheet.getLastRow() - 1, 9).getValues();
        const batchRows = data.filter(row => row[0].toString() === submissionId.toString());

        const total = batchRows.length;
        const approved = batchRows.filter(row => row[8] === 'Disetujui').length;
        const rejected = batchRows.filter(row => row[8] === 'Ditolak').length;
        const pending = total - approved - rejected;
        const allApproved = (total > 0 && approved === total);

        return { total, approved, rejected, pending, allApproved };

    } catch (e) {
        Logger.log(`getSubmissionBatchStatus Error: ${e.message}`);
        return { total: 0, approved: 0, rejected: 0, pending: 0, allApproved: false, error: e.message };
    }
}

/**
 * [DIPERBARUI] Menghasilkan template Excel untuk impor data guru, kini dengan kolom Kelas Diajar.
 */
function generateGuruTemplate() {
  let tempFile;
  try {
    const templateName = `Template_Import_Guru_${new Date().getTime()}`;
    const ss = SpreadsheetApp.create(templateName);
    tempFile = DriveApp.getFileById(ss.getId());
    
    const sheet = ss.getSheets()[0];
    // ===== PERUBAHAN 1: Tambahkan header "Kelas Diajar" =====
    const headers = [
      "Nama Guru", "NIP (Opsional)", "Username", "Password", "Kode Mapel (pisahkan dengan koma)", "Kelas Diajar (Format: KODE:KELAS, pisahkan dengan koma)"
    ];
    sheet.appendRow(headers);
    // ===== PERUBAHAN 2: Sesuaikan jangkauan styling =====
    sheet.getRange("A1:F1").setFontWeight("bold").setBackground("#d9ead3");
    
    // Set kolom NIP, Username, Password sebagai format Teks
    sheet.getRange("B:D").setNumberFormat("@");
    
    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${ss.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: 'Template_Import_Guru.xlsx',
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

/**
 * [DIPERBARUI] Mengekspor data guru ke dalam file Excel, kini dengan kolom Kelas Diajar.
 */
function exportGuruToExcel(spreadsheetId) {
  let tempFile;
  try {
    const guruList = getGuru(spreadsheetId);
    if (!guruList || guruList.length === 0) {
      return { error: "Tidak ada data guru untuk diekspor." };
    }

    const schoolData = getSchoolData(spreadsheetId);
    const schoolName = schoolData ? schoolData.namaSekolah.replace(/ /g, "_") : "Data_Guru";
    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd");
    const exportFileName = `Data_Guru_${schoolName}_${timestamp}`;
    
    const tempSpreadsheet = SpreadsheetApp.create(exportFileName);
    tempFile = DriveApp.getFileById(tempSpreadsheet.getId());
    
    const sheet = tempSpreadsheet.getSheets()[0];
    // ===== PERUBAHAN 1: Tambahkan header "Kelas Diajar" =====
    const headers = ["Nama Guru", "NIP", "Username", "Password", "Kode Mapel", "Kelas Diajar"];
    sheet.appendRow(headers);
    sheet.getRange("A1:F1").setFontWeight("bold").setBackground("#d9ead3");

    // ===== PERUBAHAN 2: Tambahkan g.kelas ke dalam data yang akan ditulis =====
    const rowsToWrite = guruList.map(g => [
      g.nama,
      "'" + g.nip,
      "'" + g.username,
      "'" + g.password,
      g.mapel,
      g.kelas // <-- Tambahkan ini
    ]);

    if (rowsToWrite.length > 0) {
      sheet.getRange(2, 1, rowsToWrite.length, headers.length).setValues(rowsToWrite);
    }
    
    sheet.autoResizeColumns(1, headers.length);
    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${tempSpreadsheet.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: `${exportFileName}.xlsx`,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

/**
 * [DIPERBARUI] Mengimpor data guru dari file Excel, kini dengan kolom Kelas Diajar.
 */
function importGuruFromExcel(spreadsheetId, fileData) {
    let tempFile;
    try {
        const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
        const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
        const tempSpreadsheetFile = Drive.Files.insert({
            title: `temp_import_guru_${new Date().getTime()}`
        }, blob, { convert: true });
        tempFile = DriveApp.getFileById(tempSpreadsheetFile.getId());
        const importSheet = SpreadsheetApp.openById(tempFile.getId()).getSheets()[0];
        const data = importSheet.getDataRange().getValues();

        if (data.length <= 1) throw new Error("File kosong atau hanya berisi header.");
        data.shift(); // Hapus header

        const targetSpreadsheet = getSpreadsheet(spreadsheetId);
        let targetSheet = targetSpreadsheet.getSheetByName(SHEET_DATA_GURU);
        if (!targetSheet) {
            targetSheet = targetSpreadsheet.insertSheet(SHEET_DATA_GURU);
            targetSheet.appendRow(["Nama Guru", "Username", "Password", "Kode Mapel", "NIP", "Diubah Guru", "Kelas Diajar"]);
        }

        const existingUsernames = new Set(
            targetSheet.getLastRow() > 1 ?
            targetSheet.getRange(2, 2, targetSheet.getLastRow() - 1, 1).getValues().flat().map(u => u.toLowerCase()) : []
        );

        const newTeachers = [];
        let skippedCount = 0;
        const usernamesInFile = new Set();

        data.forEach(row => {
            const nama = row[0] || '';
            const nip = row[1] || '';
            const username = (row[2] || '').toString().trim();
            const password = (row[3] || '').toString().trim();
            const mapel = row[4] || '';
            // ===== PERUBAHAN 1: Baca data dari kolom ke-6 (indeks 5) =====
            const kelas = row[5] || '';

            if (!username || !password) {
                skippedCount++;
                return;
            }

            if (existingUsernames.has(username.toLowerCase()) || usernamesInFile.has(username.toLowerCase())) {
                skippedCount++;
                return;
            }
            
            // ===== PERUBAHAN 2: Tambahkan data 'kelas' ke array yang akan ditulis =====
            newTeachers.push([nama, username, password, mapel, nip, 'TIDAK', kelas]);
            usernamesInFile.add(username.toLowerCase());
        });

        if (newTeachers.length > 0) {
            // ===== PERUBAHAN 3: Sesuaikan jangkauan penulisan menjadi 7 kolom =====
            targetSheet.getRange(targetSheet.getLastRow() + 1, 1, newTeachers.length, 7).setValues(newTeachers);
        }

        return { 
            status: "success", 
            message: `${newTeachers.length} data guru berhasil diimpor. ${skippedCount} data dilewati karena tidak lengkap atau username duplikat.`
        };

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: `Gagal mengimpor data: ${e.toString()}` };
    } finally {
        if (tempFile) {
            tempFile.setTrashed(true);
        }
    }
}

/**
 * [BARU] Mengambil data profil untuk guru yang sedang login.
 */
function getGuruProfile(spreadsheetId, username) {
  try {
    const allGuru = getGuru(spreadsheetId);
    const profile = allGuru.find(g => g.username === username);
    if (!profile) {
      throw new Error("Profil guru tidak ditemukan.");
    }
    return { status: 'success', profile: profile };
  } catch (e) {
    return { status: 'error', message: e.message };
  }
}

/**
 * [BARU] Guru memperbarui profilnya sendiri.
 */
function updateGuruProfile(spreadsheetId, oldUsername, newData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_GURU);
    const usernames = sheet.getRange(2, 2, sheet.getLastRow() - 1, 1).getDisplayValues().flat();
    const guruIndex = usernames.findIndex(u => u === oldUsername);

    if (guruIndex === -1) {
      throw new Error("Profil guru tidak dapat ditemukan untuk diperbarui.");
    }
    const rowToUpdate = guruIndex + 2;
    
    // Set status "Diubah Guru" menjadi YA
    const isCredentialChanged = (newData.username !== oldUsername) || (newData.password !== sheet.getRange(rowToUpdate, 3).getValue());
    
    sheet.getRange(rowToUpdate, 1, 1, 6).setValues([[
      newData.nama,
      newData.username,
      newData.password,
      newData.mapel,
      newData.nip ? "'" + newData.nip : '',
      isCredentialChanged ? 'YA' : sheet.getRange(rowToUpdate, 6).getValue() || 'TIDAK'
    ]]);
    
    return { status: 'success', message: 'Profil berhasil diperbarui.' };
  } catch (e) {
    return { status: 'error', message: e.message };
  }
}

// GANTI FUNGSI LAMA DENGAN VERSI BARU INI
/**
 * [DIPERBARUI & PERBAIKAN] Admin membuat ulang username dan password untuk guru,
 * lalu mengirimkan notifikasi email ke admin sekolah.
 */
function regenerateGuruCredentials(spreadsheetId, rowNum) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_GURU);
    
    // ===== AWAL KODE BARU: Ambil data untuk email =====
    // 1. Dapatkan nama guru dari baris yang dipilih
    const guruName = sheet.getRange(rowNum, 1).getValue();

    // 2. Dapatkan email admin dan nama sekolah dari sheet utama
    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = masterSs.getSheetByName(SHEET_PENGGUNA);
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 6).getValues();
    const schoolAdminRow = usersData.find(row => row[5] === spreadsheetId);
    
    let adminEmail = null;
    let schoolName = 'Sekolah Anda';

    if (schoolAdminRow) {
      adminEmail = schoolAdminRow[1]; // Kolom B adalah email
      schoolName = schoolAdminRow[3]; // Kolom D adalah nama sekolah
    } else {
      throw new Error("Data admin sekolah tidak ditemukan untuk mengirim email.");
    }
    // ===== AKHIR KODE BARU =====

    // Buat username & password acak (logika tidak berubah)
    const newUsername = 'guru' + Math.floor(1000 + Math.random() * 9000);
    const newPassword = Math.random().toString(36).slice(-8);
    
    // Update sheet (logika tidak berubah)
    sheet.getRange(rowNum, 2).setValue(newUsername);
    sheet.getRange(rowNum, 3).setValue(newPassword);
    sheet.getRange(rowNum, 6).setValue('TIDAK');
    
    // ===== AWAL KODE BARU: Kirim Email Notifikasi =====
    const subject = `[Info Kredensial Baru] Akun Guru untuk ${guruName}`;
    const body = `
      <div style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2>Informasi Pembaruan Kredensial Guru</h2>
        <p>Halo Admin ${schoolName},</p>
        <p>Anda telah berhasil membuat ulang kredensial login untuk salah satu guru Anda. Berikut adalah detailnya:</p>
        <ul style="list-style-type: none; padding: 0;">
          <li><strong>Nama Guru:</strong> ${guruName}</li>
          <li style="margin-top: 10px;"><strong>Username Baru:</strong> <span style="font-family: monospace; background-color: #f0f0f0; padding: 2px 5px; border-radius: 3px;">${newUsername}</span></li>
          <li><strong>Password Baru:</strong> <span style="font-family: monospace; background-color: #f0f0f0; padding: 2px 5px; border-radius: 3px;">${newPassword}</span></li>
        </ul>
        <p>Harap catat informasi ini dan berikan kepada guru yang bersangkutan. Email ini dikirim sebagai catatan untuk Anda.</p>
        <br>
        <p>Terima kasih,</p>
        <p>Sistem Aplikasi Ijazah</p>
      </div>
    `;
    MailApp.sendEmail({
      to: adminEmail,
      subject: subject,
      htmlBody: body
    });
    // ===== AKHIR KODE BARU =====
    
    // ===== TAMBAHKAN BARIS INI UNTUK MEMASTIKAN PERUBAHAN TERSIMPAN =====
    SpreadsheetApp.flush(); //
    // =====================================================================

    // Pesan sukses tidak lagi menyertakan kredensial
    return {
      status: 'success',
      message: 'Kredensial baru telah dibuat dan dikirim ke email Anda.'
    };
  } catch (e) {
    return { status: 'error', message: e.message };
  }
}

// File: Kode.gs.html

/**
 * [OPTIMASI V2] Mengambil semua data yang diperlukan untuk merender satu halaman/tabel nilai guru,
 * kini dengan filter kelas yang ditambahkan.
 *
 * @param {string} spreadsheetId - ID spreadsheet sekolah.
 * @param {string} username - Username guru yang sedang login.
 * @param {string} mapelKode - Kode mata pelajaran yang sedang dilihat.
 * @param {string} tipeNilai - Tipe nilai yang akan ditampilkan (cth: 'ujian', 'rapor_k7_ganjil').
 * @param {string} [className=null] - Nama kelas untuk memfilter siswa (opsional).
 * @returns {object} Objek komprehensif berisi semua data yang diperlukan oleh frontend.
 */
function getNilaiPageData_Guru(spreadsheetId, username, mapelKode, tipeNilai, className = null) {
  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    
    const students = getStudentsForGuru(spreadsheetId, className);
    const schoolData = getSchoolData(spreadsheetId);
    const jenjang = schoolData ? schoolData.jenjang : null;
    const { savedValues, submittedValues, approvalStatus, submissionId } = getGuruNilai(spreadsheetId, username, mapelKode);
    const batchStatus = getSubmissionBatchStatus(spreadsheetId, submissionId);
    const submissionSettings = getNilaiSubmissionStatus(spreadsheetId);
    const kkmData = getKkm(spreadsheetId); // <-- [PERUBAHAN] Ambil data KKM

    return {
      status: "success",
      students: students,
      jenjang: jenjang,
      kkm: kkmData.kkm, // <-- [PERUBAHAN] Sertakan KKM dalam respons
      savedValues: savedValues,
      submittedValues: submittedValues,
      approvalStatus: approvalStatus,
      submissionId: submissionId,
      batchStatus: batchStatus,
      isSubmissionEnabled: submissionSettings.isEnabled
    };

  } catch(e) {
    Logger.log("getNilaiPageData_Guru Error: " + e.message + " | Stack: " + e.stack);
    return { status: "error", message: "Gagal memuat data nilai secara teroptimasi: " + e.message };
  }
}

// TAMBAHKAN DUA FUNGSI BARU INI DI Kode.gs.html

/**
 * [BARU] Menangani pengiriman ulang nilai yang telah direvisi oleh guru.
 * Fungsi ini tidak membuat baris baru, tetapi memperbarui baris yang statusnya 'Ditolak'.
 * @param {object} payload Objek berisi { spreadsheetId, username, nama, submissionId, tipeNilai, nilaiRevisi }
 * @returns {object} Hasil operasi.
 */
function resubmitRevisedNilai(payload) {
  const { spreadsheetId, username, nama, submissionId, tipeNilai, nilaiRevisi } = payload;
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.openById(spreadsheetId);
    const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
    if (!approvalSheet) {
      throw new Error("Sheet pengajuan tidak ditemukan.");
    }
    const dataRange = approvalSheet.getDataRange();
    const data = dataRange.getValues();
    let updatedCount = 0;

    for (const [key, value] of Object.entries(nilaiRevisi)) {
      const nisn = key.split('_')[0];
      const subTipe = key.split('_')[1];
      let tipeCari = '';
      if (tipeNilai === 'ujian') {
          tipeCari = `ujian_${subTipe}`;
      } else if (tipeNilai.startsWith('rapor')) {
          tipeCari = `${tipeNilai}_${subTipe}`;
      }
      
      // Cari baris yang cocok di sheet
      for (let i = 1; i < data.length; i++) { // Mulai dari 1 untuk lewati header
        const row = data[i];
        // Kriteria: ID Pengajuan, NISN, Tipe Nilai, dan Statusnya Ditolak
        if (row[0].toString() === submissionId && row[4].toString() === nisn && row[3] === tipeCari && row[8] === 'Ditolak') {
          approvalSheet.getRange(i + 1, 7).setValue(value); // Update nilai di kolom G
          approvalSheet.getRange(i + 1, 8).setValue(new Date()); // Update tanggal
          approvalSheet.getRange(i + 1, 9).setValue('Menunggu Persetujuan'); // Update status ke Menunggu
          updatedCount++;
          break; // Lanjut ke nilai revisi berikutnya
        }
      }
    }

    if (updatedCount > 0) {
      // Kirim notifikasi ke admin bahwa ada revisi
      // (Logika email notifikasi bisa ditambahkan di sini jika perlu)
      return { status: 'success', message: `${updatedCount} nilai yang direvisi berhasil dikirim kembali.` };
    } else {
      return { status: 'error', message: 'Tidak ada nilai yang cocok ditemukan untuk diperbarui.' };
    }

  } catch(e) {
    Logger.log("resubmitRevisedNilai Error: " + e.message + " Stack: " + e.stack);
    return { status: "error", message: "Gagal mengirim ulang nilai revisi: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [MODIFIKASI] Membatalkan pengiriman nilai oleh guru.
 * Kini juga akan menghapus semua entri terkait dari sheet persetujuan.
 */
function cancelGuruSubmission(payload) {
    const { spreadsheetId, username, mapelKode, type } = payload;
    const ss = SpreadsheetApp.openById(spreadsheetId);
    
    // Hapus dari sheet nilai terkirim dan kembalikan ke draf
    let submittedSheet = ss.getSheetByName(SHEET_NILAI_GURU_SUBMITTED);
    let submissionIdToDelete = null;

    if (submittedSheet) {
        const data = submittedSheet.getDataRange().getValues();
        for (let i = data.length - 1; i >= 1; i--) {
            if (data[i][0] === username && data[i][1] === mapelKode && data[i][2] === type) {
                const nilaiJSON = data[i][3];
                // Cari submissionId dari sheet 'Pengajuan Nilai' berdasarkan data ini
                const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
                if(approvalSheet) {
                  const approvalData = approvalSheet.getDataRange().getValues();
                  const foundRow = approvalData.find(row => row[1] === username && row[2] === mapelKode && (row[3].startsWith(type)));
                  if(foundRow) submissionIdToDelete = foundRow[0];
                }

                saveGuruDraftNilai({ spreadsheetId, username, mapelKode, type: type, nilai: JSON.parse(nilaiJSON) });
                submittedSheet.deleteRow(i + 1);
                break; // Hanya batalkan pengiriman terakhir
            }
        }
    }

    // Hapus semua baris terkait di sheet pengajuan
    if (submissionIdToDelete) {
        const approvalSheet = ss.getSheetByName(SHEET_PENGAJUAN_NILAI);
        if (approvalSheet) {
            const approvalData = approvalSheet.getRange("A:A").getValues().flat();
            for (let i = approvalData.length - 1; i >= 1; i--) {
                if (approvalData[i] === submissionIdToDelete) {
                    approvalSheet.deleteRow(i + 1);
                }
            }
        }
    }
    
    if(submissionIdToDelete) {
      return { status: 'success', message: 'Pengiriman dibatalkan. Nilai dikembalikan ke draf.' };
    } else {
      return { status: 'error', message: 'Data terkirim tidak ditemukan untuk dibatalkan.' };
    }
}

// GANTI FUNGSI LAMA getGuruEditorData DENGAN VERSI BARU INI

// GANTI FUNGSI LAMA DENGAN VERSI BARU INI
/**
 * [DIPERBARUI] Mengambil data untuk editor guru.
 * Daftar kelas sekarang diambil dari fungsi getKelas yang terpusat.
 */
function getGuruEditorData(spreadsheetId) {
  try {
    const allMapel = getMapel(spreadsheetId);
    // ===== PERUBAHAN DI SINI =====
    // Mengambil daftar kelas dari 'Pengaturan', bukan dari data siswa lagi.
    const kelasData = getKelas(spreadsheetId); 
    const allKelas = kelasData.status === 'success' ? kelasData.kelasList : [];
    // =============================

    return {
      allMapel: allMapel,
      allKelas: allKelas.sort() // Kembalikan sebagai array yang sudah diurutkan
    };
  } catch (e) {
    Logger.log("getGuruEditorData Error: " + e.message);
    return { allMapel: [], allKelas: [] };
  }
}

// TAMBAHKAN DUA FUNGSI BARU INI

/**
 * [BARU] Menyimpan daftar kelas ke dalam sheet 'Pengaturan'.
 * Daftar kelas disimpan sebagai string yang dipisahkan koma.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} kelasString String berisi daftar kelas, dipisahkan koma.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveKelas(spreadsheetId, kelasString) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
        sheet = ss.insertSheet(SHEET_PENGATURAN);
        sheet.getRange("A1:B1").setValues([['Nama Pengaturan', 'Value']]).setFontWeight('bold');
    }
    
    const row = findOrCreateSettingRow(sheet, "Daftar Kelas");
    // Bersihkan spasi berlebih dan simpan
    const cleanedString = kelasString.split(',').map(k => k.trim()).filter(Boolean).join(',');
    sheet.getRange(row, 2).setValue(cleanedString);

    return { status: "success", message: "Daftar kelas berhasil disimpan." };
  } catch (e) {
    Logger.log(`saveKelas Error: ${e.message}`);
    return { status: "error", message: `Gagal menyimpan daftar kelas: ${e.message}` };
  }
}

/**
 * [BARU] Mengambil daftar kelas dari sheet 'Pengaturan'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, kelasList: Array<string>}} Objek berisi daftar kelas.
 */
function getKelas(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_PENGATURAN);
    if (!sheet) {
      return { status: 'success', kelasList: [] };
    }
    const data = sheet.getRange("A:B").getValues();
    const settingRow = data.find(row => row[0] === "Daftar Kelas");
    
    if (settingRow && settingRow[1]) {
      const kelasList = settingRow[1].toString().split(',');
      return { status: 'success', kelasList: kelasList };
    }
    
    return { status: 'success', kelasList: [] }; // Kembalikan array kosong jika belum diatur
  } catch (e) {
    Logger.log(`getKelas Error: ${e.message}`);
    return { status: 'error', message: e.message, kelasList: [] };
  }
}

// Tambahkan fungsi baru ini di Kode.gs.html
function getSiswaTanpaKelas(spreadsheetId) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
        if (!sheet || sheet.getLastRow() < 2) {
            return { status: 'success', data: [] };
        }
        
        // Baca data termasuk kolom Kelas (kolom N, indeks 13)
        const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 14).getValues();

        const siswaTanpaKelas = data
            .filter(row => !row[13] || row[13].toString().trim() === '') // Filter baris dimana kolom kelas kosong
            .map(row => ({
                nisn: row[0],
                nama: row[3],
                jenisKelamin: row[4],
                tempatLahir: row[5],
                tanggalLahir: row[6] instanceof Date ? row[6].toISOString() : null,
            }))
            .sort((a, b) => a.nama.localeCompare(b.nama)); // Urutkan berdasarkan nama
        
        return { status: 'success', data: siswaTanpaKelas };

    } catch (e) {
        Logger.log(`getSiswaTanpaKelas Error: ${e.message}`);
        return { status: 'error', message: `Gagal mengambil data: ${e.message}` };
    }
}

// File: Kode.gs.html
// TAMBAHKAN FUNGSI BARU INI

/**
 * [BARU] Mengambil daftar lengkap siswa untuk ditampilkan di Portal Guru.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @returns {object} Objek berisi status dan daftar lengkap siswa.
 */
function getStudentListForGuru(spreadsheetId) {
    try {
        // Menggunakan kembali fungsi getStudents() yang sudah ada dan lengkap
        const students = getStudents(spreadsheetId); 
        return { status: 'success', data: students };
    } catch (e) {
        Logger.log(`getStudentListForGuru Error: ${e.message}`);
        return { status: 'error', message: e.message, data: [] };
    }
}

// File: Kode.gs.html
// TAMBAHKAN DUA FUNGSI BARU INI

/**
 * [BARU] Guru memperbarui data pribadinya (Nama & NIP).
 * Aksi ini TIDAK akan mengubah status 'Diubah Guru'.
 */
function updateGuruData_Guru(spreadsheetId, username, data) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_GURU);
    const usernames = sheet.getRange(2, 2, sheet.getLastRow() - 1, 1).getDisplayValues().flat();
    const guruIndex = usernames.findIndex(u => u === username);

    if (guruIndex === -1) {
      throw new Error("Profil guru tidak ditemukan untuk diperbarui.");
    }
    const rowToUpdate = guruIndex + 2;
    
    // Update Nama (kolom A) dan NIP (kolom E)
    sheet.getRange(rowToUpdate, 1).setValue(data.nama);
    sheet.getRange(rowToUpdate, 5).setValue(data.nip ? "'" + data.nip : '');
    
    return { status: 'success', message: 'Data pribadi berhasil diperbarui.' };
  } catch(e) {
    Logger.log(`updateGuruData_Guru Error: ${e.message}`);
    return { status: 'error', message: 'Gagal memperbarui data pribadi: ' + e.message };
  }
}

/**
 * [BARU] Guru memperbarui kredensial loginnya (Username & Password).
 * Aksi ini akan mengubah status 'Diubah Guru' menjadi YA.
 */
function updateGuruCredentials_Guru(spreadsheetId, oldUsername, newData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_GURU);
    const usernames = sheet.getRange(2, 2, sheet.getLastRow() - 1, 1).getDisplayValues().flat();
    const guruIndex = usernames.findIndex(u => u === oldUsername);

    if (guruIndex === -1) {
      throw new Error("Profil guru tidak ditemukan.");
    }
    const rowToUpdate = guruIndex + 2;
    
    // Cek duplikasi username jika diubah
    if(newData.username.toLowerCase() !== oldUsername.toLowerCase()) {
        const isDuplicate = usernames.some((u, index) => index !== guruIndex && u.toLowerCase() === newData.username.toLowerCase());
        if(isDuplicate) {
            return { status: 'error', message: 'Username baru sudah digunakan oleh guru lain.' };
        }
    }

    // Update Username (B), Password (C), dan set 'Diubah Guru' (F) menjadi 'YA'
    sheet.getRange(rowToUpdate, 2).setValue(newData.username);
    sheet.getRange(rowToUpdate, 3).setValue(newData.password);
    sheet.getRange(rowToUpdate, 6).setValue('YA');

    return { status: 'success', message: 'Kredensial login berhasil diperbarui.' };
  } catch(e) {
    Logger.log(`updateGuruCredentials_Guru Error: ${e.message}`);
    return { status: 'error', message: 'Gagal memperbarui akun login: ' + e.message };
  }
}

// File: Kode.gs.html
// TAMBAHKAN FUNGSI BARU INI

/**
 * [AKSI MASSAL BARU] Memperbarui kolom Kelas (N) dan Ruang Ujian (O) untuk beberapa siswa sekaligus.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<number>} rowNumbers Array berisi nomor baris siswa yang akan diupdate.
 * @param {string} newKelas Nama kelas baru.
 * @param {string} newRuang Nama ruang baru.
 * @returns {object} Status operasi.
 */
function bulkUpdateKelasAndRuang(spreadsheetId, rowNumbers, newKelas, newRuang) {
  try {
    if (!rowNumbers || rowNumbers.length === 0) {
      return { status: "info", message: "Tidak ada siswa yang dipilih." };
    }
    // Validasi input: setidaknya salah satu harus diisi.
    if (!newKelas && !newRuang) {
      return { status: "error", message: "Harap isi kolom Kelas atau Ruang." };
    }
      
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    const kelasColumn = 14;  // Kolom N
    const ruangColumn = 15;  // Kolom O
    
    // Looping melalui setiap baris yang dipilih untuk diupdate
    rowNumbers.forEach(rowNum => {
      if (newKelas) {
        sheet.getRange(rowNum, kelasColumn).setValue(newKelas);
      }
      if (newRuang) {
        sheet.getRange(rowNum, ruangColumn).setValue(newRuang);
      }
    });

    SpreadsheetApp.flush(); // Pastikan perubahan segera tersimpan
    
    // Kirim kembali daftar siswa terbaru setelah diupdate
    const updatedStudentList = getStudents(spreadsheetId);

    return { 
      status: "success", 
      message: `${rowNumbers.length} data siswa berhasil diupdate.`,
      updatedStudentList: updatedStudentList
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengupdate data kelas/ruang secara massal: " + e.message };
  }
}

/**
 * [VERSI FINAL] Menerima urutan NISN baru, menulis ulang data, dan mengembalikan daftar siswa
 * yang sudah terurut langsung dari memori untuk menghindari race condition.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<string>} orderedNisnList Array berisi NISN dalam urutan baru.
 * @returns {object} Status operasi dan daftar siswa yang sudah terupdate.
 */
function saveSiswaOrder(spreadsheetId, orderedNisnList) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (sheet.getLastRow() < 2) {
      return { status: "error", message: "Tidak ada data siswa untuk diurutkan." };
    }

    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn());
    const allData = dataRange.getValues();
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const nisnIndex = headers.indexOf("NISN");

    if (nisnIndex === -1) throw new Error("Kolom NISN tidak ditemukan.");

    const studentDataMap = new Map();
    allData.forEach(row => {
      studentDataMap.set(String(row[nisnIndex]), row);
    });

    const sortedData = orderedNisnList.map(nisn => {
      return studentDataMap.get(String(nisn));
    }).filter(Boolean);

    if (sortedData.length > 0 && sortedData.length === allData.length) {
      dataRange.clearContent();
      sheet.getRange(2, 1, sortedData.length, sortedData[0].length).setValues(sortedData);
    } else {
      throw new Error("Gagal mengurutkan, terjadi ketidaksesuaian data. Coba refresh halaman.");
    }
    
    SpreadsheetApp.flush();
    
    const updatedStudentList = sortedData.map((row, index) => {
      let tanggalLahirStr = '';
      if (row[6] && row[6] instanceof Date && !isNaN(row[6])) {
        tanggalLahirStr = Utilities.formatDate(row[6], Session.getScriptTimeZone(), "yyyy-MM-dd");
      }

      return {
        row: index + 2,
        nisn: String(row[0] || ''),
        nis: String(row[1] || ''),
        nomorUjian: String(row[2] || ''),
        nama: String(row[3] || ''),
        jenisKelamin: String(row[4] || ''),
        tempatLahir: String(row[5] || ''),
        tanggalLahir: tanggalLahirStr,
        alamat: String(row[7] || ''),
        telepon: String(row[8] || ''),
        emailSiswa: String(row[9] || ''),
        tahunMasuk: String(row[10] || ''),
        tahunLulus: String(row[11] || ''),
        tampilkanTranskrip: String(row[12] || 'TIDAK'),
        kelas: String(row[13] || ''),
        ruangUjian: String(row[14] || '')
      };
    });

    return { 
      status: "success", 
      message: "Urutan siswa berhasil disimpan.",
      updatedStudentList: updatedStudentList
    };

  } catch (e) {
    Logger.log(e);
    return { status: "error", message: `Gagal menyimpan urutan: ${e.message}` };
  }
}

// [PERUBAHAN] Tambahkan dua fungsi baru ini ke Kode.gs.html

/**
 * Membuat template Excel untuk diisi nilai oleh guru.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @param {string} className Nama kelas yang dipilih.
 * @param {string} mapelKode Kode mata pelajaran yang dipilih.
 * @param {string} tipeNilai Tipe nilai (misal: 'ujian' atau 'rapor_k4_ganjil').
 * @returns {object} Objek file Excel yang siap diunduh.
 */
function generateNilaiTemplateForGuru(spreadsheetId, className, mapelKode, tipeNilai, guruData) {
  let tempFile;
  try {
    const ss = SpreadsheetApp.create(`Template_Guru_${mapelKode}_${tipeNilai}_${new Date().getTime()}`);
    tempFile = DriveApp.getFileById(ss.getId());
    const sheet = ss.getSheets()[0];

    const students = getStudentsForGuru(spreadsheetId, className);
    const studentData = (students || []).map(s => ["'" + s.nisn, s.nama]);

    const allMapel = getMapel(spreadsheetId);
    const mapelInfo = allMapel.find(m => m.kode === mapelKode);
    if (!mapelInfo) throw new Error("Mata pelajaran tidak ditemukan.");
    
    if (!guruData || !guruData.nama) {
        throw new Error("Data guru tidak lengkap atau tidak terkirim dengan benar.");
    }

    let headers = ["NISN", "Nama Siswa"];
    let sheetName = "Nilai";
    let keteranganSingkatan = [];
    let fileNameSuffix = ''; // [PERUBAHAN] Variabel baru untuk nama file

    // [PERUBAHAN] Peta untuk menerjemahkan nama semester menjadi lebih deskriptif
    const semesterNameMap = {
        k4_ganjil: 'Kelas_4_Ganjil', k4_genap: 'Kelas_4_Genap',
        k5_ganjil: 'Kelas_5_Ganjil', k5_genap: 'Kelas_5_Genap',
        k6_ganjil: 'Kelas_6_Ganjil',
        k7_ganjil: 'Kelas_7_Ganjil', k7_genap: 'Kelas_7_Genap',
        k8_ganjil: 'Kelas_8_Ganjil', k8_genap: 'Kelas_8_Genap',
        k9_ganjil: 'Kelas_9_Ganjil',
        k10_ganjil: 'Kelas_10_Ganjil', k10_genap: 'Kelas_10_Genap',
        k11_ganjil: 'Kelas_11_Ganjil', k11_genap: 'Kelas_11_Genap',
        k12_ganjil: 'Kelas_12_Ganjil'
    };

    if (tipeNilai === 'ujian') {
      sheetName = "Nilai Ujian";
      fileNameSuffix = 'Ujian'; // [PERUBAHAN]
      if (mapelInfo.jenisUjian === 'Ujian Madrasah' || mapelInfo.jenisUjian === 'Keduanya') {
        headers.push("UM");
        keteranganSingkatan.push("UM = Ujian Madrasah");
      }
      if (mapelInfo.jenisUjian === 'Ujian Praktek' || mapelInfo.jenisUjian === 'Keduanya') {
        headers.push("UPr");
        keteranganSingkatan.push("UPr = Ujian Praktek");
      }
    } else if (tipeNilai.startsWith('rapor_')) {
      sheetName = "Nilai Rapor";
      const semesterKey = tipeNilai.substring(6); // Ambil bagian setelah 'rapor_'
      fileNameSuffix = `Rapor_${semesterNameMap[semesterKey] || semesterKey}`; // [PERUBAHAN]
      headers.push("Pengetahuan");
      headers.push("Keterampilan");
      keteranganSingkatan.push("Pengetahuan = Nilai Pengetahuan", "Keterampilan = Nilai Keterampilan");
    }
    sheet.setName(sheetName);

    const keteranganHeader = [
      ["Mata Pelajaran", `: ${mapelInfo.nama}`],
      ["Kelas", `: ${className}`],
      ["Guru", `: ${guruData.nama}`],
      ["Petunjuk", ": Isi nilai pada kolom yang sesuai. Kolom NISN dan Nama Siswa jangan diubah."],
      ["Keterangan", `: ${keteranganSingkatan.join('; ')}`]
    ];
    sheet.getRange("A1:B5").setValues(keteranganHeader);
    sheet.getRange("A1:A5").setFontWeight("bold");
    sheet.getRange("A1:B5").setFontStyle("italic");

    const headerRow = 7;
    sheet.getRange(headerRow, 1, 1, headers.length).setValues([headers]).setFontWeight("bold").setBackground("#d9ead3");

    if (studentData.length > 0) {
      sheet.getRange(headerRow + 1, 1, studentData.length, headers.length).setValues(
        studentData.map(studentRow => {
            const row = [...studentRow];
            while (row.length < headers.length) {
                row.push('');
            }
            return row;
        })
      );
    }
    sheet.getRange("A:A").setNumberFormat('@');
    sheet.autoResizeColumns(1, headers.length);

    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${ss.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    
    // [PERUBAHAN] Membuat nama file yang lebih deskriptif
    const finalFileName = `Template_Nilai_${mapelKode}_${className}_${fileNameSuffix}.xlsx`;

    return {
      fileName: finalFileName,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

/**
 * Mengimpor nilai dari Excel dan menyimpannya sebagai draf untuk guru.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @param {object} fileData Data file yang diunggah.
 * @param {string} username Username guru yang mengimpor.
 * @param {string} mapelKode Kode mata pelajaran.
 * @param {string} tipeNilai Tipe nilai yang diimpor.
 * @returns {object} Hasil proses impor.
 */
function importNilaiFromExcelForGuru(spreadsheetId, fileData, username, mapelKode, tipeNilai) {
    let tempFile;
    try {
        const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
        const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
        const tempSpreadsheetFile = Drive.Files.insert({ title: `temp_import_guru_${new Date().getTime()}` }, blob, { convert: true });
        tempFile = DriveApp.getFileById(tempSpreadsheetFile.id);
        const importSheet = SpreadsheetApp.openById(tempFile.getId()).getSheets()[0];
        const allData = importSheet.getDataRange().getDisplayValues();

        if (allData.length < 2) throw new Error("File kosong atau tidak berisi data yang valid.");
        
        // [PERBAIKAN] Logika baru untuk menemukan baris header secara dinamis
        let headerRowIndex = -1;
        for (let i = 0; i < allData.length; i++) {
            if (allData[i][0] === 'NISN' && allData[i][1] === 'Nama Siswa') {
                headerRowIndex = i;
                break;
            }
        }

        if (headerRowIndex === -1) {
            throw new Error("Kolom 'NISN' dan 'Nama Siswa' tidak ditemukan di file Excel. Pastikan menggunakan template yang benar.");
        }

        const headers = allData[headerRowIndex];
        const dataRows = allData.slice(headerRowIndex + 1); // Ambil semua baris di bawah header
        
        const nisnIndex = headers.indexOf("NISN");
        
        const nilaiToSave = {};
        let importedCount = 0;

        dataRows.forEach(row => {
            const nisn = row[nisnIndex];
            if (!nisn || nisn.trim() === '') return;

            if (tipeNilai === 'ujian') {
                const umIndex = headers.indexOf("UM");
                const uprIndex = headers.indexOf("UPr");
                if (umIndex !== -1 && row[umIndex] !== '') {
                    nilaiToSave[`${nisn}_um`] = row[umIndex];
                    importedCount++;
                }
                if (uprIndex !== -1 && row[uprIndex] !== '') {
                    nilaiToSave[`${nisn}_upr`] = row[uprIndex];
                    importedCount++;
                }
            } else if (tipeNilai.startsWith('rapor_')) {
                const pengIndex = headers.indexOf("Pengetahuan");
                const ketIndex = headers.indexOf("Keterampilan");
                if (pengIndex !== -1 && row[pengIndex] !== '') {
                    nilaiToSave[`${nisn}_peng`] = row[pengIndex];
                    importedCount++;
                }
                if (ketIndex !== -1 && row[ketIndex] !== '') {
                    nilaiToSave[`${nisn}_ket`] = row[ketIndex];
                    importedCount++;
                }
            }
        });

        if (importedCount === 0) {
            return { status: "info", message: "Tidak ada data nilai baru yang ditemukan di dalam file." };
        }

        const payload = {
            spreadsheetId,
            username,
            mapelKode,
            type: tipeNilai,
            nilai: nilaiToSave
        };
        const saveResult = saveGuruDraftNilai(payload);

        if (saveResult.status === 'success') {
            return { status: "success", message: `${importedCount} nilai berhasil diimpor sebagai draf.` };
        } else {
            throw new Error(saveResult.message);
        }

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: `Gagal mengimpor data: ${e.toString()}` };
    } finally {
        if (tempFile) {
            tempFile.setTrashed(true);
        }
    }
}
