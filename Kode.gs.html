// =================================================================
// KONFIGURASI GLOBAL
// =================================================================

// PENTING: Ganti dengan ID Spreadsheet Template yang sudah Anda buat.
// Anda bisa mendapatkan ID ini dari URL spreadsheet template Anda.
// Contoh URL: https://docs.google.com/spreadsheets/d/INI_ADALAH_ID_NYA/edit
const TEMPLATE_SPREADSHEET_ID = "14u86jJydOZu-nsTRTH_dOGIBhvLLIObLkbXsHrJ0xhM"; 

// Nama-nama Sheet yang digunakan di dalam spreadsheet data setiap sekolah.
const SHEET_PENGGUNA = "Data Pengguna"; // Ini ada di spreadsheet induk
const SHEET_DATA_SEKOLAH = "Data Sekolah";
const SHEET_DATA_SISWA = "Data Siswa";
const SHEET_MAPEL = "Data Mata Pelajaran";
const SHEET_BOBOT = "Data Bobot Nilai";
const SHEET_NILAI_UJIAN_MADRASAH = "Nilai Ujian Madrasah";
const SHEET_NILAI_UJIAN_PRAKTEK = "Nilai Ujian Praktek";
const SHEET_REKAP_UJIAN = "Rekap Nilai Ujian";
const SHEET_REKAP_RAPOR = "Rekap Nilai Rapor";
const SHEET_REKAP_IJAZAH = "Rekap Nilai Ijazah";
const SHEET_MAPEL_DEFAULT = "Mapel Default"; // Sheet di Spreadsheet Induk untuk mapel standar


/**
 * Fungsi utama yang dipanggil saat web app diakses.
 * @returns {HtmlService.HtmlOutput} Output HTML untuk ditampilkan.
 */
function doGet(e) {
  return HtmlService.createHtmlOutputFromFile('Index')
    .setTitle('Aplikasi Pengolahan Nilai Ijazah by Syamsul Bahri')
    .setFaviconUrl("https://uploadimage.io/images/2025/06/12/appbySyamsulBahri.png")
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// =================================================================
// FUNGSI KEAMANAN (PASSWORD HASHING) - [BARU]
// =================================================================

/**
 * [BARU] Menghasilkan string acak untuk digunakan sebagai salt.
 * @returns {string} Salt yang dihasilkan.
 */
function generateSalt() {
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

/**
 * [BARU & DIPERBAIKI] Menghasilkan hash dari password dan salt menggunakan SHA-256.
 * @param {string} password Password teks biasa.
 * @param {string} salt Salt yang akan digunakan.
 * @returns {string} Hash dalam format heksadesimal.
 */
function hashPassword(password, salt) {
  const saltedPassword = password + salt;
  const digest = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, saltedPassword, Utilities.Charset.UTF_8);
  
  let hexString = '';
  for (let i = 0; i < digest.length; i++) {
    // --- PERBAIKAN ---
    // Ubah 'const' menjadi 'let' agar nilainya bisa dimodifikasi.
    let byte = digest[i]; 
    if (byte < 0) {
      byte += 256;
    }
    // --- AKHIR PERBAIKAN ---
    
    let hex = byte.toString(16); // 'hex' bisa tetap 'let' atau 'const'
    if (hex.length === 1) {
      hexString += '0';
    }
    hexString += hex;
  }
  return hexString;
}

/**
 * [BARU] Memverifikasi password teks biasa terhadap format 'salt:hash' yang tersimpan.
 * @param {string} plainPassword Password yang dimasukkan pengguna saat login.
 * @param {string} saltAndHash String yang tersimpan di database ('salt:hash').
 * @returns {boolean} True jika password cocok, false jika tidak.
 */
function verifyPassword(plainPassword, saltAndHash) {
  try {
    const parts = saltAndHash.split(':');
    if (parts.length !== 2) {
      // Ini bukan format hash yang kita harapkan, anggap saja tidak valid.
      return false;
    }
    const salt = parts[0];
    const storedHash = parts[1];
    const newHash = hashPassword(plainPassword, salt);
    return newHash === storedHash;
  } catch (e) {
    Logger.log("Error during password verification: " + e.message);
    return false;
  }
}

// =================================================================
// FUNGSI AUTENTIKASI DAN MANAJEMEN AKUN (DENGAN OTP)
// =================================================================

/**
 * [MODIFIKASI] Membuat dan menyimpan OTP sementara menggunakan kunci cache yang konsisten.
 * @param {string} email Email tujuan untuk OTP.
 * @returns {string} OTP yang dibuat.
 */
function generateAndStoreOtp(email) {
  const otp = Math.floor(100000 + Math.random() * 900000).toString();
  const cache = CacheService.getScriptCache();
  // [PERBAIKAN] Gunakan email lowercase sebagai kunci cache untuk konsistensi
  const cacheKey = email.toLowerCase();
  cache.put(cacheKey, otp, 600); // 600 detik = 10 menit
  return otp;
}

/**
 * [MODIFIKASI] Memvalidasi OTP yang dimasukkan pengguna dengan logging tambahan.
 * @param {string} email Email yang diverifikasi.
 * @param {string} otp Kode OTP dari pengguna.
 * @returns {boolean} True jika valid, false jika tidak.
 */
function verifyOtp(email, otp) {
  const cache = CacheService.getScriptCache();
  // [PERBAIKAN] Gunakan email lowercase untuk mengambil dari cache
  const cacheKey = email.toLowerCase();
  const storedOtp = cache.get(cacheKey);

  // [DEBUG] Tambahkan logging untuk membantu melacak masalah di masa depan
  Logger.log(`Verifikasi OTP untuk email: ${email} (key: ${cacheKey})`);
  Logger.log(`OTP dari pengguna: "${otp}" (tipe: ${typeof otp})`);
  Logger.log(`OTP dari cache: "${storedOtp}" (tipe: ${typeof storedOtp})`);
  
  // Perbandingan ketat antara OTP yang disimpan (string) dan yang dimasukkan (string)
  const isValid = storedOtp != null && storedOtp === otp.toString();
  Logger.log(`Hasil validasi: ${isValid}`);
  
  return isValid;
}

/**
 * [MODIFIKASI] Mengirim email verifikasi, menggunakan email yang sudah dinormalisasi.
 * @param {string} email Email calon pengguna.
 * @returns {{status: string, message: string}} Hasil proses pengiriman.
 */
function sendVerificationEmail(email) {
  try {
    if (!email) {
      return { status: "error", message: "Email tidak boleh kosong." };
    }
    const normalizedEmail = email.toLowerCase(); // [PERBAIKAN] Normalisasi email

    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);

    if (userSheet.getLastRow() > 1) {
        const dataRange = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1);
        const existingEmails = dataRange.getValues().flat();
        // [PERBAIKAN] Bandingkan dengan email yang sudah dinormalisasi
        if (existingEmails.some(existingEmail => existingEmail.toLowerCase() === normalizedEmail)) {
          lock.releaseLock();
          return { status: "error", message: "Email sudah terdaftar. Silakan gunakan email lain." };
        }
    }
    
    lock.releaseLock();

    // [PERBAIKAN] Gunakan email yang sudah dinormalisasi untuk generate OTP
    const otp = generateAndStoreOtp(normalizedEmail);
    const subject = "Kode Verifikasi Pendaftaran Akun";
    const body = `
      <div style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2>Verifikasi Akun Anda</h2>
        <p>Terima kasih telah mendaftar. Silakan gunakan kode verifikasi di bawah ini untuk menyelesaikan proses pendaftaran Anda:</p>
        <p style="font-size: 24px; font-weight: bold; letter-spacing: 5px; background-color: #f0f0f0; padding: 10px 20px; border-radius: 5px; display: inline-block;">${otp}</p>
        <p>Kode ini hanya berlaku selama 10 menit.</p>
        <p>Jika Anda tidak merasa mendaftar, abaikan email ini.</p>
        <br>
        <p>Terima kasih,</p>
        <p>Tim Aplikasi Pengolahan Nilai Ijazah</p>
      </div>
    `;

    MailApp.sendEmail({
      to: email, // Kirim ke email asli, bukan yang lowercase
      subject: subject,
      htmlBody: body
    });

    return { status: "success", message: "Kode OTP telah dikirim ke email Anda. Silakan periksa kotak masuk atau folder spam." };

  } catch (error) {
    Logger.log(`sendVerificationEmail Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengirim email verifikasi: " + error.message };
  }
}


/**
 * [MODIFIKASI FINAL] Mendaftarkan pengguna baru setelah verifikasi OTP berhasil.
 * Secara otomatis mengatur Role='Pengguna' dan Status='Aktif'.
 * @param {{email: string, password: string, namaSekolah: string, jenjang: string}} userData Objek berisi data pengguna baru.
 * @param {string} otp Kode OTP yang dimasukkan pengguna.
 * @returns {{status: string, message: string}} Objek status pendaftaran.
 */
function registerUser(userData, otp) {
  try {
    const { email, password, namaSekolah, jenjang } = userData;

    if (!verifyOtp(email, otp)) {
      return { status: "error", message: "Kode OTP salah atau telah kedaluwarsa." };
    }
    
    if (TEMPLATE_SPREADSHEET_ID === "GANTI_DENGAN_ID_TEMPLATE_ANDA") {
      throw new Error("ID Spreadsheet Template belum diatur di dalam Kode.gs. Harap periksa instruksi.");
    }

    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // **[BARU]** Ambil nilai batas default dari sheet Konfigurasi
    const configSheet = ss.getSheetByName('Konfigurasi Sistem');
    const defaultLimit = configSheet ? configSheet.getRange("B2").getValue() : 100; // Default 100 jika sheet tidak ada
    let userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) {
      throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan di spreadsheet induk.`);
    }

    if (userSheet.getLastRow() > 1) {
        const dataRange = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1);
        const existingEmails = dataRange.getValues().flat();
        if (existingEmails.some(existingEmail => existingEmail.toLowerCase() === email.toLowerCase())) {
          lock.releaseLock();
          return { status: "error", message: "Email sudah terdaftar." };
        }
    }

    const templateFile = DriveApp.getFileById(TEMPLATE_SPREADSHEET_ID);
    const newSpreadsheetName = `Data Akademik - ${namaSekolah}`;
    const newFile = templateFile.makeCopy(newSpreadsheetName);
    const newSpreadsheetId = newFile.getId();

    const newSs = SpreadsheetApp.openById(newSpreadsheetId);
    const dataSekolahSheet = newSs.getSheetByName(SHEET_DATA_SEKOLAH);
    if (dataSekolahSheet) {
      dataSekolahSheet.getRange(2, 1).setValue(jenjang);
      dataSekolahSheet.getRange(2, 2).setValue(namaSekolah);
    }

    const userId = Utilities.getUuid();
    
    const salt = generateSalt();
    const hashedPassword = hashPassword(password, salt);
    const storedPasswordString = `${salt}:${hashedPassword}`; 

    // **[PERBAIKAN]** appendRow sekarang memiliki 9 kolom, termasuk Student Limit
    userSheet.appendRow([
        userId, 
        email, 
        storedPasswordString, 
        namaSekolah, 
        jenjang, 
        newSpreadsheetId, 
        'Pengguna', // Role
        'Aktif',    // Status
        defaultLimit // Student Limit
    ]);
    
    CacheService.getScriptCache().remove(email.toLowerCase());
    
    lock.releaseLock();
    return { status: "success", message: "Pendaftaran berhasil! Akun dan database sekolah Anda telah dibuat." };

  } catch (error) {
    Logger.log(error);
    return { status: "error", message: "Gagal mendaftar: " + error.message + " Stack: " + error.stack };
  }
}

/**
 * [MODIFIKASI FINAL] Memeriksa kredensial login.
 * Menangani kasus Superadmin yang tidak memiliki spreadsheetId.
 * @param {string} email Email pengguna.
 * @param {string} password Password pengguna.
 * @returns {object} Objek status login.
 */
function checkLogin(email, password) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet || userSheet.getLastRow() < 2) {
      return { status: "error", message: "Konfigurasi pengguna tidak ditemukan." };
    }

    const users = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 8).getValues();
    const userIndex = users.findIndex(userRow => userRow[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Email tidak terdaftar." };
    }

    const userRow = users[userIndex];
    const storedPassword = userRow[2].toString();
    let spreadsheetId = userRow[5]; // Kolom F
    const role = userRow[6] || 'Pengguna'; // Kolom G
    const status = userRow[7] || 'Aktif';   // Kolom H

    if (status !== 'Aktif') {
        return { status: "error", message: "Akun Anda saat ini tidak aktif. Silahkan hubungi Admin." };
    }

    // Untuk Superadmin, spreadsheetId boleh kosong.
    if (role === 'Superadmin') {
      spreadsheetId = null; 
    } else if (!spreadsheetId) {
      // Untuk pengguna biasa, spreadsheetId wajib ada.
      return { status: "error", message: "Akun pengguna ini tidak terkonfigurasi dengan benar (tidak ada Spreadsheet ID)." };
    }

    let passwordIsValid = false;
    if (storedPassword.includes(':')) {
      passwordIsValid = verifyPassword(password, storedPassword);
    } else {
      // Logika upgrade password lama (jika masih diperlukan)
      passwordIsValid = (storedPassword === password);
      if (passwordIsValid) {
        try {
          const salt = generateSalt();
          const newHashedPassword = hashPassword(password, salt);
          const newStoredPasswordString = `${salt}:${newHashedPassword}`;
          const rowToUpdate = userIndex + 2;
          userSheet.getRange(rowToUpdate, 3).setValue(newStoredPasswordString);
          Logger.log(`Password for ${email} successfully upgraded to hashed format.`);
        } catch (e) {
            Logger.log(`Failed to upgrade password for ${email}. Error: ${e.message}`);
        }
      }
    }

    if (passwordIsValid) {
        // ▼▼▼ TAMBAHKAN BARIS INI ▼▼▼
        const url = ScriptApp.getService().getUrl(); 

        // ▼▼▼ UBAH BARIS return LAMA ANDA DENGAN YANG BARU INI ▼▼▼
        return { 
            status: "success", 
            message: "Login berhasil.", 
            spreadsheetId: spreadsheetId, 
            email: userRow[1], 
            role: role, 
            webAppUrl: url // Tambahkan properti ini
        };
    } else {
        return { status: "error", message: "Password salah." };
    }

  } catch (error) {
    Logger.log(error);
    return { status: "error", message: "Kesalahan Server: " + error.message };
  }
}

/**
 * [BARU] Mengirimkan OTP untuk reset password.
 * @param {string} email Email pengguna yang terdaftar.
 * @returns {{status: string, message: string}} Hasil proses pengiriman.
 */
function sendPasswordResetOtp(email) {
  try {
    if (!email) {
      return { status: "error", message: "Email tidak boleh kosong." };
    }
    const normalizedEmail = email.toLowerCase();

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const users = userSheet.getRange(2, 2, userSheet.getLastRow() - 1, 1).getValues().flat();

    // Cek apakah email terdaftar
    const emailExists = users.some(existingEmail => existingEmail.toLowerCase() === normalizedEmail);
    if (!emailExists) {
      return { status: "error", message: "Email tidak terdaftar di sistem kami." };
    }

    const otp = generateAndStoreOtp(normalizedEmail); // Menggunakan kembali fungsi OTP yang sudah ada
    const subject = "Kode Verifikasi Reset Password";
    const body = `
      <div style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2>Reset Password Anda</h2>
        <p>Kami menerima permintaan untuk mereset password akun Anda. Gunakan kode di bawah ini untuk melanjutkan:</p>
        <p style="font-size: 24px; font-weight: bold; letter-spacing: 5px; background-color: #f0f0f0; padding: 10px 20px; border-radius: 5px; display: inline-block;">${otp}</p>
        <p>Kode ini hanya berlaku selama 10 menit.</p>
        <p>Jika Anda tidak merasa meminta reset password, abaikan email ini.</p>
      </div>
    `;

    MailApp.sendEmail({
      to: email,
      subject: subject,
      htmlBody: body
    });

    return { status: "success", message: "Kode OTP telah dikirim ke email Anda." };

  } catch (error) {
    Logger.log(`sendPasswordResetOtp Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengirim email verifikasi: " + error.message };
  }
}


/**
 * [BARU] Memverifikasi OTP dan mereset password pengguna.
 * @param {string} email Email pengguna.
 * @param {string} otp Kode OTP yang dimasukkan.
 * @param {string} newPassword Password baru yang akan diatur.
 * @returns {{status: string, message: string}} Hasil proses reset.
 */
function resetPasswordWithOtp(email, otp, newPassword) {
  try {
    // 1. Verifikasi OTP
    if (!verifyOtp(email, otp)) {
      return { status: "error", message: "Kode OTP salah atau telah kedaluwarsa." };
    }

    // 2. Hash password baru
    const salt = generateSalt();
    const hashedPassword = hashPassword(newPassword, salt);
    const newStoredPasswordString = `${salt}:${hashedPassword}`;

    // 3. Temukan dan perbarui password di spreadsheet
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 3).getValues(); // Ambil ID, email, password

    const userIndex = data.findIndex(row => row[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Terjadi kesalahan: Pengguna tidak ditemukan." };
    }

    // Update password di baris yang benar (baris spreadsheet = index array + 2)
    const rowToUpdate = userIndex + 2;
    userSheet.getRange(rowToUpdate, 3).setValue(newStoredPasswordString); // Kolom password (C) adalah kolom ke-3

    // Hapus OTP dari cache setelah berhasil digunakan
    CacheService.getScriptCache().remove(email.toLowerCase());

    return { status: "success", message: "Password Anda telah berhasil direset." };

  } catch (error) {
    Logger.log(`resetPasswordWithOtp Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mereset password: " + error.message };
  }
}

/**
 * [BARU] Mengubah password pengguna yang sedang login.
 * @param {string} email Email pengguna yang terdaftar.
 * @param {string} currentPassword Password saat ini yang dimasukkan pengguna.
 * @param {string} newPassword Password baru yang akan diatur.
 * @returns {{status: string, message: string}} Hasil proses perubahan password.
 */
function changeUserPassword(email, currentPassword, newPassword) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet) {
      throw new Error(`Sheet '${SHEET_PENGGUNA}' tidak ditemukan.`);
    }

    const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 3).getValues(); // Ambil ID, email, password
    const userIndex = data.findIndex(row => row[1].toLowerCase() === email.toLowerCase());

    if (userIndex === -1) {
      return { status: "error", message: "Terjadi kesalahan: Pengguna tidak ditemukan." };
    }

    const storedPasswordString = data[userIndex][2].toString();

    // 1. Verifikasi password saat ini
    const isCurrentPasswordValid = verifyPassword(currentPassword, storedPasswordString);
    if (!isCurrentPasswordValid) {
      return { status: "error", message: "Password Anda saat ini salah. Silakan coba lagi." };
    }

    // 2. Hash password baru
    const salt = generateSalt();
    const hashedPassword = hashPassword(newPassword, salt);
    const newStoredPasswordString = `${salt}:${hashedPassword}`;

    // 3. Perbarui password di spreadsheet
    const rowToUpdate = userIndex + 2; // Baris spreadsheet = index array + 2
    userSheet.getRange(rowToUpdate, 3).setValue(newStoredPasswordString); // Kolom password (C) adalah kolom ke-3

    return { status: "success", message: "Password Anda telah berhasil diubah." };

  } catch (error) {
    Logger.log(`changeUserPassword Error: ${error.toString()}`);
    return { status: "error", message: "Gagal mengubah password: " + error.message };
  }
}

// =================================================================
// FUNGSI UTILITAS UMUM
// =================================================================

/**
 * Helper function untuk membuka spreadsheet berdasarkan ID.
 * @param {string} spreadsheetId ID dari Google Sheet yang akan dibuka.
 * @returns {SpreadsheetApp.Spreadsheet} Objek Spreadsheet.
 */
function getSpreadsheet(spreadsheetId) {
  if (!spreadsheetId) {
    throw new Error("Spreadsheet ID tidak valid atau tidak diberikan.");
  }
  return SpreadsheetApp.openById(spreadsheetId);
}

/**
 * [BARU] Helper function untuk mengubah string menjadi Proper Case.
 * @param {string} str String yang akan diubah.
 * @returns {string} String dalam format Proper Case.
 */
function toProperCase(str) {
  if (!str || typeof str !== 'string') return '';
  return str.replace(/\w\S*/g, function(txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}


// =================================================================
// FUNGSI MANAJEMEN DATA SEKOLAH, SISWA, MAPEL, DLL.
// =================================================================

// File: Kode.gs

/**
 * [MODIFIKASI] Menyimpan data sekolah ke dalam sheet 'Data Sekolah', termasuk NSM.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} dataObj Objek berisi data sekolah.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveSchoolData(spreadsheetId, dataObj) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_DATA_SEKOLAH);
    
    // [MODIFIKASI] Set format kolom NSM (D), Kode Pos (J), dan Telepon (K) ke Plain Text
    sheet.getRange("D:D").setNumberFormat('@');
    sheet.getRange("J:K").setNumberFormat('@'); // Indeks kolom bergeser
    sheet.getRange("O:O").setNumberFormat('@'); // <-- TAMBAHKAN BARIS INI UNTUK NIP KEPSEK
    
    // [MODIFIKASI] Tambahkan dataObj.nsm ke dalam array
    const schoolDataRow = [
        dataObj.jenjang||"", dataObj.namaSekolah||"", dataObj.npsn||"", dataObj.nsm||"", // NSM ditambahkan di sini
        dataObj.alamat||"", dataObj.kelurahan||"", dataObj.kecamatan||"", dataObj.kabupaten||"", 
        dataObj.provinsi||"", dataObj.kodePos||"", dataObj.telepon||"", dataObj.email||"", 
        dataObj.website||"", dataObj.namaKepsek||"", dataObj.nipKepsek||""
    ];
    // [MODIFIKASI] Pastikan header "NSM" ada jika belum ada
    if (sheet.getRange("D1").getValue() !== "NSM") {
      sheet.insertColumnAfter(3); // Sisipkan kolom baru setelah kolom C (NPSN)
      sheet.getRange("D1").setValue("NSM").setFontWeight("bold");
    }

    sheet.getRange(2, 1, 1, schoolDataRow.length).setValues([schoolDataRow]);
    return { status: "success", message: "Data sekolah berhasil diperbarui." };
  } catch (error) {
    Logger.log(error);
    return { status: "error", message: "Gagal menyimpan data sekolah: " + error.message };
  }
}

// File: Kode.gs

/**
 * [MODIFIKASI] Mengambil data sekolah dari sheet 'Data Sekolah', termasuk NSM.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object|null} Objek data sekolah atau null jika gagal.
 */
function getSchoolData(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SEKOLAH);
    if (!sheet || sheet.getLastRow() < 2) return null;

    // [MODIFIKASI] Set format kolom NSM, Kode Pos, dan Telepon ke Plain Text saat mengambil data
    sheet.getRange("D:D").setNumberFormat('@');
    sheet.getRange("J:K").setNumberFormat('@'); // Indeks kolom bergeser
    sheet.getRange("O:O").setNumberFormat('@'); // <-- TAMBAHKAN BARIS INI UNTUK NIP KEPSEK

    // [MODIFIKASI] Ubah jangkauan pengambilan data dari A2:N2 menjadi A2:O2
    const values = sheet.getRange("A2:O2").getValues()[0];
    
    // [MODIFIKASI] Tambahkan 'nsm' dan sesuaikan indeks kolom lainnya
    return {
        jenjang:values[0], 
        namaSekolah:values[1], 
        npsn:values[2], 
        nsm:values[3], // NSM ada di indeks 3
        alamat:values[4], 
        kelurahan:values[5], 
        kecamatan:values[6], 
        kabupaten:values[7], 
        provinsi:values[8], 
        kodePos:values[9], 
        telepon:values[10], 
        email:values[11], 
        website:values[12], 
        namaKepsek:values[13], 
        nipKepsek:values[14]
    };
  } catch (error) {
    Logger.log(error);
    return null;
  }
}

/**
 * [MODIFIKASI & PERBAIKAN FINAL] Mengambil daftar siswa dari sheet 'Data Siswa'.
 * Memastikan semua data yang relevan dibaca sebagai Teks (String) untuk mencegah error.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {Array<object>} Array objek data siswa.
 */
function getStudents(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (!sheet || sheet.getLastRow() < 2) return [];

    // Format kolom yang rawan salah interpretasi menjadi Teks
    sheet.getRange("A:B").setNumberFormat('@'); // NISN & NIS
    sheet.getRange("E:E").setNumberFormat('@'); // <-- TAMBAHAN: Paksa Tempat Lahir menjadi Teks
    sheet.getRange("H:H").setNumberFormat('@'); // Telepon

    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 11);
    const values = dataRange.getValues();

    return values.map((row, index) => {
      let tanggalLahirStr = '';
      // Cek apakah kolom tanggal lahir (indeks 5) adalah objek Date yang valid
      if (row[5] && row[5] instanceof Date && !isNaN(row[5])) {
        tanggalLahirStr = Utilities.formatDate(row[5], Session.getScriptTimeZone(), "yyyy-MM-dd");
      }

      return {
        row: index + 2,
        nisn: String(row[0] || ''),
        nis: String(row[1] || ''),
        nama: String(row[2] || ''),
        jenisKelamin: String(row[3] || ''),
        tempatLahir: String(row[4] || ''), // Selalu baca sebagai string
        tanggalLahir: tanggalLahirStr,
        alamat: String(row[6] || ''),
        telepon: String(row[7] || ''),
        emailSiswa: String(row[8] || ''),
        tahunMasuk: String(row[9] || ''),
        tahunLulus: String(row[10] || '')
      };
    });
  } catch (e) {
    Logger.log(`getStudents Error: ${e}`);
    return [];
  }
}

/**
 * [MODIFIKASI & PERBAIKAN FINAL] Menambahkan siswa baru atau mendeteksi konflik jika NISN sudah ada.
 * Kini juga memeriksa batas siswa sebelum menambahkan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} studentData Objek data siswa baru.
 * @param {string} userEmail Email pengguna yang melakukan aksi (dikirim dari frontend).
 * @returns {{status: string, message: string, oldData?: object, newData?: object}} Status penambahan.
 */
function addStudent(spreadsheetId, studentData, userEmail) { // <-- [PERBAIKAN] Tambahkan parameter userEmail
  try {
    // [PERBAIKAN] Panggil fungsi checkStudentLimit dengan userEmail yang dikirim dari frontend
    const limitCheck = checkStudentLimit(spreadsheetId, userEmail); 
    if (limitCheck.limitReached) {
        return { status: "error", message: limitCheck.message };
    }

    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    
    // Cek apakah ada data siswa
    if (sheet.getLastRow() > 1) {
      const allStudents = getStudents(spreadsheetId);
      const existingStudent = allStudents.find(s => s.nisn.toString() === studentData.nisn.toString());

      if (existingStudent) {
        const isIdentical = areStudentsIdentical(existingStudent, studentData);
        if (isIdentical) {
          return { status: "duplicate", message: "Data siswa dengan NISN ini sudah ada dan semua datanya identik." };
        } else {
          return {
            status: "conflict",
            message: "NISN ini sudah terdaftar dengan data yang berbeda.",
            oldData: existingStudent,
            newData: studentData
          };
        }
      }
    }

    // Jika tidak ada konflik, tambahkan siswa baru
    const nextRow = sheet.getLastRow() + 1;
    sheet.getRange(nextRow, 1, 1, 2).setNumberFormat('@');
    const tanggalLahirObject = studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '';
    sheet.getRange(nextRow, 1, 1, 2).setNumberFormat('@');
    sheet.getRange(nextRow, 8, 1, 1).setNumberFormat('@');

    const newRowData = [
        studentData.nisn, studentData.nis, studentData.nama, studentData.jenisKelamin, 
        toProperCase(studentData.tempatLahir), tanggalLahirObject, studentData.alamat, 
        studentData.telepon, studentData.emailSiswa, studentData.tahunMasuk, studentData.tahunLulus
    ];
    sheet.getRange(nextRow, 1, 1, newRowData.length).setValues([newRowData]);
    
    return { status: "success", message: `Siswa "${studentData.nama}" berhasil ditambahkan.` };

  } catch (e) { 
    Logger.log(e); 
    return { status: "error", message: "Gagal memproses data siswa: " + e.message }; 
  }
}


/**
 * [MODIFIKASI] Memperbarui data siswa dengan tambahan validasi duplikasi NISN.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} studentData Objek data siswa yang akan diupdate, termasuk studentRow.
 * @returns {{status: string, message: string}} Status pembaruan.
 */
function updateStudent(spreadsheetId, studentData) {
  try {
    const allStudents = getStudents(spreadsheetId);
    const duplicateStudent = allStudents.find(s =>
      s.nisn.toString().trim() === studentData.nisn.toString().trim() &&
      s.row != studentData.studentRow
    );

    if (duplicateStudent) {
      return { status: "error", message: `Gagal: NISN "${studentData.nisn}" sudah digunakan oleh siswa lain (${duplicateStudent.nama}).` };
    }

    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    
    // [PERIKSA ULANG] Susunan array ini harus cocok persis dengan urutan kolom di sheet
    const rowToUpdate = [
      studentData.nisn,
      studentData.nis,
      studentData.nama,
      studentData.jenisKelamin,
      toProperCase(studentData.tempatLahir),
      studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '',
      studentData.alamat,
      studentData.telepon,
      studentData.emailSiswa,
      studentData.tahunMasuk,
      studentData.tahunLulus
    ];

    const targetRange = sheet.getRange(studentData.studentRow, 1, 1, rowToUpdate.length);

    sheet.getRange(studentData.studentRow, 1, 1, 2).setNumberFormat('@');
    sheet.getRange(studentData.studentRow, 8, 1, 1).setNumberFormat('@');

    targetRange.setValues([rowToUpdate]);

    return { status: "success", message: `Data siswa "${studentData.nama}" berhasil diperbarui.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data: " + e.message };
  }
}

/**
 * Menghapus data siswa dari sheet 'Data Siswa'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {number} rowNumber Nomor baris yang akan dihapus.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteStudent(spreadsheetId, rowNumber) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    sheet.deleteRow(rowNumber);
    return { status: "success", message: "Data siswa berhasil dihapus." };
  } catch (e) { Logger.log(e); return { status: "error", message: "Gagal menghapus data: " + e.message }; }
}

/**
 * Menghapus semua data siswa dari sheet 'Data Siswa'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllStudents(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    if (sheet && sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }
    return { status: "success", message: "Semua data siswa telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data siswa: " + e.message };
  }
}

/**
 * Menghasilkan template Excel untuk impor data siswa.
 * @returns {object} Objek berisi data file template.
 */
function generateSiswaTemplate() {
  let tempFile;
  try {
    const templateName = `Template_Import_Siswa_${new Date().getTime()}`;
    const ss = SpreadsheetApp.create(templateName);
    tempFile = DriveApp.getFileById(ss.getId());
    
    const sheet = ss.getSheets()[0];
    const headers = [
      "NISN", "NIS (2 digit tahun masuk, 4 digit no. urut)", "Nama Lengkap", "Jenis Kelamin (L/P)", 
      "Tempat Lahir", "Tanggal Lahir (Format: YYYY-MM-DD)",
      "Alamat Lengkap Siswa", "Nomor Telepon", "Email", "Tahun Masuk", "Tahun Lulus"
    ];
    sheet.appendRow(headers);
    sheet.getRange("A1:K1").setFontWeight("bold").setBackground("#d9ead3"); // Ubah E1 menjadi J1
    
    // Set format kolom ke teks
    sheet.getRange("A:B").setNumberFormat("@"); // NISN & NIS
    sheet.getRange("H:H").setNumberFormat("@"); // Nomor Telepon
    
    sheet.setColumnWidths(1, 5, 150); // Kolom A-E
    sheet.setColumnWidth(7, 250); // Kolom G (Alamat)
    sheet.setColumnWidths(8, 4, 150); // Kolom G-J
    
    sheet.getRange("F:F").setNumberFormat("yyyy-mm-dd");

    SpreadsheetApp.flush();

    const url = `https://www.googleapis.com/drive/v3/files/${ss.getId()}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
    const response = UrlFetchApp.fetch(url, {
      headers: { Authorization: `Bearer ${ScriptApp.getOAuthToken()}` },
      muteHttpExceptions: true
    });

    const blob = response.getBlob();
    return {
      fileName: 'Template_Import_Siswa.xlsx',
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      base64Data: Utilities.base64Encode(blob.getBytes())
    };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    if (tempFile) {
      tempFile.setTrashed(true);
    }
  }
}

/**
 * [MODIFIKASI FINAL & PERBAIKAN] Mengimpor data dari file Excel, dengan logika untuk menambah, memperkaya, atau mendeteksi konflik.
 * Kini juga memeriksa dan MEMBATASI impor sesuai kuota siswa.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} fileData Data file yang diunggah.
 * @param {string} sheetName Nama sheet tujuan.
 * @param {string} userEmail Email pengguna yang melakukan aksi (dikirim dari frontend).
 * @returns {object} Hasil proses impor yang detail.
 */
function importFromExcel(spreadsheetId, fileData, sheetName, userEmail) {
    let tempFile;
    try {
        const decoded = Utilities.base64Decode(fileData.content, Utilities.Charset.UTF_8);
        const blob = Utilities.newBlob(decoded, fileData.mimeType, fileData.fileName);
        const tempSpreadsheetFile = Drive.Files.insert({
            title: `temp_import_${new Date().getTime()}`
        }, blob, {
            convert: true
        });
        tempFile = DriveApp.getFileById(tempSpreadsheetFile.id);
        const importSheet = SpreadsheetApp.openById(tempFile.getId()).getSheets()[0];
        const data = importSheet.getDataRange().getValues();

        if (data.length <= 1) throw new Error("File kosong atau hanya berisi header.");
        data.shift(); // Hapus header

        const targetSpreadsheet = getSpreadsheet(spreadsheetId);
        let targetSheet = targetSpreadsheet.getSheetByName(sheetName);

        if (sheetName === SHEET_DATA_SISWA) {
            // [PERBAIKAN UTAMA] Logika pengecekan kuota diubah total
            // 1. Dapatkan informasi kuota yang akurat (limit, terpakai, sisa)
            const quotaInfo = getStudentQuotaInfo(userEmail);
            if (quotaInfo.status === 'error') {
                return { status: "error", message: quotaInfo.message };
            }

            let remainingSlots = quotaInfo.remaining;
            // Jika kuota tak terbatas, beri nilai yang sangat besar.
            if (isNaN(remainingSlots) || remainingSlots < 0) {
                 remainingSlots = 1000000; // Angka besar untuk "tak terbatas"
            }

            if (remainingSlots <= 0) {
                return { status: "error", message: `Impor dibatalkan. Kuota siswa Anda sudah penuh (${quotaInfo.usedCount}/${quotaInfo.totalLimit}).` };
            }
            // --- Akhir dari logika kuota baru ---

            targetSheet.getRange("A:B").setNumberFormat("@");
            const existingStudents = getStudents(spreadsheetId);
            const existingNisnMap = new Map();
            existingStudents.forEach(s => {
                if (s.nisn) existingNisnMap.set(s.nisn.toString().trim(), s);
            });

            const newStudents = [];
            const enrichedStudents = [];
            const conflicts = [];
            const skippedDuplicates = [];
            const skippedDueToLimit = []; // [BARU] Array untuk menampung siswa yang dilewati karena kuota penuh
            const processedNisns = new Set();

            data.forEach((row) => {
                const nisn = (row[0] || '').toString().trim();
                const namaFromFile = (row[2] || '').toString().trim();
                if (!nisn || !namaFromFile) return;
                if (processedNisns.has(nisn)) {
                    skippedDuplicates.push({
                        nisn,
                        nama: namaFromFile,
                        reason: 'Duplikat di dalam file import.'
                    });
                    return;
                }
                processedNisns.add(nisn);

                if (existingNisnMap.has(nisn)) {
                    // Logika untuk memperkaya data atau konflik (tidak berubah)
                    const existingStudent = existingNisnMap.get(nisn);
                    const newData = {
                        nisn: nisn, nis: row[1] || '', nama: namaFromFile, jenisKelamin: row[3] || '',
                        tempatLahir: toProperCase(row[4] || ''),
                        tanggalLahir: row[5] ? Utilities.formatDate(new Date(row[5]), Session.getScriptTimeZone(), "yyyy-MM-dd") : '',
                        alamat: row[6] || '', telepon: row[7] || '', emailSiswa: row[8] || '',
                        tahunMasuk: row[9] || '', tahunLulus: row[10] || ''
                    };
                    const isIdentical = areStudentsIdentical(existingStudent, newData);
                    if (!isIdentical) {
                        conflicts.push({ nisn: nisn, rowToUpdate: existingStudent.row, oldData: existingStudent, newData: newData });
                    } else {
                        // ... logika enrich atau skip (tidak diubah)
                        let isEnriched = false;
                        const finalData = { ...existingStudent };
                        Object.keys(newData).forEach(key => {
                            if (!finalData[key] && newData[key]) {
                                finalData[key] = newData[key];
                                isEnriched = true;
                            }
                        });
                        if (isEnriched) {
                            enrichedStudents.push({ ...finalData, studentRow: existingStudent.row });
                        } else {
                            skippedDuplicates.push({ nisn, nama: namaFromFile, reason: 'Data sudah ada dan identik.' });
                        }
                    }
                } else {
                    // [PERBAIKAN UTAMA] Logika untuk siswa baru
                    // Cek apakah masih ada slot tersisa sebelum menambahkan.
                    if (remainingSlots > 0) {
                        if (row[4]) {
                            row[4] = toProperCase(row[4]);
                        }
                        newStudents.push(row);
                        remainingSlots--; // Kurangi jatah slot setiap kali menambahkan siswa baru
                    } else {
                        // Jika tidak ada slot, masukkan ke daftar yang dilewati
                        skippedDueToLimit.push({
                            nisn: nisn,
                            nama: namaFromFile,
                            reason: 'Batas kuota siswa tercapai.'
                        });
                    }
                }
            });

            if (newStudents.length > 0) {
                targetSheet.getRange(targetSheet.getLastRow() + 1, 1, newStudents.length, newStudents[0].length).setValues(newStudents);
            }
            if (enrichedStudents.length > 0) {
                batchUpdateStudents(spreadsheetId, enrichedStudents);
            }

            return {
                status: "partial",
                message: "Proses impor siswa selesai.",
                newCount: newStudents.length,
                enrichedCount: enrichedStudents.length,
                skippedCount: skippedDuplicates.length,
                conflictCount: conflicts.length,
                conflicts: conflicts,
                skippedLimitCount: skippedDueToLimit.length, // [BARU] Kirim jumlah yang dilewati karena limit
                skippedLimitData: skippedDueToLimit // [BARU] Kirim data yang dilewati
            };
        } else {
            // Logika untuk sheet lain (tidak diubah)
            const rowsToAppend = data.filter(row => row.some(cell => cell.toString().trim() !== ""));
            if (rowsToAppend.length > 0) {
                targetSheet.getRange(targetSheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
            }
            return { status: "success", message: `${rowsToAppend.length} data berhasil diimpor ke sheet ${sheetName}.` };
        }

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: `Gagal mengimpor data: ${e.toString()}` };
    } finally {
        if (tempFile) {
            tempFile.setTrashed(true);
        }
    }
}

/**
 * Mengambil daftar mata pelajaran dari sheet 'Data Mata Pelajaran'.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {Array<object>} Array objek data mata pelajaran.
 */
function getMapel(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    if (!sheet || sheet.getLastRow() < 2) return [];
    const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4);
    const values = dataRange.getValues();
    return values.map((row, index) => ({ row: index + 2, kode: row[0], nama: row[1], kelompok: row[2], jenisUjian: row[3] || '' }));
  } catch (e) { Logger.log(e); return []; }
}

// HAPUS fungsi addMapel(spreadsheetId, mapelData) yang lama.

/**
 * [MODIFIKASI] Menambahkan beberapa mata pelajaran sekaligus (input massal)
 * dengan validasi duplikasi kode yang efisien.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} mapelArray Array objek data mata pelajaran baru.
 * @returns {{status: string, message: string}} Status penambahan.
 */
function addMultipleMapel(spreadsheetId, mapelArray) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(SHEET_MAPEL);

        // 1. Ambil semua kode mapel yang ada dalam satu kali panggilan
        const existingMapel = getMapel(spreadsheetId);
        const existingCodes = new Set(existingMapel.map(m => m.kode.toString().trim().toLowerCase()));
        
        const rowsToAppend = [];
        const codesInThisBatch = new Set();
        let skippedCount = 0;

        // 2. Loop melalui data baru dari frontend
        for (const mapelData of mapelArray) {
            const newCode = (mapelData.kode || '').toString().trim().toLowerCase();
            const newName = (mapelData.nama || '').toString().trim();

            // Lakukan validasi
            if (!newCode || !newName) {
                // Lewati baris yang tidak lengkap
                skippedCount++;
                continue;
            }

            // Cek duplikasi dengan data yang sudah ada DI SHEET dan DI DALAM BATCH ini
            if (existingCodes.has(newCode) || codesInThisBatch.has(newCode)) {
                skippedCount++;
                continue;
            }

            // Atur nilai default untuk Jenis Ujian jika kosong
            const jenisUjian = mapelData.jenisUjian || 'Ujian Madrasah';
            
            // Tambahkan ke daftar yang akan disimpan
            rowsToAppend.push([mapelData.kode, newName, mapelData.kelompok, jenisUjian]);
            codesInThisBatch.add(newCode); // Catat kode ini agar tidak ada duplikat dalam satu kali simpan
        }
        
        // 3. Simpan semua baris baru dalam satu operasi (jika ada)
        if (rowsToAppend.length > 0) {
            sheet.getRange(sheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);
        }

        // 4. Buat pesan laporan
        let message = `${rowsToAppend.length} mata pelajaran berhasil ditambahkan.`;
        if (skippedCount > 0) {
            message += ` ${skippedCount} mapel dilewati karena tidak lengkap atau kode duplikat.`;
        }

        return { status: "success", message: message };

    } catch (e) {
        Logger.log(e);
        return { status: "error", message: "Gagal menambah mapel secara massal: " + e.message };
    }
}

/**
 * Memperbarui data mata pelajaran.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} mapelData Data mata pelajaran yang akan diupdate.
 * @returns {{status: string, message: string}} Status pembaruan.
 */
function updateMapel(spreadsheetId, mapelData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    const rowToUpdate = [mapelData.kode, mapelData.nama, mapelData.kelompok, mapelData.jenisUjian];
    sheet.getRange(mapelData.mapelRow, 1, 1, rowToUpdate.length).setValues([rowToUpdate]);
    return { status: "success", message: `Mata Pelajaran "${mapelData.nama}" berhasil diperbarui.` };
  } catch (e) { Logger.log(e); return { status: "error", message: "Gagal memperbarui data mapel: " + e.message }; }
}

/**
 * Menghapus mata pelajaran.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {number} rowNumber Nomor baris yang akan dihapus.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteMapel(spreadsheetId, rowNumber) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    sheet.deleteRow(rowNumber);
    return { status: "success", message: "Mata pelajaran berhasil dihapus." };
  } catch (e) { Logger.log(e); return { status: "error", message: "Gagal menghapus mapel: " + e.message }; }
}

/**
 * Menghapus semua mata pelajaran.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllMapel(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_MAPEL);
    if (sheet && sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }
    return { status: "success", message: "Semua data mata pelajaran telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data mata pelajaran: " + e.message };
  }
}

/**
 * Mengimpor daftar mata pelajaran standar berdasarkan jenjang sekolah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Hasil proses impor.
 */
function importMapelBySystem(spreadsheetId) {
  try {
    const userSs = getSpreadsheet(spreadsheetId);
    const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang;

    if (!jenjang) {
      return { status: 'error', message: 'Jenjang sekolah belum diatur. Harap atur di menu Data Sekolah terlebih dahulu.' };
    }

    const masterSs = SpreadsheetApp.getActiveSpreadsheet();
    const mapelDefaultSheet = masterSs.getSheetByName(SHEET_MAPEL_DEFAULT);
    if (!mapelDefaultSheet) {
      return { status: 'error', message: `Sheet '${SHEET_MAPEL_DEFAULT}' tidak ditemukan di spreadsheet master.` };
    }

    const defaultMapelData = mapelDefaultSheet.getDataRange().getValues();
    defaultMapelData.shift(); // Hapus header

    const mapelForJenjang = defaultMapelData
      .filter(row => row[0] === jenjang) // Filter berdasarkan jenjang
      .map(row => [row[1], row[2], row[3], row[4]]); // Ambil kolom B-E (Kode, Nama, Kelompok, Jenis Ujian)

    if (mapelForJenjang.length === 0) {
      return { status: 'info', message: `Tidak ada mata pelajaran default yang ditemukan untuk jenjang ${jenjang}.`};
    }
    
    const existingMapel = getMapel(spreadsheetId);
    const existingMapelCodes = new Set(existingMapel.map(m => m.kode.toString().trim()));

    const newMapel = mapelForJenjang.filter(row => !existingMapelCodes.has(row[0].toString().trim()));
    const skippedCount = mapelForJenjang.length - newMapel.length;

    if (newMapel.length > 0) {
      const targetSheet = userSs.getSheetByName(SHEET_MAPEL);
      targetSheet.getRange(targetSheet.getLastRow() + 1, 1, newMapel.length, newMapel[0].length).setValues(newMapel);
    }

    let message = `${newMapel.length} mata pelajaran berhasil diimpor.`;
    if (skippedCount > 0) {
      message += ` ${skippedCount} mata pelajaran dilewati karena kode sudah ada.`;
    }

    return { status: "success", message: message, newCount: newMapel.length, skippedCount: skippedCount };

  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengimpor dari sistem: " + e.message };
  }
}

/**
 * Menyimpan data bobot nilai.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} bobotData Objek berisi bobot nilai.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function saveBobot(spreadsheetId, bobotData) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(SHEET_BOBOT);
    const bobotRow = [bobotData.bobotUjian, bobotData.bobotRapor];
    if (sheet.getLastRow() >= 2) sheet.getRange("A2:B2").clearContent();
    sheet.getRange(2, 1, 1, bobotRow.length).setValues([bobotRow]);
    return { status: "success", message: "Bobot nilai berhasil disimpan." };
  } catch (e) { Logger.log(e); return { status: "error", message: "Gagal menyimpan bobot nilai: " + e.message }; }
}

/**
 * Mengambil data bobot nilai, atau mengaturnya ke default jika belum ada.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi bobot nilai.
 */
function getBobot(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_BOBOT);
    if (!sheet) {
      return { bobotUjian: 40, bobotRapor: 60 };
    }

    if (sheet.getLastRow() >= 2) {
        const values = sheet.getRange("A2:B2").getValues()[0];
        if (values[0] !== '' && values[1] !== '' && !isNaN(values[0]) && !isNaN(values[1])) {
            return { bobotUjian: values[0], bobotRapor: values[1] };
        }
    }
    
    const defaultBobot = { bobotUjian: 40, bobotRapor: 60 };
    sheet.getRange(2, 1, 1, 2).setValues([[defaultBobot.bobotUjian, defaultBobot.bobotRapor]]);
    
    return defaultBobot;
  } catch (e) { 
    Logger.log('Error di getBobot: ' + e.message); 
    return { bobotUjian: 40, bobotRapor: 60 }; 
  }
}

/**
 * Mengambil daftar mapel berdasarkan jenis ujian.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} jenis Jenis ujian ('madrasah' atau 'praktek').
 * @returns {Array<object>} Array objek data mata pelajaran.
 */
function getMapelByJenis(spreadsheetId, jenis) {
  const allMapel = getMapel(spreadsheetId);
  if (jenis === 'madrasah') return allMapel.filter(m => m.jenisUjian === 'Ujian Madrasah' || m.jenisUjian === 'Keduanya');
  if (jenis === 'praktek') return allMapel.filter(m => m.jenisUjian === 'Ujian Praktek' || m.jenisUjian === 'Keduanya');
  return [];
}

/**
 * Menyimpan data nilai ujian.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} data Objek berisi jenis dan data nilai.
 * @returns {object} Status penyimpanan.
 */
function saveNilai(spreadsheetId, data) {
  const { jenis, nilai } = data;
  const sheetName = jenis === 'madrasah' ? SHEET_NILAI_UJIAN_MADRASAH : SHEET_NILAI_UJIAN_PRAKTEK;
  const mapelList = getMapelByJenis(spreadsheetId, jenis);
  return processAndSaveScores(spreadsheetId, sheetName, mapelList, nilai);
}

/**
 * Menyimpan data nilai rapor.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {object} data Objek berisi semester, jenis, dan data nilai.
 * @returns {object} Status penyimpanan.
 */
function saveNilaiRapor(spreadsheetId, data) {
  const { semesterKey, jenisNilai, nilai } = data;
  const sheetName = `Rapor_${jenisNilai}_${semesterKey}`;
  const mapelList = getMapel(spreadsheetId);
  return processAndSaveScores(spreadsheetId, sheetName, mapelList, nilai);
}

/**
 * Mengambil data nilai yang sudah ada dari sebuah sheet.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet nilai.
 * @returns {object} Objek berisi nilai yang sudah ada, dengan NISN sebagai key.
 */
function getExistingNilai(spreadsheetId, sheetName) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() < 2) return {};
    sheet.getRange("A:A").setNumberFormat('@');
    const data = sheet.getDataRange().getValues();
    const headers = data.shift();
    const nisnIndex = headers.indexOf("NISN");
    const existingScores = {};
    data.forEach(row => {
      const nisn = row[nisnIndex];
      if (nisn) {
          existingScores[nisn] = {};
          headers.forEach((header, index) => {
              if (index > 1) existingScores[nisn][header] = row[index];
          });
      }
    });
    return existingScores;
  } catch(e) { Logger.log(e); return {}; }
}

/**
 * Memproses dan menyimpan data nilai ke sheet yang ditentukan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet tujuan.
 * @param {Array<object>} mapelList Daftar mata pelajaran.
 * @param {Array<object>} nilai Daftar nilai.
 * @returns {{status: string, message: string}} Status penyimpanan.
 */
function processAndSaveScores(spreadsheetId, sheetName, mapelList, nilai) {
  const ss = getSpreadsheet(spreadsheetId);
  let sheet = ss.getSheetByName(sheetName);
  const headers = ["NISN", "Nama Lengkap", ...mapelList.map(m => m.kode)];
  try {
    if (!sheet) sheet = ss.insertSheet(sheetName);
    sheet.clear(); 
    sheet.appendRow(headers);
    sheet.getRange("A:A").setNumberFormat('@');
    sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold");
    const rows = nilai.map(n => {
      const rowData = [n.nisn, n.nama];
      mapelList.forEach(mapel => {
        rowData.push(n.scores[mapel.kode] || '');
      });
      return rowData;
    });
    if (rows.length > 0) sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
    return { status: 'success', message: `Data nilai untuk sheet '${sheetName}' berhasil disimpan.` };
  } catch (e) { Logger.log(e); return { status: 'error', message: `Gagal menyimpan data: ${e.message}` }; }
}

// =================================================================
// FUNGSI REKAPITULASI NILAI
// =================================================================

/**
 * Mengambil data dari sebuah sheet dan mengubahnya menjadi objek dengan NISN sebagai key.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet.
 * @returns {object} Data sheet dalam bentuk objek.
 */
function getSheetDataAsObject(spreadsheetId, sheetName) {
    try {
        const ss = getSpreadsheet(spreadsheetId);
        const sheet = ss.getSheetByName(sheetName);
        if (!sheet || sheet.getLastRow() < 2) return {};
        sheet.getRange("A:A").setNumberFormat('@');
        const data = sheet.getDataRange().getValues();
        const headers = data.shift();
        const nisnIndex = headers.indexOf("NISN");
        if (nisnIndex === -1) return {};

        const dataObj = {};
        data.forEach(row => {
            const nisn = row[nisnIndex].toString().trim();
            if (nisn) {
                dataObj[nisn] = {};
                headers.forEach((header, index) => {
                    // Mulai dari kolom ke-3 (setelah NISN dan Nama)
                    if (index > 1) dataObj[nisn][header] = row[index];
                });
            }
        });
        return dataObj;
    } catch (e) {
        Logger.log(`Error getting data from ${sheetName}: ${e}`);
        return {};
    }
}

/**
 * Memperbarui semua data di sheet rekapitulasi.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status pembaruan.
 */
function updateRekapitulasi(spreadsheetId) {
  try {
    const students = getStudents(spreadsheetId); //
    if (!students || students.length === 0) {
      return {status: 'error', message: 'Tidak ada data siswa untuk direkap.'};
    }
    const mapel = getMapel(spreadsheetId); //
    if (!mapel || mapel.length === 0) {
      return {status: 'error', message: 'Tidak ada data mata pelajaran untuk direkap.'};
    }
    const bobot = getBobot(spreadsheetId) || { bobotUjian: 0, bobotRapor: 0 }; //
    const jenjang = (getSchoolData(spreadsheetId) || {}).jenjang; //

    if (!jenjang) {
      return {status: 'error', message: 'Jenjang sekolah belum diatur di menu Data Sekolah.'};
    }

    const semesterKeys = {
      MI: ['k4_ganjil', 'k4_genap', 'k5_ganjil', 'k5_genap', 'k6_ganjil'],
      MTS: ['k7_ganjil', 'k7_genap', 'k8_ganjil', 'k8_genap', 'k9_ganjil'],
      MA: ['k10_ganjil', 'k10_genap', 'k11_ganjil', 'k11_genap', 'k12_ganjil']
    };
    const semestersForJenjang = semesterKeys[jenjang] || [];

    const sheetsToRead = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK]; //
    semestersForJenjang.forEach(smKey => {
        sheetsToRead.push(`Rapor_Pengetahuan_${smKey}`);
        sheetsToRead.push(`Rapor_Keterampilan_${smKey}`);
    });
    
    const allData = {};
    sheetsToRead.forEach(sheetName => {
        allData[sheetName] = getSheetDataAsObject(spreadsheetId, sheetName); //
    });

    const nilaiUjianMadrasah = allData[SHEET_NILAI_UJIAN_MADRASAH] || {}; //
    const nilaiUjianPraktek = allData[SHEET_NILAI_UJIAN_PRAKTEK] || {}; //
    
    const rekapUjian = {};
    const rekapRapor = {};
    const rekapIjazah = {};

    students.forEach(student => {
        const nisn = student.nisn.toString().trim();
        rekapUjian[nisn] = {};
        rekapRapor[nisn] = {};
        rekapIjazah[nisn] = {};

        mapel.forEach(m => {
            const kode = m.kode;
            const nilaiUM = parseFloat( (nilaiUjianMadrasah[nisn] || {})[kode] );
            const nilaiUP = parseFloat( (nilaiUjianPraktek[nisn] || {})[kode] );

            let rataUjian = null; // Default ke null
            const hasUM = !isNaN(nilaiUM);
            const hasUP = !isNaN(nilaiUP);

            if (hasUM && hasUP) rataUjian = (nilaiUM + nilaiUP) / 2;
            else if (hasUM) rataUjian = nilaiUM;
            else if (hasUP) rataUjian = nilaiUP;
            
            if(rataUjian !== null) rekapUjian[nisn][kode] = rataUjian;

            let totalNilaiRapor = 0;
            let semesterCount = 0;
            
            semestersForJenjang.forEach(smKey => {
                const sheetNameP = `Rapor_Pengetahuan_${smKey}`;
                const sheetNameK = `Rapor_Keterampilan_${smKey}`;
                
                const nilaiP = parseFloat( ((allData[sheetNameP] || {})[nisn] || {})[kode] );
                const nilaiK = parseFloat( ((allData[sheetNameK] || {})[nisn] || {})[kode] );

                if (!isNaN(nilaiP) && !isNaN(nilaiK)) {
                    totalNilaiRapor += (nilaiP + nilaiK) / 2;
                    semesterCount++;
                } else if (!isNaN(nilaiP)) {
                    totalNilaiRapor += nilaiP;
                    semesterCount++;
                } else if (!isNaN(nilaiK)) {
                    totalNilaiRapor += nilaiK;
                    semesterCount++;
                }
            });

            const rataRapor = semesterCount > 0 ? totalNilaiRapor / semesterCount : 0;
            if (semesterCount > 0) rekapRapor[nisn][kode] = rataRapor;

            const bobotUjianVal = parseFloat(bobot.bobotUjian) || 0;
            const bobotRaporVal = parseFloat(bobot.bobotRapor) || 0;

            const finalRataUjian = rataUjian !== null ? rataUjian : 0;
            const finalRataRapor = semesterCount > 0 ? rataRapor : 0;

            if (rataUjian !== null || semesterCount > 0) {
              const nilaiAkhir = (finalRataUjian * (bobotUjianVal / 100)) + (finalRataRapor * (bobotRaporVal / 100));
              rekapIjazah[nisn][kode] = nilaiAkhir;
            }
        });
    });

    saveRekapSheet(spreadsheetId, SHEET_REKAP_UJIAN, students, mapel, rekapUjian); //
    saveRekapSheet(spreadsheetId, SHEET_REKAP_RAPOR, students, mapel, rekapRapor); //
    saveRekapSheet(spreadsheetId, SHEET_REKAP_IJAZAH, students, mapel, rekapIjazah); //
    
    return {status: "success", message: "Data rekapitulasi berhasil diperbarui."};
  } catch(e) {
    Logger.log(e);
    return {status: "error", message: "Gagal memperbarui rekapitulasi: " + e.message};
  }
}

/**
 * [FINAL & DIPERBAIKI] Menyimpan data rekapitulasi ke sheet yang ditentukan.
 * Rata-rata kini dihitung dari nilai per mapel yang sudah dibulatkan agar konsisten.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} sheetName Nama sheet rekap.
 * @param {Array<object>} students Daftar siswa.
 * @param {Array<object>} mapel Daftar mata pelajaran.
 * @param {object} data Data rekapitulasi.
 */
function saveRekapSheet(spreadsheetId, sheetName, students, mapel, data) {
    const ss = getSpreadsheet(spreadsheetId);
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
        sheet = ss.insertSheet(sheetName);
    }
    sheet.clear();

    const headers = ["NISN", "Nama Lengkap", ...mapel.map(m => m.kode), "Jumlah", "Rata-rata"];
    sheet.appendRow(headers);
    sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold");
    sheet.getRange("A:A").setNumberFormat("@");

    const rows = students.map(student => {
        const nisn = student.nisn.toString().trim();
        // [PERBAIKAN] Nama kolom diubah menjadi "Nama Lengkap" agar konsisten
        const rowData = [nisn, student.nama]; 
        
        // [PERBAIKAN] Logika perhitungan diubah agar menjumlahkan nilai yang sudah dibulatkan
        let roundedTotal = 0;
        let count = 0;

        mapel.forEach(m => {
            const rawScore = (data[nisn] || {})[m.kode];
            const numericScore = parseFloat(rawScore);

            if (!isNaN(numericScore)) {
              // Jumlahkan nilai yang SUDAH DIBULATKAN
              roundedTotal += Math.round(numericScore);
              count++;
            }
            // Tetap simpan nilai asli di kolom per mapel
            rowData.push(rawScore !== undefined && rawScore !== null ? rawScore : '');
        });

        // Hitung rata-rata dari total nilai yang sudah dibulatkan
        const averageOfRounded = count > 0 ? roundedTotal / count : 0;
        
        rowData.push(roundedTotal); // Simpan Jumlah dari nilai bulat
        rowData.push(averageOfRounded); // Simpan Rata-rata dari nilai bulat

        return rowData;
    });

    if (rows.length > 0) {
        sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
    }
}

/**
 * Mengambil semua data rekapitulasi untuk ditampilkan.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi semua data rekapitulasi.
 */
function getRekapitulasiData(spreadsheetId) {
  const students = getStudents(spreadsheetId);
  const mapel = getMapel(spreadsheetId);
  const bobot = getBobot(spreadsheetId); // Tambahkan baris ini
  return {
    students,
    mapel,
    bobot, // Tambahkan properti ini
    rekapUjian: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_UJIAN),
    rekapRapor: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_RAPOR),
    rekapIjazah: getSheetDataAsObject(spreadsheetId, SHEET_REKAP_IJAZAH),
  };
}

/**
 * [BARU & OPTIMIZED] Mengambil semua data untuk halaman rekapitulasi dalam satu operasi.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi semua data rekapitulasi.
 */
function getRekapitulasiData_Optimized(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId); // Membuka spreadsheet HANYA SEKALI

    // Helper function untuk memproses data dari sheet menjadi objek
    const processSheetData = (sheet) => {
      if (!sheet || sheet.getLastRow() < 2) return {};
      sheet.getRange("A:A").setNumberFormat('@');
      const data = sheet.getDataRange().getValues();
      const headers = data.shift();
      const nisnIndex = headers.indexOf("NISN");
      if (nisnIndex === -1) return {};

      const dataObj = {};
      data.forEach(row => {
        const nisn = row[nisnIndex].toString().trim();
        if (nisn) {
          dataObj[nisn] = {};
          headers.forEach((header, index) => {
            if (header !== "NISN" && header !== "Nama Lengkap") {
              dataObj[nisn][header] = row[index];
            }
          });
        }
      });
      return dataObj;
    };

    // 1. Mengambil Data Siswa
    const studentSheet = ss.getSheetByName(SHEET_DATA_SISWA);
    let students = [];
    if (studentSheet && studentSheet.getLastRow() >= 2) {
      studentSheet.getRange("A:B").setNumberFormat('@');
      const studentValues = studentSheet.getRange(2, 1, studentSheet.getLastRow() - 1, 5).getValues();
      students = studentValues.map((row, index) => {
        let tanggalLahirStr = '';
        if (row[4] && row[4] instanceof Date) {
          tanggalLahirStr = Utilities.formatDate(row[4], Session.getScriptTimeZone(), "yyyy-MM-dd");
        }
        return { row: index + 2, nisn: row[0], nis: row[1], nama: row[2], tempatLahir: row[3], tanggalLahir: tanggalLahirStr };
      });
    }

    // 2. Mengambil Data Mapel
    const mapelSheet = ss.getSheetByName(SHEET_MAPEL);
    let mapel = [];
    if (mapelSheet && mapelSheet.getLastRow() >= 2) {
      const mapelValues = mapelSheet.getRange(2, 1, mapelSheet.getLastRow() - 1, 4).getValues();
      mapel = mapelValues.map((row, index) => ({ row: index + 2, kode: row[0], nama: row[1], kelompok: row[2], jenisUjian: row[3] || '' }));
    }

    // 3. Mengambil Data Bobot
    const bobotSheet = ss.getSheetByName(SHEET_BOBOT);
    let bobot = { bobotUjian: 40, bobotRapor: 60 };
    if (bobotSheet && bobotSheet.getLastRow() >= 2) {
      const bobotValues = bobotSheet.getRange("A2:B2").getValues()[0];
      if (bobotValues[0] !== '' && bobotValues[1] !== '' && !isNaN(bobotValues[0]) && !isNaN(bobotValues[1])) {
        bobot = { bobotUjian: bobotValues[0], bobotRapor: bobotValues[1] };
      }
    }

    // 4. Mengambil Semua Data Rekapitulasi
    const rekapUjian = processSheetData(ss.getSheetByName(SHEET_REKAP_UJIAN));
    const rekapRapor = processSheetData(ss.getSheetByName(SHEET_REKAP_RAPOR));
    const rekapIjazah = processSheetData(ss.getSheetByName(SHEET_REKAP_IJAZAH));

    return { status: "success", data: { students, mapel, bobot, rekapUjian, rekapRapor, rekapIjazah } };

  } catch (e) {
    Logger.log(`Error di getRekapitulasiData_Optimized: ${e}`);
    return { status: "error", message: "Gagal mengambil data rekapitulasi: " + e.message };
  }
}

/**
 * Memeriksa apakah sheet rekapitulasi sudah ada.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {boolean} True jika semua sheet ada.
 */
function checkRekapSheetsExist(spreadsheetId) {
  const ss = getSpreadsheet(spreadsheetId);
  const sheetUjian = ss.getSheetByName(SHEET_REKAP_UJIAN);
  const sheetRapor = ss.getSheetByName(SHEET_REKAP_RAPOR);
  const sheetIjazah = ss.getSheetByName(SHEET_REKAP_IJAZAH);
  return !!(sheetUjian && sheetRapor && sheetIjazah);
}

/**
 * Mengekspor data rekapitulasi ke format PDF atau Excel dengan layout kustom presisi.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} type Jenis rekap ('ujian', 'rapor', 'ijazah').
 * @param {string} format Format ekspor ('pdf' atau 'excel').
 * @param {object} exportOptions Objek berisi data dari form modal.
 * @returns {object} Objek berisi data file yang telah di-encode base64.
 */
function exportRekapData(spreadsheetId, type, format, exportOptions) {
  let tempSpreadsheetFileId = null;
  try {
    // 1. Tentukan Judul Laporan
    let reportTitle;
    switch (type) {
      case 'ijazah': reportTitle = "REKAPITULASI NILAI IJAZAH"; break;
      case 'rapor': reportTitle = "REKAPITULASI NILAI RAPOR"; break;
      case 'ujian': reportTitle = "REKAPITULASI NILAI UJIAN"; break; // [MODIFIKASI] Judul untuk jenis 'ujian'
      default: throw new Error("Jenis rekap tidak valid.");
    }

    // 2. Ambil data yang diperlukan
    const { students, mapel } = getRekapitulasiData(spreadsheetId);
    if (!students || students.length === 0) throw new Error("Tidak ada data siswa untuk diekspor.");
    
    const sheetName = `Rekap Nilai ${type.charAt(0).toUpperCase() + type.slice(1)}`;
    const dataToProcess = getSheetDataAsObject(spreadsheetId, sheetName);

    // 3. Bangun data tabel
    const tableBodyData = [];
    students.forEach((student, index) => {
        const nisn = student.nisn;
        const studentScores = dataToProcess[nisn] || {};
        
        const rowData = [index + 1, `'${nisn}`, student.nama.toUpperCase()];
        
        let total = 0;
        mapel.forEach(m => {
            const score = parseFloat(studentScores[m.kode] || 0);
            const roundedScore = Math.round(score);
            rowData.push(roundedScore);
            total += roundedScore; // Menjumlahkan nilai yang sudah dibulatkan
        });

        const average = mapel.length > 0 ? (total / mapel.length) : 0;
        
        rowData.push(total);
        rowData.push(average.toFixed(2).replace('.', ','));

        // [MODIFIKASI] Tambahkan kolom pembulatan HANYA untuk tipe 'ujian'
        if (type === 'ujian') {
            rowData.push(Math.round(average));
        }
        
        tableBodyData.push(rowData);
    });
    
    // 4. Buat spreadsheet sementara
    const tempSpreadsheetName = `Cetak_${reportTitle.replace(/ /g, "_")}_${new Date().getTime()}`;
    const tempSpreadsheet = SpreadsheetApp.create(tempSpreadsheetName);
    tempSpreadsheetFileId = tempSpreadsheet.getId();
    const tempSheet = tempSpreadsheet.getSheets()[0];
    tempSheet.setName("Rekapitulasi");

    // --- PEMFORMATAN KUSTOM ---
    const schoolData = getSchoolData(spreadsheetId);
    let currentRow = 1;
    const numMapel = mapel.length;

    // [MODIFIKASI] Sesuaikan jumlah total kolom jika tipenya 'ujian'
    let numColumns = numMapel + 5; // Kolom default: No, NISN, Nama, Jumlah, Rata-Rata
    if (type === 'ujian') {
      numColumns++; // Tambah 1 untuk kolom Pembulatan
    }

    // Header Laporan
    tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue(reportTitle).setFontSize(16);
    currentRow++;
    tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue((schoolData.namaSekolah || "NAMA SEKOLAH").toUpperCase()).setFontSize(16);
    currentRow++;
    tempSheet.getRange(currentRow, 1, 1, numColumns).merge().setValue(`Tahun Ajaran ${exportOptions.tahunAjaran || ""}`).setFontSize(14);
    currentRow += 2;

    // --- HEADER TABEL (STRUKTUR 2 BARIS) ---
    const tableStartRow = currentRow;
    tempSheet.getRange(tableStartRow, 4, 1, numMapel).merge().setValue("MATA PELAJARAN");
    const mapelHeaders = mapel.map(m => m.kode);
    tempSheet.getRange(tableStartRow + 1, 4, 1, numMapel).setValues([mapelHeaders]);
    
    // Header Tetap
    tempSheet.getRange(tableStartRow, 1).setValue("No.");
    tempSheet.getRange(tableStartRow, 2).setValue("NISN");
    tempSheet.getRange(tableStartRow, 3).setValue("Nama Siswa");
    const jumlahCol = 4 + numMapel;
    const rataRataCol = 5 + numMapel;
    tempSheet.getRange(tableStartRow, jumlahCol).setValue("Jumlah");
    tempSheet.getRange(tableStartRow, rataRataCol).setValue("Rata-Rata");

    // Merge Vertikal
    tempSheet.getRange(tableStartRow, 1, 2, 1).merge();
    tempSheet.getRange(tableStartRow, 2, 2, 1).merge();
    tempSheet.getRange(tableStartRow, 3, 2, 1).merge();
    tempSheet.getRange(tableStartRow, jumlahCol, 2, 1).merge();
    tempSheet.getRange(tableStartRow, rataRataCol, 2, 1).merge();
    
    // [MODIFIKASI] Tambahkan header "Pembulatan" jika tipenya 'ujian'
    if (type === 'ujian') {
      const pembulatanCol = 6 + numMapel;
      tempSheet.getRange(tableStartRow, pembulatanCol).setValue("Pembulatan");
      tempSheet.getRange(tableStartRow, pembulatanCol, 2, 1).merge();
    }
    
    // Tulis Body Tabel
    if (tableBodyData.length > 0) {
        tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, numColumns).setValues(tableBodyData);
    }

    // --- APLIKASI FORMAT ---
    // (Kode format lainnya tidak berubah)
    const fullRange = tempSheet.getRange(1, 1, tempSheet.getLastRow() + 5, numColumns);
    fullRange.setFontFamily("Arial").setVerticalAlignment("middle");
    tempSheet.getRange(1, 1, 3, 1).setFontWeight("bold").setHorizontalAlignment("center");
    const tableHeaderRange = tempSheet.getRange(tableStartRow, 1, 2, numColumns);
    tableHeaderRange.setFontWeight("bold").setFontSize(12).setHorizontalAlignment("center").setBackground("#ffff00");
    if (tableBodyData.length > 0) {
        tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, numColumns).setFontSize(12);
        tempSheet.getRange(tableStartRow + 2, 1, tableBodyData.length, 1).setHorizontalAlignment("center");
        tempSheet.getRange(tableStartRow + 2, 2, tableBodyData.length, 1).setNumberFormat("@").setHorizontalAlignment("center");
        tempSheet.getRange(tableStartRow + 2, 3, tableBodyData.length, 1).setHorizontalAlignment("left");
        tempSheet.getRange(tableStartRow + 2, 4, tableBodyData.length, numColumns - 3).setHorizontalAlignment("center");
    }
    tempSheet.getRange(tableStartRow, 1, tableBodyData.length + 2, numColumns).setBorder(true, true, true, true, true, true);
    
    // --- Atur Lebar Kolom ---
    tempSheet.setColumnWidth(1, 40);
    tempSheet.setColumnWidth(2, 100);
    tempSheet.setColumnWidth(3, 220);
    for (let i = 4; i <= 3 + numMapel; i++) {
        tempSheet.setColumnWidth(i, 60); // Lebar seragam untuk kolom mapel
    }
    tempSheet.setColumnWidth(jumlahCol, 80);
    tempSheet.setColumnWidth(rataRataCol, 80);
    // [MODIFIKASI] Atur lebar kolom "Pembulatan"
    if (type === 'ujian') {
      tempSheet.setColumnWidth(6 + numMapel, 90);
    }
    // --- AKHIR LOGIKA LEBAR KOLOM ---

    // Blok Tanda Tangan
    const signatureBlockStartRow = tableStartRow + tableBodyData.length + 3;
    const signatureColumnStart = numColumns - 3;
    const formatDateToIndonesian = (dateString) => {
      if (!dateString) return "";
      const date = new Date(dateString);
      return new Intl.DateTimeFormat('id-ID', { day: '2-digit', month: 'long', year: 'numeric' }).format(date);
    };
    
    let ttdRow = signatureBlockStartRow;
    const ttdDate = formatDateToIndonesian(exportOptions.tanggalTTD);
    
    tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(`${exportOptions.tempatTTD || "Tempat"}, ${ttdDate}`);
    ttdRow++;
    tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(exportOptions.tipeKamad || "Kepala Madrasah");
    ttdRow += 3;
    tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge().setValue(schoolData.namaKepsek || "Nama Kepala").setFontWeight("bold").setFontLine('underline');
    ttdRow++;
    const nipRange = tempSheet.getRange(ttdRow, signatureColumnStart, 1, 4).merge();
    nipRange.setNumberFormat("@");
    nipRange.setValue(schoolData.nipKepsek ? `NIP. ${schoolData.nipKepsek}` : "NIP. -");
    
    // Samakan ukuran font seluruh blok ttd
    tempSheet.getRange(signatureBlockStartRow, signatureColumnStart, 5, 4).setFontSize(12).setHorizontalAlignment("left");
    
    SpreadsheetApp.flush(); 

    // 5. Ekspor file
    const exportUrl = `https://docs.google.com/spreadsheets/d/${tempSpreadsheetFileId}/export`;
    const token = ScriptApp.getOAuthToken();
    const fetchOptions = { headers: { Authorization: `Bearer ${token}` }, muteHttpExceptions: true };
    let blob, fileName, mimeType;

    if (format === 'excel') {
      fileName = `${reportTitle.replace(/ /g, "_")}.xlsx`;
      mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
      const url = `${exportUrl}?format=xlsx`;
      blob = UrlFetchApp.fetch(url, fetchOptions).getBlob().setName(fileName);
    } else { // PDF
      fileName = `${reportTitle.replace(/ /g, "_")}.pdf`;
      mimeType = 'application/pdf';
      const pdfOptions = `?exportFormat=pdf&format=pdf&size=A4&portrait=false&fitw=true&sheetnames=false&printtitle=false&gridlines=false&gid=${tempSheet.getSheetId()}`;
      const url = `${exportUrl}${pdfOptions}`;
      blob = UrlFetchApp.fetch(url, fetchOptions).getBlob().setName(fileName);
    }
    
    if (!blob || blob.getBytes().length === 0) throw new Error("Gagal membuat file ekspor. Blob kosong.");
    
    // 6. Kembalikan data file
    return {
      fileName: fileName,
      mimeType: mimeType,
      base64Data: Utilities.base64Encode(blob.getBytes())
    };

  } catch (e) {
    Logger.log(`Export Error: ${e.toString()}\nStack: ${e.stack}`);
    return { error: e.toString() };
  } finally {
    if (tempSpreadsheetFileId) {
      DriveApp.getFileById(tempSpreadsheetFileId).setTrashed(true);
    }
  }
}

/**
 * [BARU] Menghitung rata-rata skor untuk setiap mata pelajaran dari sheet rekap.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi data rata-rata untuk setiap jenis rekap.
 */
function getSubjectAverageScores(spreadsheetId) {
  try {
    const mapel = getMapel(spreadsheetId);
    if (!mapel || mapel.length === 0) return {};

    const ss = getSpreadsheet(spreadsheetId);
    const labels = mapel.map(m => m.kode);

    // Helper function untuk memproses satu sheet
    const calculateAveragesForSheet = (sheetName) => {
      const sheet = ss.getSheetByName(sheetName);
      const averages = {};
      labels.forEach(l => averages[l] = 0); // Inisialisasi semua rata-rata ke 0

      if (!sheet || sheet.getLastRow() < 2) {
        return labels.map(() => 0); // Kembalikan array nol jika sheet kosong
      }

      const data = sheet.getDataRange().getValues();
      const headers = data.shift();
      const studentCount = data.length;
      if (studentCount === 0) return labels.map(() => 0);

      // Hitung total untuk setiap kolom
      const totals = new Array(headers.length).fill(0);
      data.forEach(row => {
        for (let i = 2; i < headers.length; i++) { // Mulai dari kolom ke-3 (setelah NISN dan Nama)
          const value = parseFloat(row[i]);
          if (!isNaN(value)) {
            totals[i] += value;
          }
        }
      });

      // Hitung rata-rata
      headers.forEach((header, i) => {
        if (averages.hasOwnProperty(header)) {
          averages[header] = totals[i] / studentCount;
        }
      });
      
      return labels.map(label => Math.round(averages[label] || 0));
    };

    return {
      ujian: { labels, data: calculateAveragesForSheet(SHEET_REKAP_UJIAN) },
      rapor: { labels, data: calculateAveragesForSheet(SHEET_REKAP_RAPOR) },
      ijazah: { labels, data: calculateAveragesForSheet(SHEET_REKAP_IJAZAH) }
    };

  } catch (e) {
    Logger.log("Error in getSubjectAverageScores: " + e.message);
    return {};
  }
}


/**
 * [DIUBAH & DIPERBAIKI] Mengambil data nilai rata-rata ujian untuk setiap siswa.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {Array<Object>} Array objek berisi nama dan skor rata-rata ujian setiap siswa.
 */
function getExamScoreShare(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const rekapUjianSheet = ss.getSheetByName(SHEET_REKAP_UJIAN);

    if (!rekapUjianSheet || rekapUjianSheet.getLastRow() < 2) {
      return [{ nama: 'Belum Ada Data', skor: 1 }];
    }

    const dataRange = rekapUjianSheet.getRange(2, 1, rekapUjianSheet.getLastRow() - 1, rekapUjianSheet.getLastColumn()).getValues();
    const headers = rekapUjianSheet.getRange(1, 1, 1, rekapUjianSheet.getLastColumn()).getValues()[0];

    // [PERBAIKAN] Mencari header "Nama Lengkap" dan "Rata-rata"
    const namaIndex = headers.indexOf("Nama Lengkap");
    const skorIndex = headers.indexOf("Rata-rata");

    if (namaIndex === -1 || skorIndex === -1) {
       return [{ nama: 'Kolom Tidak Ditemukan', skor: 1 }];
    }

    const studentScores = dataRange.map(row => {
      return {
        nama: row[namaIndex],
        skor: parseFloat(row[skorIndex]) || 0
      };
    });

    return studentScores;

  } catch (e) {
    Logger.log("Error in getExamScoreShare: " + e.message);
    return [{ nama: 'Gagal Memuat', skor: 1 }];
  }
}

/**
 * [DIPERBAIKI] Mendapatkan peringkat siswa berdasarkan nilai rata-rata ijazah.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {array} Array objek berisi nama siswa dan rata-rata nilai ijazah, diurutkan berdasarkan peringkat.
 */
function getIjazahRanking(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const rekapIjazahSheet = ss.getSheetByName(SHEET_REKAP_IJAZAH);

    if (!rekapIjazahSheet || rekapIjazahSheet.getLastRow() < 2) {
      return [];
    }

    const dataRange = rekapIjazahSheet.getDataRange().getValues();
    const headers = dataRange.shift();
    
    // [PERBAIKAN] Mencari header "Nama Lengkap" dan "Rata-rata"
    const namaKolomIndex = headers.indexOf('Nama Lengkap');
    const nilaiKolomIndex = headers.indexOf('Rata-rata');

    if (namaKolomIndex === -1 || nilaiKolomIndex === -1) {
      return [];
    }

    const studentRanks = dataRange.map(row => ({
      nama: row[namaKolomIndex],
      nilai: parseFloat(row[nilaiKolomIndex]) || 0
    }));

    studentRanks.sort((a, b) => b.nilai - a.nilai);
    return studentRanks;

  } catch (e) {
    Logger.log("Error in getIjazahRanking: " + e.message);
    return [];
  }
}

/**
 * Mengambil data agregat untuk halaman dashboard.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {object} Objek berisi data untuk dashboard.
 */
function getDashboardData(spreadsheetId) {
  try {
    const students = getStudents(spreadsheetId);
    const mapel = getMapel(spreadsheetId);
    const schoolData = getSchoolData(spreadsheetId);
    const subjectAverages = getSubjectAverageScores(spreadsheetId);
    const examScoreShare = getExamScoreShare(spreadsheetId);
    const ijazahRanking = getIjazahRanking(spreadsheetId); // [BARU]

    return {
      status: "success",
      studentCount: students.length,
      mapelCount: mapel.length,
      schoolData: schoolData,
      mapelList: mapel,
      subjectAverages: subjectAverages,
      examScoreShare: examScoreShare,
      ijazahRanking: ijazahRanking // [BARU]
    };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengambil data dashboard: " + e.message };
  }
}

/**
 * [PERBAIKAN FINAL] Memperbarui data beberapa siswa sekaligus setelah konfirmasi konflik impor.
 * Menggunakan struktur data 11 kolom yang benar.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {Array<object>} studentsToUpdate Array objek siswa yang akan diupdate.
 * @returns {{status: string, message: string}} Status pembaruan.
 */
function batchUpdateStudents(spreadsheetId, studentsToUpdate) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheet = ss.getSheetByName(SHEET_DATA_SISWA);
    let updatedCount = 0;

    studentsToUpdate.forEach(studentData => {
      // [PERBAIKAN] Susun ulang array agar cocok dengan struktur 11 kolom yang baru
      const rowToUpdate = [
        studentData.nisn,
        studentData.nis,
        studentData.nama,
        studentData.jenisKelamin, // <-- Ditambahkan
        toProperCase(studentData.tempatLahir),
        studentData.tanggalLahir ? new Date(studentData.tanggalLahir.replace(/-/g, '/')) : '',
        studentData.alamat,      // <-- Ditambahkan
        studentData.telepon,     // <-- Ditambahkan
        studentData.emailSiswa,  // <-- Ditambahkan
        studentData.tahunMasuk,  // <-- Ditambahkan
        studentData.tahunLulus   // <-- Ditambahkan
      ];

      const targetRange = sheet.getRange(studentData.studentRow, 1, 1, rowToUpdate.length);
      
      // Sesuaikan format nomor untuk kolom yang benar
      sheet.getRange(studentData.studentRow, 1, 1, 2).setNumberFormat('@'); // NISN, NIS
      sheet.getRange(studentData.studentRow, 8, 1, 1).setNumberFormat('@'); // Telepon di kolom H

      targetRange.setValues([rowToUpdate]);
      updatedCount++;
    });

    return { status: "success", message: `${updatedCount} data siswa berhasil diperbarui.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data siswa secara massal: " + e.message };
  }
}

// ===== [BARU] FUNGSI UNTUK MENGHAPUS SEMUA NILAI UJIAN =====
/**
 * Menghapus semua konten dari sheet Nilai Ujian Madrasah dan Praktek.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllUjianScores(spreadsheetId) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheetNames = [SHEET_NILAI_UJIAN_MADRASAH, SHEET_NILAI_UJIAN_PRAKTEK];
    let clearedCount = 0;

    sheetNames.forEach(name => {
      const sheet = ss.getSheetByName(name);
      if (sheet && sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
        clearedCount++;
      }
    });

    if (clearedCount === 0) {
      return { status: "info", message: "Tidak ada data nilai ujian untuk dihapus." };
    }
    
    return { status: "success", message: "Semua data nilai Ujian Madrasah & Praktek telah berhasil dihapus." };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data nilai ujian: " + e.message };
  }
}


// ===== [BARU] FUNGSI UNTUK MENGHAPUS SEMUA NILAI RAPOR PER SEMESTER =====
/**
 * Menghapus semua konten nilai rapor (Pengetahuan & Keterampilan) untuk semester tertentu.
 * @param {string} spreadsheetId ID spreadsheet target.
 * @param {string} semesterKey Kunci semester, cth: 'k10_ganjil'.
 * @returns {{status: string, message: string}} Status penghapusan.
 */
function deleteAllRaporScoresBySemester(spreadsheetId, semesterKey) {
  try {
    const ss = getSpreadsheet(spreadsheetId);
    const sheetNames = [
      `Rapor_Pengetahuan_${semesterKey}`,
      `Rapor_Keterampilan_${semesterKey}`
    ];
    let clearedCount = 0;

    sheetNames.forEach(name => {
      const sheet = ss.getSheetByName(name);
      if (sheet && sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
        clearedCount++;
      }
    });
    
    if (clearedCount === 0) {
      return { status: "info", message: "Tidak ada data nilai rapor untuk semester ini yang bisa dihapus." };
    }

    return { status: "success", message: `Semua data nilai rapor untuk semester ini telah berhasil dihapus.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal menghapus data rapor semester: " + e.message };
  }
}

/**
 * [BARU] Membandingkan dua objek data siswa untuk melihat apakah identik di semua kolom.
 * @param {object} studentA Objek data siswa pertama.
 * @param {object} studentB Objek data siswa kedua.
 * @returns {boolean} True jika identik, false jika ada perbedaan.
 */
function areStudentsIdentical(studentA, studentB) {
  // Daftar semua kunci yang ingin dibandingkan
  const keysToCompare = [
    'nisn', 'nis', 'nama', 'jenisKelamin', 'tempatLahir', 'tanggalLahir',
    'alamat', 'telepon', 'emailSiswa', 'tahunMasuk', 'tahunLulus'
  ];

  for (const key of keysToCompare) {
    // Menggunakan (objek[key] || '') untuk menangani nilai null/undefined sebagai string kosong
    // Ini memastikan perbandingan yang konsisten.
    const valueA = (studentA[key] || '').toString().trim();
    const valueB = (studentB[key] || '').toString().trim();

    // Khusus untuk tempat lahir, kita bandingkan dalam format Proper Case
    if (key === 'tempatLahir') {
      if (toProperCase(valueA) !== toProperCase(valueB)) {
        return false; // Jika berbeda, langsung kembalikan false
      }
    } else {
      if (valueA !== valueB) {
        return false; // Jika ada satu saja perbedaan, mereka tidak identik
      }
    }
  }

  // Jika loop selesai tanpa menemukan perbedaan, berarti mereka identik
  return true;
}

// =================================================================
// FUNGSI KHUSUS SUPERADMIN
// =================================================================

/**
 * [SUPERADMIN & DIPERBAIKI] Helper function untuk memverifikasi apakah pengguna adalah Superadmin.
 * Kini lebih aman dan bisa menangani input email yang kosong (null).
 * @param {string} email Email pengguna yang melakukan aksi.
 * @returns {boolean} True jika Superadmin, false jika bukan.
 */
function isSuperadmin(email) {
  // Cek apakah email yang dikirim valid sebelum diproses.
  if (!email) { 
    return false;
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
  const data = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 8).getValues();
  
  // Pastikan data baris dan email di sheet tidak kosong sebelum .toLowerCase()
  const userRow = data.find(row => row && row[1] && row[1].toLowerCase() === email.toLowerCase());
  
  return userRow && userRow[6] === 'Superadmin';
}

/**
 * [SUPERADMIN] Mengambil semua data pengguna untuk ditampilkan di panel superadmin.
 * @param {string} adminEmail Email superadmin yang meminta data.
 * @returns {Array<object>} Array objek data pengguna.
 */
function getAllUsers_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak. Hanya Superadmin yang dapat melakukan aksi ini.");
  }
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
  if (!sheet || sheet.getLastRow() < 2) return [];
  
  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 9).getValues(); // Baca sampai kolom I
  
  return data.map((row, index) => {
    const spreadsheetId = row[5];
    let currentStudentCount = '-';
    if (row[6] !== 'Superadmin' && spreadsheetId) {
      try {
        const studentSheet = SpreadsheetApp.openById(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
        currentStudentCount = studentSheet ? studentSheet.getLastRow() - 1 : 0;
      } catch (e) {
        currentStudentCount = 'Error';
      }
    }

    return {
      row: index + 2,
      email: row[1],
      namaSekolah: row[3],
      role: row[6] || 'Pengguna',
      status: row[7] || 'Aktif',
      studentLimit: row[8] || 'N/A', // Kolom I
      currentStudentCount: currentStudentCount
    };
  });
}

/**
 * [SUPERADMIN] Memperbarui data pengguna (Nama Sekolah & Jenjang) oleh Superadmin.
 * @param {string} adminEmail Email superadmin yang melakukan aksi.
 * @param {object} userData Objek berisi data yang akan diupdate {row, namaSekolah, jenjang}.
 * @returns {{status: string, message: string}} Hasil proses.
 */
function updateUserBySuperadmin(adminEmail, userData) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    
    // Update Nama Sekolah (Kolom D) dan Jenjang (Kolom E) di sheet Data Pengguna
    userSheet.getRange(userData.row, 4).setValue(userData.namaSekolah);
    userSheet.getRange(userData.row, 5).setValue(userData.jenjang);

    // Update juga di dalam spreadsheet sekolah yang bersangkutan
    const schoolSsId = userSheet.getRange(userData.row, 6).getValue();
    const schoolSs = SpreadsheetApp.openById(schoolSsId);
    const dataSekolahSheet = schoolSs.getSheetByName(SHEET_DATA_SEKOLAH);
    if (dataSekolahSheet) {
      dataSekolahSheet.getRange(2, 1).setValue(userData.jenjang); // Jenjang di A2
      dataSekolahSheet.getRange(2, 2).setValue(userData.namaSekolah); // Nama Sekolah di B2
    }

    return { status: "success", message: `Data untuk akun ${userData.email} berhasil diperbarui.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal memperbarui data: " + e.message };
  }
}

/**
 * [SUPERADMIN] Mengubah status akun pengguna (Aktif/Nonaktif).
 * @param {string} adminEmail Email superadmin yang melakukan aksi.
 * @param {number} rowNomor Nomor baris pengguna yang akan diubah.
 * @param {string} newStatus Status baru ('Aktif' atau 'Nonaktif').
 * @returns {{status: string, message: string}} Hasil proses.
 */
function setUserStatus_Superadmin(adminEmail, rowNumber, newStatus) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    // Kolom Status adalah kolom ke-8 (H)
    userSheet.getRange(rowNumber, 8).setValue(newStatus); 
    return { status: "success", message: `Status akun berhasil diubah menjadi ${newStatus}.` };
  } catch (e) {
    Logger.log(e);
    return { status: "error", message: "Gagal mengubah status: " + e.message };
  }
}

/**
 * [SUPERADMIN & DIPERBARUI] Mengumpulkan data statistik agregat untuk dashboard superadmin.
 * @param {string} adminEmail - Email superadmin untuk verifikasi.
 * @returns {object} Objek berisi data statistik.
 */
function getSuperadminDashboardData(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
  
  // -- Statistik Akun & Siswa (Kode Lama, tidak diubah) --
  let totalAccounts = 0, activeAccounts = 0, totalStudents = 0, inactiveAccounts = 0;
  if (userSheet && userSheet.getLastRow() >= 2) {
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 8).getValues();
    totalAccounts = usersData.length;
    usersData.forEach(userRow => {
      const status = userRow[7] || 'Aktif';
      if (status === 'Aktif') activeAccounts++;
      const role = userRow[6];
      const spreadsheetId = userRow[5];
      if (role !== 'Superadmin' && spreadsheetId) {
        try {
          const studentSs = SpreadsheetApp.openById(spreadsheetId);
          const studentSheet = studentSs.getSheetByName(SHEET_DATA_SISWA);
          if (studentSheet && studentSheet.getLastRow() > 1) {
            totalStudents += studentSheet.getLastRow() - 1;
          }
        } catch (e) {
          Logger.log(`[Superadmin] Gagal akses spreadsheet ID ${spreadsheetId} untuk email ${userRow[1]}. Error: ${e.message}`);
        }
      }
    });
    inactiveAccounts = totalAccounts - activeAccounts;
  }

  // -- [KODE BARU] Statistik Pengajuan --
  let totalRequests = 0, pendingRequests = 0, approvedRequests = 0, rejectedRequests = 0;
  try {
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (pengajuanSheet && pengajuanSheet.getLastRow() >= 2) {
      const statusColumn = pengajuanSheet.getRange(2, 8, pengajuanSheet.getLastRow() - 1, 1).getValues();
      totalRequests = statusColumn.length;
      pendingRequests = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
      approvedRequests = statusColumn.filter(row => row[0] === 'Disetujui').length;
      rejectedRequests = statusColumn.filter(row => row[0] === 'Ditolak').length;
    }
  } catch(e) {
     Logger.log("getSuperadminDashboardData Error saat mengambil data pengajuan: " + e.message);
  }

  // -- Return semua data --
  return {
    totalAccounts: totalAccounts,
    activeAccounts: activeAccounts,
    inactiveAccounts: inactiveAccounts,
    totalStudents: totalStudents,
    totalRequests: totalRequests,
    pendingRequests: pendingRequests,
    approvedRequests: approvedRequests,
    rejectedRequests: rejectedRequests
  };
}

/**
 * Helper function untuk memeriksa apakah pengguna telah mencapai batas siswa.
 * @param {string} spreadsheetId ID spreadsheet pengguna.
 * @param {string} userEmail Email pengguna yang akan diperiksa.
 * @returns {{limitReached: boolean, message: string}} Objek berisi status batas.
 */
function checkStudentLimit(spreadsheetId, userEmail) {
  try {
    // Dapatkan batas siswa dari sheet Data Pengguna
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    const userRow = usersData.find(row => row[1].toLowerCase() === userEmail.toLowerCase());
    
    if (!userRow) {
      return { limitReached: true, message: "Data pengguna tidak ditemukan." };
    }
    const studentLimit = parseInt(userRow[8]); // Kolom I adalah student limit

    if (isNaN(studentLimit)) {
      // Jika batas tidak diatur, anggap tidak ada batas (untuk keamanan)
      return { limitReached: false, message: "" };
    }

    // Dapatkan jumlah siswa saat ini
    const studentSs = SpreadsheetApp.openById(spreadsheetId);
    const studentSheet = studentSs.getSheetByName(SHEET_DATA_SISWA);
    const currentStudentCount = studentSheet ? studentSheet.getLastRow() - 1 : 0;

    if (currentStudentCount >= studentLimit) {
      return { limitReached: true, message: `Batas jumlah siswa tercapai (${currentStudentCount}/${studentLimit}). Anda tidak dapat menambahkan siswa baru. Hubungi admin untuk menaikkan batas.` };
    }

    return { limitReached: false, message: "" };

  } catch (e) {
    Logger.log(`Error di checkStudentLimit: ${e.message}`);
    return { limitReached: true, message: "Terjadi kesalahan saat memeriksa batas siswa." };
  }
}

/**
 * [SUPERADMIN] Mengatur batas jumlah siswa untuk akun tertentu.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {number} rowNumber Nomor baris pengguna yang akan diubah.
 * @param {number} newLimit Batas baru yang akan ditetapkan.
 * @returns {object} Hasil proses.
 */
function setStudentLimit_Superadmin(adminEmail, rowNumber, newLimit) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const limit = parseInt(newLimit);
    if (isNaN(limit) || limit < 0) {
      return { status: "error", message: "Batas siswa harus berupa angka positif." };
    }
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    userSheet.getRange(rowNumber, 9).setValue(limit); // Kolom I adalah Student Limit
    return { status: "success", message: "Batas siswa berhasil diperbarui." };
  } catch (e) {
    return { status: "error", message: "Gagal memperbarui batas: " + e.message };
  }
}

/**
 * [SUPERADMIN] Mengatur dan mengambil batas default siswa untuk pendaftaran baru.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {number} [newLimit] Batas default baru (opsional). Jika tidak diberikan, fungsi hanya akan mengambil nilai saat ini.
 * @returns {object} Hasil proses atau nilai saat ini.
 */
function manageDefaultStudentLimit_Superadmin(adminEmail, newLimit) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  try {
    const configSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Konfigurasi Sistem');
    if (!configSheet) {
      return { status: "error", message: "Sheet 'Konfigurasi Sistem' tidak ditemukan." };
    }
    const limitCell = configSheet.getRange("B2");

    if (newLimit !== undefined && newLimit !== null) {
      // Mode: Mengatur nilai baru
      const limit = parseInt(newLimit);
      if (isNaN(limit) || limit < 0) {
        return { status: "error", message: "Batas default harus berupa angka positif." };
      }
      limitCell.setValue(limit);
      return { status: "success", message: `Batas default siswa berhasil diubah menjadi ${limit}.`, currentLimit: limit };
    } else {
      // Mode: Mengambil nilai saat ini
      const currentLimit = limitCell.getValue();
      return { status: "success", currentLimit: currentLimit };
    }
  } catch (e) {
    return { status: "error", message: "Gagal mengelola batas default: " + e.message };
  }
}

/**
 * [BARU] Mengambil informasi kuota siswa untuk pengguna yang sedang login.
 * @param {string} userEmail Email pengguna.
 * @returns {object} Objek berisi info kuota: {status, totalLimit, usedCount, remaining}.
 */
function getStudentQuotaInfo(userEmail) {
  if (!userEmail) {
    return { status: "error", message: "Email pengguna tidak diberikan." };
  }

  try {
    const userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_PENGGUNA);
    const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    const userRow = usersData.find(row => row[1] && row[1].toLowerCase() === userEmail.toLowerCase());

    if (!userRow) {
      return { status: "error", message: "Data pengguna tidak ditemukan." };
    }

    const role = userRow[6];
    if (role === 'Superadmin') {
        // Superadmin tidak memiliki kuota siswa
        return { status: "success", totalLimit: 'Tak Terbatas', usedCount: '-', remaining: '-' };
    }

    const spreadsheetId = userRow[5];
    const studentLimit = parseInt(userRow[8]);

    if (!spreadsheetId) {
        return { status: "error", message: "Spreadsheet ID tidak ditemukan untuk pengguna ini." };
    }

    // Jika batas tidak diatur atau bukan angka, anggap tak terbatas
    if (isNaN(studentLimit)) {
      const studentSheet = SpreadsheetApp.openById(spreadsheetId).getSheetByName(SHEET_DATA_SISWA);
      const usedCount = studentSheet ? Math.max(0, studentSheet.getLastRow() - 1) : 0;
      return { status: "success", totalLimit: 'Tak Terbatas', usedCount: usedCount, remaining: '-' };
    }

    const studentSs = SpreadsheetApp.openById(spreadsheetId);
    const studentSheet = studentSs.getSheetByName(SHEET_DATA_SISWA);
    const usedCount = studentSheet ? Math.max(0, studentSheet.getLastRow() - 1) : 0;
    
    const remaining = studentLimit - usedCount;

    return {
      status: "success",
      totalLimit: studentLimit,
      usedCount: usedCount,
      remaining: remaining
    };

  } catch (e) {
    Logger.log(`Error di getStudentQuotaInfo untuk ${userEmail}: ${e.message}`);
    return { status: "error", message: "Gagal mengambil informasi kuota." };
  }
}

// =================================================================
// [BARU] FUNGSI PENGAJUAN PERUBAHAN DATA
// =================================================================

// Nama Sheet baru untuk menyimpan data pengajuan.
const SHEET_PENGAJUAN = "Data Pengajuan";

/**
 * [BARU & DIPERBAIKI] Mengajukan permintaan perubahan data sekolah oleh pengguna.
 * @param {string} userEmail Email pengguna yang mengajukan.
 * @param {object} newData Objek berisi data baru { jenjang, namaSekolah }.
 * @returns {{status: string, message: string}} Hasil dari pengajuan.
 */
function submitChangeRequest(userEmail, newData) {
  try {
    const { newJenjang, newNamaSekolah } = newData;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);

    // Jika sheet belum ada, buat baru dengan header.
    if (!pengajuanSheet) {
      pengajuanSheet = ss.insertSheet(SHEET_PENGAJUAN);
      pengajuanSheet.appendRow([
        "Request ID", "User Email", "Jenjang Lama", "Nama Sekolah Lama", 
        "Jenjang Baru", "Nama Sekolah Baru", "Tanggal Ajuan", "Status", 
        "Catatan Admin", "Tanggal Diproses"
      ]);
    }

    // Cek apakah ada pengajuan yang masih menunggu dari pengguna yang sama.
    if (pengajuanSheet.getLastRow() > 1) {
        const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
        const pendingRequest = data.find(row => row[1] === userEmail && row[7] === 'Menunggu Persetujuan');
        if (pendingRequest) {
            return { status: "error", message: "Anda sudah memiliki pengajuan yang sedang diproses. Harap tunggu hingga admin meninjaunya." };
        }
    }
    
    // Dapatkan data sekolah saat ini untuk disimpan sebagai 'data lama'.
    const userRow = findUserRowByEmail(userEmail);
    if (!userRow) {
        return { status: "error", message: "Data pengguna tidak ditemukan." };
    }
    const oldJenjang = userRow[4]; // Kolom E
    const oldNamaSekolah = userRow[3]; // Kolom D

    if (!newJenjang && !newNamaSekolah) {
       return { status: "error", message: "Tidak ada data baru yang diajukan untuk diubah." };
    }

    const requestId = Utilities.getUuid();
    const requestDate = new Date();
    
    pengajuanSheet.appendRow([
      requestId,
      userEmail,
      oldJenjang,
      oldNamaSekolah,
      newJenjang || oldJenjang, // Jika tidak diubah, pakai data lama
      newNamaSekolah || oldNamaSekolah, // Jika tidak diubah, pakai data lama
      requestDate,
      'Menunggu Persetujuan', // Status awal
      '', // Catatan Admin kosong
      ''  // Tanggal diproses kosong
    ]);

    // !! PENTING: TAMBAHKAN BARIS INI !!
    // Memaksa Google untuk menyelesaikan semua operasi penulisan sebelum melanjutkan.
    SpreadsheetApp.flush(); 

    return { status: "success", message: "Pengajuan perubahan data berhasil dikirim dan sedang menunggu persetujuan admin." };

  } catch (e) {
    Logger.log(`submitChangeRequest Error: ${e.toString()}`);
    return { status: "error", message: "Gagal mengirim pengajuan: " + e.message };
  }
}

/**
 * [BARU] Mengambil status pengajuan terakhir dari seorang pengguna.
 * @param {string} userEmail Email pengguna.
 * @returns {object|null} Objek berisi detail pengajuan terakhir atau null jika tidak ada.
 */
function getChangeRequestStatus(userEmail) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!pengajuanSheet || pengajuanSheet.getLastRow() < 2) {
      return null;
    }

    const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
    // Cari dari bawah ke atas untuk mendapatkan data terbaru
    for (let i = data.length - 1; i >= 0; i--) {
      if (data[i][1] === userEmail) {
        // Ditemukan ajuan terakhir dari pengguna ini
        return {
          requestId: data[i][0],
          userEmail: data[i][1],
          oldJenjang: data[i][2],
          oldNamaSekolah: data[i][3],
          newJenjang: data[i][4],
          newNamaSekolah: data[i][5],
          requestDate: data[i][6],
          status: data[i][7],
          adminNotes: data[i][8],
          resolvedDate: data[i][9]
        };
      }
    }
    return null; // Tidak ada ajuan dari pengguna ini
  } catch (e) {
    Logger.log(`getChangeRequestStatus Error: ${e.toString()}`);
    return null;
  }
}

/**
 * [BARU] Helper function untuk mencari baris pengguna berdasarkan email.
 * @param {string} email Email pengguna.
 * @returns {Array|null} Array data baris pengguna atau null.
 */
function findUserRowByEmail(email) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
    if (!userSheet || userSheet.getLastRow() < 2) return null;
    const users = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
    return users.find(userRow => userRow[1].toLowerCase() === email.toLowerCase());
}

/**
 * [SUPERADMIN] Mengambil semua data pengajuan perubahan data.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @returns {Array<object>} Array objek data pengajuan.
 */
function getChangeRequests_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    throw new Error("Akses ditolak.");
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!sheet || sheet.getLastRow() < 2) {
      return [];
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    
    const requests = data.map(row => ({
      requestId: row[0],
      userEmail: row[1],
      oldJenjang: row[2],
      oldNamaSekolah: row[3],
      newJenjang: row[4],
      newNamaSekolah: row[5],
      // Mengubah format tanggal menjadi string ISO agar aman saat diurutkan
      requestDate: row[6] instanceof Date ? row[6].toISOString() : new Date().toISOString(),
      status: row[7]
    })).filter(req => req.requestId); // Filter baris yang tidak punya ID

    // Urutkan agar yang "Menunggu Persetujuan" selalu di atas
    requests.sort((a, b) => {
        if (a.status === 'Menunggu Persetujuan' && b.status !== 'Menunggu Persetujuan') return -1;
        if (a.status !== 'Menunggu Persetujuan' && b.status === 'Menunggu Persetujuan') return 1;
        // Sekarang pengurutan tanggal lebih aman
        return new Date(b.requestDate).getTime() - new Date(a.requestDate).getTime();
    });

    return requests;

  } catch (e) {
    Logger.log("getChangeRequests_Superadmin Error: " + e.message);
    // Jika terjadi error, kembalikan array kosong agar tidak merusak UI
    return [];
  }
}


/**
 * [SUPERADMIN] Memproses (menyetujui/menolak) pengajuan perubahan data.
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @param {string} requestId ID dari pengajuan yang akan diproses.
 * @param {string} resolution Keputusan ('Disetujui' atau 'Ditolak').
 * @param {string} adminNotes Catatan dari admin (khusus jika ditolak).
 * @returns {{status: string, message: string}} Hasil proses.
 */
function resolveChangeRequest_Superadmin(adminEmail, requestId, resolution, adminNotes) {
  if (!isSuperadmin(adminEmail)) {
    return { status: "error", message: "Akses ditolak." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Kunci proses untuk menghindari double-processing

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    const dataRange = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn());
    const data = dataRange.getValues();

    const requestIndex = data.findIndex(row => row[0] === requestId);

    if (requestIndex === -1) {
      return { status: "error", message: "Pengajuan tidak ditemukan." };
    }
    
    const requestRow = data[requestIndex];
    if (requestRow[7] !== 'Menunggu Persetujuan') {
      return { status: "error", message: "Pengajuan ini sudah pernah diproses." };
    }

    const userEmail = requestRow[1];
    const newJenjang = requestRow[4];
    const newNamaSekolah = requestRow[5];

    // Jika disetujui, lakukan perubahan data.
    if (resolution === 'Disetujui') {
      const userSheet = ss.getSheetByName(SHEET_PENGGUNA);
      const usersData = userSheet.getRange(2, 1, userSheet.getLastRow() - 1, 9).getValues();
      const userIndex = usersData.findIndex(row => row[1] === userEmail);
      
      if (userIndex !== -1) {
        const userRowNumber = userIndex + 2;
        
        // 1. Update di sheet Data Pengguna
        userSheet.getRange(userRowNumber, 4).setValue(newNamaSekolah); // Kolom D
        userSheet.getRange(userRowNumber, 5).setValue(newJenjang);    // Kolom E
        
        // 2. Update di spreadsheet sekolah yang bersangkutan
        const schoolSsId = usersData[userIndex][5]; // Kolom F
        if (schoolSsId) {
            const schoolSs = SpreadsheetApp.openById(schoolSsId);
            const dataSekolahSheet = schoolSs.getSheetByName(SHEET_DATA_SEKOLAH);
            if (dataSekolahSheet) {
              dataSekolahSheet.getRange("A2").setValue(newJenjang);
              dataSekolahSheet.getRange("B2").setValue(newNamaSekolah);
            }
        }
      } else {
         throw new Error(`Pengguna dengan email ${userEmail} tidak ditemukan di Data Pengguna.`);
      }
    }

    // Update status di sheet Data Pengajuan
    const targetRowInSheet = requestIndex + 2;
    pengajuanSheet.getRange(targetRowInSheet, 8).setValue(resolution); // Status
    pengajuanSheet.getRange(targetRowInSheet, 9).setValue(adminNotes); // Catatan Admin
    pengajuanSheet.getRange(targetRowInSheet, 10).setValue(new Date()); // Tanggal Diproses

    return { status: 'success', message: `Pengajuan berhasil ${resolution.toLowerCase()}.` };

  } catch (e) {
    Logger.log("resolveChangeRequest_Superadmin Error: " + e.message);
    return { status: "error", message: "Gagal memproses pengajuan: " + e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN] Menghitung jumlah pengajuan yang berstatus "Menunggu Persetujuan".
 * @param {string} adminEmail Email superadmin untuk verifikasi.
 * @returns {{status: string, count: number}} Objek berisi status dan jumlah hitungan.
 */
function getPendingRequestCount_Superadmin(adminEmail) {
  if (!isSuperadmin(adminEmail)) {
    // Sebaiknya tidak melempar error agar tidak mengganggu UI jika terjadi masalah sesi
    return { status: "error", count: 0 }; 
  }
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!sheet || sheet.getLastRow() < 2) {
      return { status: "success", count: 0 };
    }

    // Ambil hanya kolom status (kolom H, indeks 7) untuk efisiensi
    const statusColumn = sheet.getRange(2, 8, sheet.getLastRow() - 1, 1).getValues();
    
    // Hitung yang statusnya "Menunggu Persetujuan"
    const pendingCount = statusColumn.filter(row => row[0] === 'Menunggu Persetujuan').length;
    
    return { status: "success", count: pendingCount };

  } catch (e) {
    Logger.log("getPendingRequestCount_Superadmin Error: " + e.message);
    return { status: "error", count: 0 };
  }
}

/**
 * [BARU] Mengambil SEMUA riwayat pengajuan perubahan data untuk seorang pengguna.
 * @param {string} userEmail Email pengguna.
 * @returns {Array<object>} Array berisi semua objek pengajuan, diurutkan dari terbaru.
 */
function getChangeRequestHistory_User(userEmail) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pengajuanSheet = ss.getSheetByName(SHEET_PENGAJUAN);
    if (!pengajuanSheet || pengajuanSheet.getLastRow() < 2) {
      return []; // Kembalikan array kosong jika tidak ada data
    }

    const data = pengajuanSheet.getRange(2, 1, pengajuanSheet.getLastRow() - 1, pengajuanSheet.getLastColumn()).getValues();
    
    // 1. Filter untuk mendapatkan semua baris milik pengguna ini
    const userRequests = data.filter(row => row[1] === userEmail);

    // 2. Ubah menjadi objek dan urutkan dari yang terbaru
    const history = userRequests.map(row => ({
        requestId: row[0],
        requestDate: row[6] instanceof Date ? row[6].toISOString() : new Date().toISOString(),
        oldJenjang: row[2],
        oldNamaSekolah: row[3],
        newJenjang: row[4],
        newNamaSekolah: row[5],
        status: row[7],
        adminNotes: row[8]
    })).sort((a, b) => new Date(b.requestDate).getTime() - new Date(a.requestDate).getTime());

    return history;

  } catch (e) {
    Logger.log(`getChangeRequestHistory_User Error: ${e.toString()}`);
    return []; // Kembalikan array kosong jika terjadi error
  }
}

// =================================================================
// FUNGSI BACKUP & RESTORE
// =================================================================

/**
 * [BARU] Membuat folder backup khusus untuk sekolah jika belum ada.
 * @param {string} spreadsheetId ID spreadsheet sekolah.
 * @returns {DriveApp.Folder} Objek folder backup.
 */
function getOrCreateBackupFolder(spreadsheetId) {
  const ss = SpreadsheetApp.openById(spreadsheetId);
  const schoolName = ss.getSheetByName(SHEET_DATA_SEKOLAH).getRange("B2").getValue();
  const parentFolder = DriveApp.getFileById(SpreadsheetApp.getActiveSpreadsheet().getId()).getParents().next();

  const backupFolderName = `Backups Aplikasi Ijazah`;
  let backupRootFolder = parentFolder.getFoldersByName(backupFolderName);
  
  if (backupRootFolder.hasNext()) {
    backupRootFolder = backupRootFolder.next();
  } else {
    backupRootFolder = parentFolder.createFolder(backupFolderName);
  }

  const schoolBackupFolderName = `Backup - ${schoolName}`;
  let schoolFolder = backupRootFolder.getFoldersByName(schoolBackupFolderName);

  if (schoolFolder.hasNext()) {
    return schoolFolder.next();
  } else {
    return backupRootFolder.createFolder(schoolBackupFolderName);
  }
}

/**
 * [BARU] Membuat file backup dari spreadsheet pengguna.
 * @param {string} spreadsheetId ID spreadsheet yang akan di-backup.
 * @returns {object} Status pembuatan backup.
 */
function createBackup(spreadsheetId) {
  try {
    const liveFile = DriveApp.getFileById(spreadsheetId);
    const backupFolder = getOrCreateBackupFolder(spreadsheetId);
    
    const now = new Date();
    const timestamp = Utilities.formatDate(now, Session.getScriptTimeZone(), "yyyy-MM-dd_HH-mm-ss");
    const schoolName = SpreadsheetApp.openById(spreadsheetId).getName();
    
    const backupFileName = `[BACKUP] ${schoolName} (${timestamp})`;
    
    liveFile.makeCopy(backupFileName, backupFolder);
    
    return { status: "success", message: `Backup '${backupFileName}' berhasil dibuat.` };
  } catch (e) {
    Logger.log(`createBackup Error: ${e}`);
    return { status: "error", message: `Gagal membuat backup: ${e.message}` };
  }
}

/**
 * [BARU] Mengambil daftar file backup yang tersedia untuk pengguna.
 * @param {string} spreadsheetId ID spreadsheet pengguna.
 * @returns {object} Daftar file backup.
 */
function getBackupList(spreadsheetId) {
  try {
    const backupFolder = getOrCreateBackupFolder(spreadsheetId);
    const filesIterator = backupFolder.getFiles();
    const backupList = [];
    
    while (filesIterator.hasNext()) {
      const file = filesIterator.next();
      backupList.push({
        id: file.getId(),
        name: file.getName(),
        date: file.getDateCreated().toISOString() // Format standar untuk sorting
      });
    }
    
    // Urutkan dari yang terbaru ke yang terlama
    backupList.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    return { status: "success", backups: backupList };
  } catch (e) {
    Logger.log(`getBackupList Error: ${e}`);
    return { status: "error", message: `Gagal mengambil daftar backup: ${e.message}` };
  }
}

/**
 * [BARU] Menghapus file backup tertentu.
 * @param {string} backupFileId ID file backup yang akan dihapus.
 * @returns {object} Status penghapusan.
 */
function deleteBackup(backupFileId) {
    try {
        const file = DriveApp.getFileById(backupFileId);
        file.setTrashed(true);
        return { status: 'success', message: 'File backup berhasil dihapus.' };
    } catch (e) {
        Logger.log(`deleteBackup Error: ${e}`);
        return { status: 'error', message: 'Gagal menghapus file backup: ' + e.message };
    }
}


/**
 * [VERSI 3.0 - POLLING] Memulihkan data dari file backup ke file utama.
 * Fungsi ini sekarang hanya berjalan di latar belakang dan mengatur status di Cache.
 * @param {string} liveSpreadsheetId ID spreadsheet utama yang akan ditimpa.
 * @param {string} backupSpreadsheetId ID spreadsheet backup sumber data.
 */
function restoreFromBackup(liveSpreadsheetId, backupSpreadsheetId) {
  const cache = CacheService.getScriptCache();
  const user = Session.getActiveUser().getEmail();
  const statusKey = `restore_status_${user}`;

  // Set status 'berjalan' sebelum memulai
  cache.put(statusKey, 'running', 21600); // Simpan status selama 6 jam

  try {
    const liveSs = SpreadsheetApp.openById(liveSpreadsheetId);
    const backupSs = SpreadsheetApp.openById(backupSpreadsheetId);

    const backupSheets = backupSs.getSheets();
    const liveSheetNames = liveSs.getSheets().map(s => s.getName());
    const backupSheetNames = backupSheets.map(s => s.getName());

    backupSheets.forEach((backupSheet, index) => {
      const sheetName = backupSheet.getName();
      const oldLiveSheet = liveSs.getSheetByName(sheetName);

      if (oldLiveSheet) {
        liveSs.deleteSheet(oldLiveSheet);
      }

      const newCopiedSheet = backupSheet.copyTo(liveSs);
      newCopiedSheet.setName(sheetName);
      liveSs.setActiveSheet(newCopiedSheet);
      liveSs.moveActiveSheet(index + 1);
    });

    liveSheetNames.forEach(liveName => {
        if (!backupSheetNames.includes(liveName)) {
            const extraSheet = liveSs.getSheetByName(liveName);
            if (extraSheet) {
                liveSs.deleteSheet(extraSheet);
            }
        }
    });

    // Set status 'selesai' jika berhasil
    cache.put(statusKey, 'complete', 300); // Simpan status 'complete' selama 5 menit

  } catch (e) {
    Logger.log(`restoreFromBackup Error: ${e.toString()}`);
    // Set status 'error' jika gagal
    cache.put(statusKey, `error: ${e.message}`, 300);
  }
}

/**
 * [BARU - POLLING] Fungsi cepat untuk memeriksa status proses restore.
 * @returns {string|null} Status saat ini: 'running', 'complete', 'error', atau null.
 */
function getRestoreStatus() {
  const cache = CacheService.getScriptCache();
  const user = Session.getActiveUser().getEmail();
  const statusKey = `restore_status_${user}`;
  return cache.get(statusKey);
}
